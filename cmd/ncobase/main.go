package main

import (
	"context"
	"errors"
	"fmt"
	"ncobase/cmd/bootstrap"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"syscall"
	"time"

	"ncobase/common/config"
	"ncobase/common/log"

	_ "ncobase/docs" // docs is generated by Swag CLI, you have to import it.
)

const (
	shutdownTimeout = 3 * time.Second // service shutdown timeout
)

// @title Ncobase
// @version 0.1.0
// @description Next-Gen Plug-in Framework
// @securityDefinitions.apikey Bearer
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.
// @termsOfService https://ncobase.com
func main() {
	// load config
	conf := loadConfig()

	// watch config file changes
	config.Watch(func(newConfig *config.Config) {
		log.Infof(context.Background(), "Configuration reloaded: %+v", newConfig)
		restartApplication()
	})

	// initialize logger
	cleanupLogger := initializeLogger(conf)
	defer cleanupLogger()

	log.Infof(context.Background(), "Application Name: %s", conf.AppName)

	// create server
	handler, cleanup, err := createServer(conf)
	if err != nil {
		log.Fatalf(context.Background(), "‚ùå [Server] Failed to start: %+v", err)
	}
	defer cleanup()

	// start server
	addr := fmt.Sprintf("%s:%d", conf.Host, conf.Port)
	srv := &http.Server{
		Addr:    addr,
		Handler: handler,
	}
	log.Infof(context.Background(), "üöÄ [Server] Listening and serving HTTP on: %s", addr)

	// listen and serve
	go func() {
		if err := srv.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			log.Fatalf(context.Background(), "‚ùå [Server] Listen: %s", err)
		}
	}()

	gracefulShutdown(srv)
}

// loadConfig loads the application configuration.
func loadConfig() *config.Config {
	conf, err := config.Init()
	if err != nil {
		log.Fatalf(context.Background(), "‚ùå [Config] Initialization error: %+v", err)
	}
	return conf
}

func initializeLogger(conf *config.Config) func() {
	cleanupLogger, err := log.Init(conf.Logger)
	if err != nil {
		log.Fatalf(context.Background(), "‚ùå [Logger] Initialization error: %+v", err)
	}
	return cleanupLogger
}

// createServer creates and initializes the server.
func createServer(conf *config.Config) (http.Handler, func(), error) {
	handler, cleanup, err := bootstrap.New(conf)
	if err != nil {
		return nil, nil, err
	}
	return handler, cleanup, nil
}

// restartApplication restarts the application.
func restartApplication() {
	log.Infof(context.Background(), "üîÑ [Restart] Restarting application...")

	execSpec := &exec.Cmd{
		Path:   os.Args[0],
		Args:   os.Args,
		Env:    os.Environ(),
		Stdout: os.Stdout,
		Stderr: os.Stderr,
	}

	if err := execSpec.Start(); err != nil {
		log.Fatalf(context.Background(), "‚ùå [Restart] Failed to restart application: %+v", err)
	}

	log.Infof(context.Background(), "üëã [Restart] Exiting old process")
	os.Exit(0)
}

// gracefulShutdown gracefully shuts down the server.
func gracefulShutdown(srv *http.Server) {
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	log.Infof(context.Background(), "‚åõÔ∏è [Server] Graceful shutdown in progress...")

	ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		log.Fatalf(context.Background(), "‚ùå [Server] Shutdown: %+v", err)
	}

	select {
	case <-ctx.Done():
		log.Infof(context.Background(), "‚åõÔ∏è [Server] Shutdown completed within %s", shutdownTimeout)
	}

	log.Infof(context.Background(), "üëã [Server] Exiting")
}
