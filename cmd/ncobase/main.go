package main

import (
	"context"
	"errors"
	"fmt"
	"ncobase/cmd/ncobase/service"
	"ncobase/common/helper"
	"ncobase/common/observes"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"ncobase/common/config"
	"ncobase/common/log"

	_ "ncobase/docs/swagger" // generated by Swag CLI
)

const (
	shutdownTimeout = 3 * time.Second // service shutdown timeout
)

// @title Ncobase
// @version 0.1.0
// @description Base Development Framework
// @securityDefinitions.apikey Bearer
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.
// @termsOfService https://ncobase.com
func main() {
	log.SetVersion(helper.Version)
	// load config
	conf := loadConfig()

	// watch config file changes
	// config.Watch(func(newConfig *config.Config) {
	// 	log.Infof(context.Background(), "Configuration reloaded: %+v", newConfig)
	// 	// Implement config reload logic here
	// 	// restartApplication()
	// })

	appName := strings.ToLower(conf.AppName)

	// init tracer
	if conf.Observes != nil && conf.Observes.Tracer != nil && conf.Observes.Tracer.Endpoint != "" {
		err := observes.NewTracer(&observes.TracerOption{
			URL:                conf.Observes.Tracer.Endpoint,
			Name:               strings.ToLower(conf.AppName),
			Version:            helper.Version,
			Branch:             helper.Branch,
			Revision:           helper.Revision,
			Environment:        conf.RunMode,
			SamplingRate:       1.0,
			MaxAttributes:      100,
			BatchTimeout:       5 * time.Second,
			ExportTimeout:      30 * time.Second,
			MaxExportBatchSize: 512,
		})
		if err != nil {
			log.Errorf(context.Background(), "tracer.Init: %s", err)
		}
	}
	// init sentry
	if conf.Observes != nil && conf.Observes.Sentry != nil && conf.Observes.Sentry.Endpoint != "" {
		if err := observes.NewSentry(&observes.SentryOptions{
			Dsn:         conf.Observes.Sentry.Endpoint,
			Name:        appName,
			Release:     helper.Version,
			Environment: conf.RunMode,
		}); err != nil {
			log.Errorf(context.Background(), "sentry.Init: %s", err)
		}
	}

	// initialize logger
	cleanupLogger := initializeLogger(conf)
	defer cleanupLogger()

	log.Infof(context.Background(), "Starting: %s", appName)

	// create server
	handler, cleanup, err := createServer(conf)
	if err != nil {
		log.Fatalf(context.Background(), "Failed to start: %+v", err)
	}
	defer cleanup()

	// start server
	var srv *http.Server
	var listener net.Listener

	if conf.Port == 0 {
		listener, err = net.Listen("tcp", fmt.Sprintf("%s:0", conf.Host))
		if err != nil {
			log.Fatalf(context.Background(), "Error starting server: %v", err)
		}
		conf.Port = listener.Addr().(*net.TCPAddr).Port
	} else {
		listener, err = net.Listen("tcp", fmt.Sprintf("%s:%d", conf.Host, conf.Port))
		if err != nil {
			log.Fatalf(context.Background(), "Error starting server: %v", err)
		}
	}

	defer func(listener net.Listener) {
		_ = listener.Close()
	}(listener)

	srv = &http.Server{
		Addr:    fmt.Sprintf("%s:%d", conf.Host, conf.Port),
		Handler: handler,
	}

	log.Infof(context.Background(), "Listening and serving HTTP on: %s", srv.Addr)

	// listen and serve
	go func() {
		if err := srv.Serve(listener); err != nil {
			if !errors.Is(err, http.ErrServerClosed) {
				log.Errorf(context.Background(), "Listen error: %s", err)
			} else {
				log.Infof(context.Background(), "Server closed")
			}
		}
	}()

	gracefulShutdown(srv)
}

// loadConfig loads the application configuration.
func loadConfig() *config.Config {
	conf, err := config.Init()
	if err != nil {
		log.Fatalf(context.Background(), "[Config] Initialization error: %+v", err)
	}
	return conf
}

func initializeLogger(conf *config.Config) func() {
	cleanupLogger, err := log.Init(conf.Logger)
	if err != nil {
		log.Fatalf(context.Background(), "[Logger] Initialization error: %+v", err)
	}
	return cleanupLogger
}

// createServer creates and initializes the server.
func createServer(conf *config.Config) (http.Handler, func(), error) {
	handler, cleanup, err := service.NewServer(conf)
	if err != nil {
		return nil, nil, err
	}
	return handler, cleanup, nil
}

// restartApplication restarts the application.
// func restartApplication() {
// 	log.Infof(context.Background(), "Restarting application...")
//
// 	execSpec := &exec.Cmd{
// 		Path:   os.Args[0],
// 		Args:   os.Args,
// 		Env:    os.Environ(),
// 		Stdout: os.Stdout,
// 		Stderr: os.Stderr,
// 	}
//
// 	if err := execSpec.Start(); err != nil {
// 		log.Fatalf(context.Background(), "Failed to restart application: %+v", err)
// 	}
//
// 	log.Infof(context.Background(), "Exiting old process")
// 	os.Exit(0)
// }

// gracefulShutdown gracefully shuts down the server.
func gracefulShutdown(srv *http.Server) {
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	log.Infof(context.Background(), "Graceful shutdown in progress...")

	ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
	defer cancel()

	// Then shutdown the server
	if err := srv.Shutdown(ctx); err != nil {
		log.Errorf(context.Background(), "Shutdown error: %v", err)
	}

	select {
	case <-ctx.Done():
		if errors.Is(ctx.Err(), context.DeadlineExceeded) {
			log.Warnf(context.Background(), "Shutdown timed out after %s", shutdownTimeout)
		} else {
			log.Infof(context.Background(), "Shutdown completed within %s", shutdownTimeout)
		}
	}

	log.Infof(context.Background(), "Exiting")
}
