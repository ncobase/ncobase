// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"ncobase/payment/data/ent/paymentchannel"
	"ncobase/payment/data/ent/paymentlog"
	"ncobase/payment/data/ent/paymentorder"
	"ncobase/payment/data/ent/paymentproduct"
	"ncobase/payment/data/ent/paymentsubscription"
	"ncobase/payment/data/ent/predicate"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypePaymentChannel      = "PaymentChannel"
	TypePaymentLog          = "PaymentLog"
	TypePaymentOrder        = "PaymentOrder"
	TypePaymentProduct      = "PaymentProduct"
	TypePaymentSubscription = "PaymentSubscription"
)

// PaymentChannelMutation represents an operation that mutates the PaymentChannel nodes in the graph.
type PaymentChannelMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	name                  *string
	description           *string
	extras                *map[string]interface{}
	created_by            *string
	updated_by            *string
	created_at            *int64
	addcreated_at         *int64
	updated_at            *int64
	addupdated_at         *int64
	provider              *string
	status                *string
	is_default            *bool
	supported_types       *[]string
	appendsupported_types []string
	_config               *map[string]interface{}
	tenant_id             *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*PaymentChannel, error)
	predicates            []predicate.PaymentChannel
}

var _ ent.Mutation = (*PaymentChannelMutation)(nil)

// paymentchannelOption allows management of the mutation configuration using functional options.
type paymentchannelOption func(*PaymentChannelMutation)

// newPaymentChannelMutation creates new mutation for the PaymentChannel entity.
func newPaymentChannelMutation(c config, op Op, opts ...paymentchannelOption) *PaymentChannelMutation {
	m := &PaymentChannelMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentChannelID sets the ID field of the mutation.
func withPaymentChannelID(id string) paymentchannelOption {
	return func(m *PaymentChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentChannel
		)
		m.oldValue = func(ctx context.Context) (*PaymentChannel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentChannel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentChannel sets the old PaymentChannel of the mutation.
func withPaymentChannel(node *PaymentChannel) paymentchannelOption {
	return func(m *PaymentChannelMutation) {
		m.oldValue = func(context.Context) (*PaymentChannel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentChannel entities.
func (m *PaymentChannelMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentChannelMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentChannelMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentChannel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PaymentChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PaymentChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PaymentChannelMutation) ClearName() {
	m.name = nil
	m.clearedFields[paymentchannel.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PaymentChannelMutation) NameCleared() bool {
	_, ok := m.clearedFields[paymentchannel.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PaymentChannelMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, paymentchannel.FieldName)
}

// SetDescription sets the "description" field.
func (m *PaymentChannelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PaymentChannelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PaymentChannelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[paymentchannel.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PaymentChannelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[paymentchannel.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PaymentChannelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, paymentchannel.FieldDescription)
}

// SetExtras sets the "extras" field.
func (m *PaymentChannelMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *PaymentChannelMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *PaymentChannelMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[paymentchannel.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *PaymentChannelMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[paymentchannel.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *PaymentChannelMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, paymentchannel.FieldExtras)
}

// SetCreatedBy sets the "created_by" field.
func (m *PaymentChannelMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PaymentChannelMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PaymentChannelMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[paymentchannel.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PaymentChannelMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[paymentchannel.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PaymentChannelMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, paymentchannel.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PaymentChannelMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PaymentChannelMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PaymentChannelMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[paymentchannel.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PaymentChannelMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[paymentchannel.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PaymentChannelMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, paymentchannel.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentChannelMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentChannelMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *PaymentChannelMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PaymentChannelMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PaymentChannelMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[paymentchannel.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PaymentChannelMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[paymentchannel.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentChannelMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, paymentchannel.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentChannelMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentChannelMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *PaymentChannelMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PaymentChannelMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PaymentChannelMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[paymentchannel.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PaymentChannelMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[paymentchannel.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, paymentchannel.FieldUpdatedAt)
}

// SetProvider sets the "provider" field.
func (m *PaymentChannelMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *PaymentChannelMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *PaymentChannelMutation) ResetProvider() {
	m.provider = nil
}

// SetStatus sets the "status" field.
func (m *PaymentChannelMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentChannelMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentChannelMutation) ResetStatus() {
	m.status = nil
}

// SetIsDefault sets the "is_default" field.
func (m *PaymentChannelMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *PaymentChannelMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *PaymentChannelMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetSupportedTypes sets the "supported_types" field.
func (m *PaymentChannelMutation) SetSupportedTypes(s []string) {
	m.supported_types = &s
	m.appendsupported_types = nil
}

// SupportedTypes returns the value of the "supported_types" field in the mutation.
func (m *PaymentChannelMutation) SupportedTypes() (r []string, exists bool) {
	v := m.supported_types
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportedTypes returns the old "supported_types" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldSupportedTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportedTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportedTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportedTypes: %w", err)
	}
	return oldValue.SupportedTypes, nil
}

// AppendSupportedTypes adds s to the "supported_types" field.
func (m *PaymentChannelMutation) AppendSupportedTypes(s []string) {
	m.appendsupported_types = append(m.appendsupported_types, s...)
}

// AppendedSupportedTypes returns the list of values that were appended to the "supported_types" field in this mutation.
func (m *PaymentChannelMutation) AppendedSupportedTypes() ([]string, bool) {
	if len(m.appendsupported_types) == 0 {
		return nil, false
	}
	return m.appendsupported_types, true
}

// ResetSupportedTypes resets all changes to the "supported_types" field.
func (m *PaymentChannelMutation) ResetSupportedTypes() {
	m.supported_types = nil
	m.appendsupported_types = nil
}

// SetConfig sets the "config" field.
func (m *PaymentChannelMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *PaymentChannelMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *PaymentChannelMutation) ResetConfig() {
	m._config = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *PaymentChannelMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PaymentChannelMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PaymentChannel entity.
// If the PaymentChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentChannelMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *PaymentChannelMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[paymentchannel.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *PaymentChannelMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[paymentchannel.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PaymentChannelMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, paymentchannel.FieldTenantID)
}

// Where appends a list predicates to the PaymentChannelMutation builder.
func (m *PaymentChannelMutation) Where(ps ...predicate.PaymentChannel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentChannel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentChannel).
func (m *PaymentChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentChannelMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, paymentchannel.FieldName)
	}
	if m.description != nil {
		fields = append(fields, paymentchannel.FieldDescription)
	}
	if m.extras != nil {
		fields = append(fields, paymentchannel.FieldExtras)
	}
	if m.created_by != nil {
		fields = append(fields, paymentchannel.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, paymentchannel.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, paymentchannel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentchannel.FieldUpdatedAt)
	}
	if m.provider != nil {
		fields = append(fields, paymentchannel.FieldProvider)
	}
	if m.status != nil {
		fields = append(fields, paymentchannel.FieldStatus)
	}
	if m.is_default != nil {
		fields = append(fields, paymentchannel.FieldIsDefault)
	}
	if m.supported_types != nil {
		fields = append(fields, paymentchannel.FieldSupportedTypes)
	}
	if m._config != nil {
		fields = append(fields, paymentchannel.FieldConfig)
	}
	if m.tenant_id != nil {
		fields = append(fields, paymentchannel.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentchannel.FieldName:
		return m.Name()
	case paymentchannel.FieldDescription:
		return m.Description()
	case paymentchannel.FieldExtras:
		return m.Extras()
	case paymentchannel.FieldCreatedBy:
		return m.CreatedBy()
	case paymentchannel.FieldUpdatedBy:
		return m.UpdatedBy()
	case paymentchannel.FieldCreatedAt:
		return m.CreatedAt()
	case paymentchannel.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentchannel.FieldProvider:
		return m.Provider()
	case paymentchannel.FieldStatus:
		return m.Status()
	case paymentchannel.FieldIsDefault:
		return m.IsDefault()
	case paymentchannel.FieldSupportedTypes:
		return m.SupportedTypes()
	case paymentchannel.FieldConfig:
		return m.Config()
	case paymentchannel.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentchannel.FieldName:
		return m.OldName(ctx)
	case paymentchannel.FieldDescription:
		return m.OldDescription(ctx)
	case paymentchannel.FieldExtras:
		return m.OldExtras(ctx)
	case paymentchannel.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case paymentchannel.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case paymentchannel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentchannel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentchannel.FieldProvider:
		return m.OldProvider(ctx)
	case paymentchannel.FieldStatus:
		return m.OldStatus(ctx)
	case paymentchannel.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case paymentchannel.FieldSupportedTypes:
		return m.OldSupportedTypes(ctx)
	case paymentchannel.FieldConfig:
		return m.OldConfig(ctx)
	case paymentchannel.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentChannel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentchannel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case paymentchannel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case paymentchannel.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case paymentchannel.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case paymentchannel.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case paymentchannel.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentchannel.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentchannel.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case paymentchannel.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case paymentchannel.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case paymentchannel.FieldSupportedTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportedTypes(v)
		return nil
	case paymentchannel.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case paymentchannel.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentChannel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentChannelMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, paymentchannel.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, paymentchannel.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentChannelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentchannel.FieldCreatedAt:
		return m.AddedCreatedAt()
	case paymentchannel.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentchannel.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case paymentchannel.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentChannel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentchannel.FieldName) {
		fields = append(fields, paymentchannel.FieldName)
	}
	if m.FieldCleared(paymentchannel.FieldDescription) {
		fields = append(fields, paymentchannel.FieldDescription)
	}
	if m.FieldCleared(paymentchannel.FieldExtras) {
		fields = append(fields, paymentchannel.FieldExtras)
	}
	if m.FieldCleared(paymentchannel.FieldCreatedBy) {
		fields = append(fields, paymentchannel.FieldCreatedBy)
	}
	if m.FieldCleared(paymentchannel.FieldUpdatedBy) {
		fields = append(fields, paymentchannel.FieldUpdatedBy)
	}
	if m.FieldCleared(paymentchannel.FieldCreatedAt) {
		fields = append(fields, paymentchannel.FieldCreatedAt)
	}
	if m.FieldCleared(paymentchannel.FieldUpdatedAt) {
		fields = append(fields, paymentchannel.FieldUpdatedAt)
	}
	if m.FieldCleared(paymentchannel.FieldTenantID) {
		fields = append(fields, paymentchannel.FieldTenantID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentChannelMutation) ClearField(name string) error {
	switch name {
	case paymentchannel.FieldName:
		m.ClearName()
		return nil
	case paymentchannel.FieldDescription:
		m.ClearDescription()
		return nil
	case paymentchannel.FieldExtras:
		m.ClearExtras()
		return nil
	case paymentchannel.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case paymentchannel.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case paymentchannel.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case paymentchannel.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case paymentchannel.FieldTenantID:
		m.ClearTenantID()
		return nil
	}
	return fmt.Errorf("unknown PaymentChannel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentChannelMutation) ResetField(name string) error {
	switch name {
	case paymentchannel.FieldName:
		m.ResetName()
		return nil
	case paymentchannel.FieldDescription:
		m.ResetDescription()
		return nil
	case paymentchannel.FieldExtras:
		m.ResetExtras()
		return nil
	case paymentchannel.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case paymentchannel.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case paymentchannel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentchannel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentchannel.FieldProvider:
		m.ResetProvider()
		return nil
	case paymentchannel.FieldStatus:
		m.ResetStatus()
		return nil
	case paymentchannel.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case paymentchannel.FieldSupportedTypes:
		m.ResetSupportedTypes()
		return nil
	case paymentchannel.FieldConfig:
		m.ResetConfig()
		return nil
	case paymentchannel.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown PaymentChannel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentChannelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentChannelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentChannelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentChannelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PaymentChannel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentChannelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PaymentChannel edge %s", name)
}

// PaymentLogMutation represents an operation that mutates the PaymentLog nodes in the graph.
type PaymentLogMutation struct {
	config
	op            Op
	typ           string
	id            *string
	extras        *map[string]interface{}
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	channel_id    *string
	_type         *string
	status_before *string
	status_after  *string
	request_data  *string
	response_data *string
	ip            *string
	user_agent    *string
	user_id       *string
	error         *string
	clearedFields map[string]struct{}
	_order        *string
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*PaymentLog, error)
	predicates    []predicate.PaymentLog
}

var _ ent.Mutation = (*PaymentLogMutation)(nil)

// paymentlogOption allows management of the mutation configuration using functional options.
type paymentlogOption func(*PaymentLogMutation)

// newPaymentLogMutation creates new mutation for the PaymentLog entity.
func newPaymentLogMutation(c config, op Op, opts ...paymentlogOption) *PaymentLogMutation {
	m := &PaymentLogMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentLogID sets the ID field of the mutation.
func withPaymentLogID(id string) paymentlogOption {
	return func(m *PaymentLogMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentLog
		)
		m.oldValue = func(ctx context.Context) (*PaymentLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentLog sets the old PaymentLog of the mutation.
func withPaymentLog(node *PaymentLog) paymentlogOption {
	return func(m *PaymentLogMutation) {
		m.oldValue = func(context.Context) (*PaymentLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentLog entities.
func (m *PaymentLogMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentLogMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentLogMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExtras sets the "extras" field.
func (m *PaymentLogMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *PaymentLogMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *PaymentLogMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[paymentlog.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *PaymentLogMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[paymentlog.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *PaymentLogMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, paymentlog.FieldExtras)
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentLogMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentLogMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *PaymentLogMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PaymentLogMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PaymentLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[paymentlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PaymentLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[paymentlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentLogMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, paymentlog.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentLogMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentLogMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *PaymentLogMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PaymentLogMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PaymentLogMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[paymentlog.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PaymentLogMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[paymentlog.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, paymentlog.FieldUpdatedAt)
}

// SetOrderID sets the "order_id" field.
func (m *PaymentLogMutation) SetOrderID(s string) {
	m._order = &s
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *PaymentLogMutation) OrderID() (r string, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldOrderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *PaymentLogMutation) ResetOrderID() {
	m._order = nil
}

// SetChannelID sets the "channel_id" field.
func (m *PaymentLogMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *PaymentLogMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *PaymentLogMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetType sets the "type" field.
func (m *PaymentLogMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PaymentLogMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PaymentLogMutation) ResetType() {
	m._type = nil
}

// SetStatusBefore sets the "status_before" field.
func (m *PaymentLogMutation) SetStatusBefore(s string) {
	m.status_before = &s
}

// StatusBefore returns the value of the "status_before" field in the mutation.
func (m *PaymentLogMutation) StatusBefore() (r string, exists bool) {
	v := m.status_before
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusBefore returns the old "status_before" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldStatusBefore(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusBefore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusBefore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusBefore: %w", err)
	}
	return oldValue.StatusBefore, nil
}

// ClearStatusBefore clears the value of the "status_before" field.
func (m *PaymentLogMutation) ClearStatusBefore() {
	m.status_before = nil
	m.clearedFields[paymentlog.FieldStatusBefore] = struct{}{}
}

// StatusBeforeCleared returns if the "status_before" field was cleared in this mutation.
func (m *PaymentLogMutation) StatusBeforeCleared() bool {
	_, ok := m.clearedFields[paymentlog.FieldStatusBefore]
	return ok
}

// ResetStatusBefore resets all changes to the "status_before" field.
func (m *PaymentLogMutation) ResetStatusBefore() {
	m.status_before = nil
	delete(m.clearedFields, paymentlog.FieldStatusBefore)
}

// SetStatusAfter sets the "status_after" field.
func (m *PaymentLogMutation) SetStatusAfter(s string) {
	m.status_after = &s
}

// StatusAfter returns the value of the "status_after" field in the mutation.
func (m *PaymentLogMutation) StatusAfter() (r string, exists bool) {
	v := m.status_after
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusAfter returns the old "status_after" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldStatusAfter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusAfter: %w", err)
	}
	return oldValue.StatusAfter, nil
}

// ClearStatusAfter clears the value of the "status_after" field.
func (m *PaymentLogMutation) ClearStatusAfter() {
	m.status_after = nil
	m.clearedFields[paymentlog.FieldStatusAfter] = struct{}{}
}

// StatusAfterCleared returns if the "status_after" field was cleared in this mutation.
func (m *PaymentLogMutation) StatusAfterCleared() bool {
	_, ok := m.clearedFields[paymentlog.FieldStatusAfter]
	return ok
}

// ResetStatusAfter resets all changes to the "status_after" field.
func (m *PaymentLogMutation) ResetStatusAfter() {
	m.status_after = nil
	delete(m.clearedFields, paymentlog.FieldStatusAfter)
}

// SetRequestData sets the "request_data" field.
func (m *PaymentLogMutation) SetRequestData(s string) {
	m.request_data = &s
}

// RequestData returns the value of the "request_data" field in the mutation.
func (m *PaymentLogMutation) RequestData() (r string, exists bool) {
	v := m.request_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestData returns the old "request_data" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldRequestData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestData: %w", err)
	}
	return oldValue.RequestData, nil
}

// ClearRequestData clears the value of the "request_data" field.
func (m *PaymentLogMutation) ClearRequestData() {
	m.request_data = nil
	m.clearedFields[paymentlog.FieldRequestData] = struct{}{}
}

// RequestDataCleared returns if the "request_data" field was cleared in this mutation.
func (m *PaymentLogMutation) RequestDataCleared() bool {
	_, ok := m.clearedFields[paymentlog.FieldRequestData]
	return ok
}

// ResetRequestData resets all changes to the "request_data" field.
func (m *PaymentLogMutation) ResetRequestData() {
	m.request_data = nil
	delete(m.clearedFields, paymentlog.FieldRequestData)
}

// SetResponseData sets the "response_data" field.
func (m *PaymentLogMutation) SetResponseData(s string) {
	m.response_data = &s
}

// ResponseData returns the value of the "response_data" field in the mutation.
func (m *PaymentLogMutation) ResponseData() (r string, exists bool) {
	v := m.response_data
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseData returns the old "response_data" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldResponseData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseData: %w", err)
	}
	return oldValue.ResponseData, nil
}

// ClearResponseData clears the value of the "response_data" field.
func (m *PaymentLogMutation) ClearResponseData() {
	m.response_data = nil
	m.clearedFields[paymentlog.FieldResponseData] = struct{}{}
}

// ResponseDataCleared returns if the "response_data" field was cleared in this mutation.
func (m *PaymentLogMutation) ResponseDataCleared() bool {
	_, ok := m.clearedFields[paymentlog.FieldResponseData]
	return ok
}

// ResetResponseData resets all changes to the "response_data" field.
func (m *PaymentLogMutation) ResetResponseData() {
	m.response_data = nil
	delete(m.clearedFields, paymentlog.FieldResponseData)
}

// SetIP sets the "ip" field.
func (m *PaymentLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *PaymentLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *PaymentLogMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[paymentlog.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *PaymentLogMutation) IPCleared() bool {
	_, ok := m.clearedFields[paymentlog.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *PaymentLogMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, paymentlog.FieldIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *PaymentLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *PaymentLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *PaymentLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[paymentlog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *PaymentLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[paymentlog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *PaymentLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, paymentlog.FieldUserAgent)
}

// SetUserID sets the "user_id" field.
func (m *PaymentLogMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PaymentLogMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *PaymentLogMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[paymentlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *PaymentLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[paymentlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PaymentLogMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, paymentlog.FieldUserID)
}

// SetError sets the "error" field.
func (m *PaymentLogMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *PaymentLogMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the PaymentLog entity.
// If the PaymentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentLogMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *PaymentLogMutation) ClearError() {
	m.error = nil
	m.clearedFields[paymentlog.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *PaymentLogMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[paymentlog.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *PaymentLogMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, paymentlog.FieldError)
}

// ClearOrder clears the "order" edge to the PaymentOrder entity.
func (m *PaymentLogMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[paymentlog.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the PaymentOrder entity was cleared.
func (m *PaymentLogMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *PaymentLogMutation) OrderIDs() (ids []string) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *PaymentLogMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the PaymentLogMutation builder.
func (m *PaymentLogMutation) Where(ps ...predicate.PaymentLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentLog).
func (m *PaymentLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentLogMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.extras != nil {
		fields = append(fields, paymentlog.FieldExtras)
	}
	if m.created_at != nil {
		fields = append(fields, paymentlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentlog.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, paymentlog.FieldOrderID)
	}
	if m.channel_id != nil {
		fields = append(fields, paymentlog.FieldChannelID)
	}
	if m._type != nil {
		fields = append(fields, paymentlog.FieldType)
	}
	if m.status_before != nil {
		fields = append(fields, paymentlog.FieldStatusBefore)
	}
	if m.status_after != nil {
		fields = append(fields, paymentlog.FieldStatusAfter)
	}
	if m.request_data != nil {
		fields = append(fields, paymentlog.FieldRequestData)
	}
	if m.response_data != nil {
		fields = append(fields, paymentlog.FieldResponseData)
	}
	if m.ip != nil {
		fields = append(fields, paymentlog.FieldIP)
	}
	if m.user_agent != nil {
		fields = append(fields, paymentlog.FieldUserAgent)
	}
	if m.user_id != nil {
		fields = append(fields, paymentlog.FieldUserID)
	}
	if m.error != nil {
		fields = append(fields, paymentlog.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentlog.FieldExtras:
		return m.Extras()
	case paymentlog.FieldCreatedAt:
		return m.CreatedAt()
	case paymentlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentlog.FieldOrderID:
		return m.OrderID()
	case paymentlog.FieldChannelID:
		return m.ChannelID()
	case paymentlog.FieldType:
		return m.GetType()
	case paymentlog.FieldStatusBefore:
		return m.StatusBefore()
	case paymentlog.FieldStatusAfter:
		return m.StatusAfter()
	case paymentlog.FieldRequestData:
		return m.RequestData()
	case paymentlog.FieldResponseData:
		return m.ResponseData()
	case paymentlog.FieldIP:
		return m.IP()
	case paymentlog.FieldUserAgent:
		return m.UserAgent()
	case paymentlog.FieldUserID:
		return m.UserID()
	case paymentlog.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentlog.FieldExtras:
		return m.OldExtras(ctx)
	case paymentlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentlog.FieldOrderID:
		return m.OldOrderID(ctx)
	case paymentlog.FieldChannelID:
		return m.OldChannelID(ctx)
	case paymentlog.FieldType:
		return m.OldType(ctx)
	case paymentlog.FieldStatusBefore:
		return m.OldStatusBefore(ctx)
	case paymentlog.FieldStatusAfter:
		return m.OldStatusAfter(ctx)
	case paymentlog.FieldRequestData:
		return m.OldRequestData(ctx)
	case paymentlog.FieldResponseData:
		return m.OldResponseData(ctx)
	case paymentlog.FieldIP:
		return m.OldIP(ctx)
	case paymentlog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case paymentlog.FieldUserID:
		return m.OldUserID(ctx)
	case paymentlog.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentlog.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case paymentlog.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentlog.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentlog.FieldOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case paymentlog.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case paymentlog.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case paymentlog.FieldStatusBefore:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusBefore(v)
		return nil
	case paymentlog.FieldStatusAfter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusAfter(v)
		return nil
	case paymentlog.FieldRequestData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestData(v)
		return nil
	case paymentlog.FieldResponseData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseData(v)
		return nil
	case paymentlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case paymentlog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case paymentlog.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case paymentlog.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, paymentlog.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, paymentlog.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentlog.FieldCreatedAt:
		return m.AddedCreatedAt()
	case paymentlog.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentlog.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case paymentlog.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentlog.FieldExtras) {
		fields = append(fields, paymentlog.FieldExtras)
	}
	if m.FieldCleared(paymentlog.FieldCreatedAt) {
		fields = append(fields, paymentlog.FieldCreatedAt)
	}
	if m.FieldCleared(paymentlog.FieldUpdatedAt) {
		fields = append(fields, paymentlog.FieldUpdatedAt)
	}
	if m.FieldCleared(paymentlog.FieldStatusBefore) {
		fields = append(fields, paymentlog.FieldStatusBefore)
	}
	if m.FieldCleared(paymentlog.FieldStatusAfter) {
		fields = append(fields, paymentlog.FieldStatusAfter)
	}
	if m.FieldCleared(paymentlog.FieldRequestData) {
		fields = append(fields, paymentlog.FieldRequestData)
	}
	if m.FieldCleared(paymentlog.FieldResponseData) {
		fields = append(fields, paymentlog.FieldResponseData)
	}
	if m.FieldCleared(paymentlog.FieldIP) {
		fields = append(fields, paymentlog.FieldIP)
	}
	if m.FieldCleared(paymentlog.FieldUserAgent) {
		fields = append(fields, paymentlog.FieldUserAgent)
	}
	if m.FieldCleared(paymentlog.FieldUserID) {
		fields = append(fields, paymentlog.FieldUserID)
	}
	if m.FieldCleared(paymentlog.FieldError) {
		fields = append(fields, paymentlog.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentLogMutation) ClearField(name string) error {
	switch name {
	case paymentlog.FieldExtras:
		m.ClearExtras()
		return nil
	case paymentlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case paymentlog.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case paymentlog.FieldStatusBefore:
		m.ClearStatusBefore()
		return nil
	case paymentlog.FieldStatusAfter:
		m.ClearStatusAfter()
		return nil
	case paymentlog.FieldRequestData:
		m.ClearRequestData()
		return nil
	case paymentlog.FieldResponseData:
		m.ClearResponseData()
		return nil
	case paymentlog.FieldIP:
		m.ClearIP()
		return nil
	case paymentlog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case paymentlog.FieldUserID:
		m.ClearUserID()
		return nil
	case paymentlog.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown PaymentLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentLogMutation) ResetField(name string) error {
	switch name {
	case paymentlog.FieldExtras:
		m.ResetExtras()
		return nil
	case paymentlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentlog.FieldOrderID:
		m.ResetOrderID()
		return nil
	case paymentlog.FieldChannelID:
		m.ResetChannelID()
		return nil
	case paymentlog.FieldType:
		m.ResetType()
		return nil
	case paymentlog.FieldStatusBefore:
		m.ResetStatusBefore()
		return nil
	case paymentlog.FieldStatusAfter:
		m.ResetStatusAfter()
		return nil
	case paymentlog.FieldRequestData:
		m.ResetRequestData()
		return nil
	case paymentlog.FieldResponseData:
		m.ResetResponseData()
		return nil
	case paymentlog.FieldIP:
		m.ResetIP()
		return nil
	case paymentlog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case paymentlog.FieldUserID:
		m.ResetUserID()
		return nil
	case paymentlog.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown PaymentLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, paymentlog.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentlog.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, paymentlog.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentLogMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentlog.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentLogMutation) ClearEdge(name string) error {
	switch name {
	case paymentlog.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown PaymentLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentLogMutation) ResetEdge(name string) error {
	switch name {
	case paymentlog.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown PaymentLog edge %s", name)
}

// PaymentOrderMutation represents an operation that mutates the PaymentOrder nodes in the graph.
type PaymentOrderMutation struct {
	config
	op              Op
	typ             string
	id              *string
	extras          *map[string]interface{}
	created_by      *string
	updated_by      *string
	created_at      *int64
	addcreated_at   *int64
	updated_at      *int64
	addupdated_at   *int64
	order_number    *string
	amount          *float64
	addamount       *float64
	currency        *string
	status          *string
	_type           *string
	channel_id      *string
	user_id         *string
	tenant_id       *string
	product_id      *string
	subscription_id *string
	expires_at      *time.Time
	paid_at         *time.Time
	provider_ref    *string
	description     *string
	clearedFields   map[string]struct{}
	logs            map[string]struct{}
	removedlogs     map[string]struct{}
	clearedlogs     bool
	done            bool
	oldValue        func(context.Context) (*PaymentOrder, error)
	predicates      []predicate.PaymentOrder
}

var _ ent.Mutation = (*PaymentOrderMutation)(nil)

// paymentorderOption allows management of the mutation configuration using functional options.
type paymentorderOption func(*PaymentOrderMutation)

// newPaymentOrderMutation creates new mutation for the PaymentOrder entity.
func newPaymentOrderMutation(c config, op Op, opts ...paymentorderOption) *PaymentOrderMutation {
	m := &PaymentOrderMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentOrderID sets the ID field of the mutation.
func withPaymentOrderID(id string) paymentorderOption {
	return func(m *PaymentOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentOrder
		)
		m.oldValue = func(ctx context.Context) (*PaymentOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentOrder sets the old PaymentOrder of the mutation.
func withPaymentOrder(node *PaymentOrder) paymentorderOption {
	return func(m *PaymentOrderMutation) {
		m.oldValue = func(context.Context) (*PaymentOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentOrder entities.
func (m *PaymentOrderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentOrderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentOrderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExtras sets the "extras" field.
func (m *PaymentOrderMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *PaymentOrderMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *PaymentOrderMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[paymentorder.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *PaymentOrderMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *PaymentOrderMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, paymentorder.FieldExtras)
}

// SetCreatedBy sets the "created_by" field.
func (m *PaymentOrderMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PaymentOrderMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PaymentOrderMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[paymentorder.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PaymentOrderMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PaymentOrderMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, paymentorder.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PaymentOrderMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PaymentOrderMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PaymentOrderMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[paymentorder.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PaymentOrderMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PaymentOrderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, paymentorder.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentOrderMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentOrderMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *PaymentOrderMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PaymentOrderMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PaymentOrderMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[paymentorder.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PaymentOrderMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentOrderMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, paymentorder.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentOrderMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentOrderMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *PaymentOrderMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PaymentOrderMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PaymentOrderMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[paymentorder.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PaymentOrderMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, paymentorder.FieldUpdatedAt)
}

// SetOrderNumber sets the "order_number" field.
func (m *PaymentOrderMutation) SetOrderNumber(s string) {
	m.order_number = &s
}

// OrderNumber returns the value of the "order_number" field in the mutation.
func (m *PaymentOrderMutation) OrderNumber() (r string, exists bool) {
	v := m.order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "order_number" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "order_number" field.
func (m *PaymentOrderMutation) ResetOrderNumber() {
	m.order_number = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentOrderMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentOrderMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PaymentOrderMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentOrderMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentOrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCurrency sets the "currency" field.
func (m *PaymentOrderMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PaymentOrderMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PaymentOrderMutation) ResetCurrency() {
	m.currency = nil
}

// SetStatus sets the "status" field.
func (m *PaymentOrderMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentOrderMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentOrderMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *PaymentOrderMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PaymentOrderMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PaymentOrderMutation) ResetType() {
	m._type = nil
}

// SetChannelID sets the "channel_id" field.
func (m *PaymentOrderMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *PaymentOrderMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *PaymentOrderMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetUserID sets the "user_id" field.
func (m *PaymentOrderMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PaymentOrderMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PaymentOrderMutation) ResetUserID() {
	m.user_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *PaymentOrderMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PaymentOrderMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *PaymentOrderMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[paymentorder.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *PaymentOrderMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PaymentOrderMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, paymentorder.FieldTenantID)
}

// SetProductID sets the "product_id" field.
func (m *PaymentOrderMutation) SetProductID(s string) {
	m.product_id = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *PaymentOrderMutation) ProductID() (r string, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *PaymentOrderMutation) ClearProductID() {
	m.product_id = nil
	m.clearedFields[paymentorder.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *PaymentOrderMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *PaymentOrderMutation) ResetProductID() {
	m.product_id = nil
	delete(m.clearedFields, paymentorder.FieldProductID)
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *PaymentOrderMutation) SetSubscriptionID(s string) {
	m.subscription_id = &s
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *PaymentOrderMutation) SubscriptionID() (r string, exists bool) {
	v := m.subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ClearSubscriptionID clears the value of the "subscription_id" field.
func (m *PaymentOrderMutation) ClearSubscriptionID() {
	m.subscription_id = nil
	m.clearedFields[paymentorder.FieldSubscriptionID] = struct{}{}
}

// SubscriptionIDCleared returns if the "subscription_id" field was cleared in this mutation.
func (m *PaymentOrderMutation) SubscriptionIDCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldSubscriptionID]
	return ok
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *PaymentOrderMutation) ResetSubscriptionID() {
	m.subscription_id = nil
	delete(m.clearedFields, paymentorder.FieldSubscriptionID)
}

// SetExpiresAt sets the "expires_at" field.
func (m *PaymentOrderMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PaymentOrderMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PaymentOrderMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetPaidAt sets the "paid_at" field.
func (m *PaymentOrderMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *PaymentOrderMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldPaidAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *PaymentOrderMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[paymentorder.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *PaymentOrderMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *PaymentOrderMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, paymentorder.FieldPaidAt)
}

// SetProviderRef sets the "provider_ref" field.
func (m *PaymentOrderMutation) SetProviderRef(s string) {
	m.provider_ref = &s
}

// ProviderRef returns the value of the "provider_ref" field in the mutation.
func (m *PaymentOrderMutation) ProviderRef() (r string, exists bool) {
	v := m.provider_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderRef returns the old "provider_ref" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldProviderRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderRef: %w", err)
	}
	return oldValue.ProviderRef, nil
}

// ClearProviderRef clears the value of the "provider_ref" field.
func (m *PaymentOrderMutation) ClearProviderRef() {
	m.provider_ref = nil
	m.clearedFields[paymentorder.FieldProviderRef] = struct{}{}
}

// ProviderRefCleared returns if the "provider_ref" field was cleared in this mutation.
func (m *PaymentOrderMutation) ProviderRefCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldProviderRef]
	return ok
}

// ResetProviderRef resets all changes to the "provider_ref" field.
func (m *PaymentOrderMutation) ResetProviderRef() {
	m.provider_ref = nil
	delete(m.clearedFields, paymentorder.FieldProviderRef)
}

// SetDescription sets the "description" field.
func (m *PaymentOrderMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PaymentOrderMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PaymentOrderMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[paymentorder.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PaymentOrderMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PaymentOrderMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, paymentorder.FieldDescription)
}

// AddLogIDs adds the "logs" edge to the PaymentLog entity by ids.
func (m *PaymentOrderMutation) AddLogIDs(ids ...string) {
	if m.logs == nil {
		m.logs = make(map[string]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the PaymentLog entity.
func (m *PaymentOrderMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the PaymentLog entity was cleared.
func (m *PaymentOrderMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the PaymentLog entity by IDs.
func (m *PaymentOrderMutation) RemoveLogIDs(ids ...string) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the PaymentLog entity.
func (m *PaymentOrderMutation) RemovedLogsIDs() (ids []string) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *PaymentOrderMutation) LogsIDs() (ids []string) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *PaymentOrderMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// Where appends a list predicates to the PaymentOrderMutation builder.
func (m *PaymentOrderMutation) Where(ps ...predicate.PaymentOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentOrder).
func (m *PaymentOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentOrderMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.extras != nil {
		fields = append(fields, paymentorder.FieldExtras)
	}
	if m.created_by != nil {
		fields = append(fields, paymentorder.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, paymentorder.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, paymentorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentorder.FieldUpdatedAt)
	}
	if m.order_number != nil {
		fields = append(fields, paymentorder.FieldOrderNumber)
	}
	if m.amount != nil {
		fields = append(fields, paymentorder.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, paymentorder.FieldCurrency)
	}
	if m.status != nil {
		fields = append(fields, paymentorder.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, paymentorder.FieldType)
	}
	if m.channel_id != nil {
		fields = append(fields, paymentorder.FieldChannelID)
	}
	if m.user_id != nil {
		fields = append(fields, paymentorder.FieldUserID)
	}
	if m.tenant_id != nil {
		fields = append(fields, paymentorder.FieldTenantID)
	}
	if m.product_id != nil {
		fields = append(fields, paymentorder.FieldProductID)
	}
	if m.subscription_id != nil {
		fields = append(fields, paymentorder.FieldSubscriptionID)
	}
	if m.expires_at != nil {
		fields = append(fields, paymentorder.FieldExpiresAt)
	}
	if m.paid_at != nil {
		fields = append(fields, paymentorder.FieldPaidAt)
	}
	if m.provider_ref != nil {
		fields = append(fields, paymentorder.FieldProviderRef)
	}
	if m.description != nil {
		fields = append(fields, paymentorder.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentorder.FieldExtras:
		return m.Extras()
	case paymentorder.FieldCreatedBy:
		return m.CreatedBy()
	case paymentorder.FieldUpdatedBy:
		return m.UpdatedBy()
	case paymentorder.FieldCreatedAt:
		return m.CreatedAt()
	case paymentorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentorder.FieldOrderNumber:
		return m.OrderNumber()
	case paymentorder.FieldAmount:
		return m.Amount()
	case paymentorder.FieldCurrency:
		return m.Currency()
	case paymentorder.FieldStatus:
		return m.Status()
	case paymentorder.FieldType:
		return m.GetType()
	case paymentorder.FieldChannelID:
		return m.ChannelID()
	case paymentorder.FieldUserID:
		return m.UserID()
	case paymentorder.FieldTenantID:
		return m.TenantID()
	case paymentorder.FieldProductID:
		return m.ProductID()
	case paymentorder.FieldSubscriptionID:
		return m.SubscriptionID()
	case paymentorder.FieldExpiresAt:
		return m.ExpiresAt()
	case paymentorder.FieldPaidAt:
		return m.PaidAt()
	case paymentorder.FieldProviderRef:
		return m.ProviderRef()
	case paymentorder.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentorder.FieldExtras:
		return m.OldExtras(ctx)
	case paymentorder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case paymentorder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case paymentorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentorder.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case paymentorder.FieldAmount:
		return m.OldAmount(ctx)
	case paymentorder.FieldCurrency:
		return m.OldCurrency(ctx)
	case paymentorder.FieldStatus:
		return m.OldStatus(ctx)
	case paymentorder.FieldType:
		return m.OldType(ctx)
	case paymentorder.FieldChannelID:
		return m.OldChannelID(ctx)
	case paymentorder.FieldUserID:
		return m.OldUserID(ctx)
	case paymentorder.FieldTenantID:
		return m.OldTenantID(ctx)
	case paymentorder.FieldProductID:
		return m.OldProductID(ctx)
	case paymentorder.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case paymentorder.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case paymentorder.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case paymentorder.FieldProviderRef:
		return m.OldProviderRef(ctx)
	case paymentorder.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentorder.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case paymentorder.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case paymentorder.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case paymentorder.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentorder.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentorder.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case paymentorder.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case paymentorder.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case paymentorder.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case paymentorder.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case paymentorder.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case paymentorder.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case paymentorder.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case paymentorder.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case paymentorder.FieldSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case paymentorder.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case paymentorder.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case paymentorder.FieldProviderRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderRef(v)
		return nil
	case paymentorder.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentOrderMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, paymentorder.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, paymentorder.FieldUpdatedAt)
	}
	if m.addamount != nil {
		fields = append(fields, paymentorder.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentorder.FieldCreatedAt:
		return m.AddedCreatedAt()
	case paymentorder.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case paymentorder.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentorder.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case paymentorder.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case paymentorder.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentorder.FieldExtras) {
		fields = append(fields, paymentorder.FieldExtras)
	}
	if m.FieldCleared(paymentorder.FieldCreatedBy) {
		fields = append(fields, paymentorder.FieldCreatedBy)
	}
	if m.FieldCleared(paymentorder.FieldUpdatedBy) {
		fields = append(fields, paymentorder.FieldUpdatedBy)
	}
	if m.FieldCleared(paymentorder.FieldCreatedAt) {
		fields = append(fields, paymentorder.FieldCreatedAt)
	}
	if m.FieldCleared(paymentorder.FieldUpdatedAt) {
		fields = append(fields, paymentorder.FieldUpdatedAt)
	}
	if m.FieldCleared(paymentorder.FieldTenantID) {
		fields = append(fields, paymentorder.FieldTenantID)
	}
	if m.FieldCleared(paymentorder.FieldProductID) {
		fields = append(fields, paymentorder.FieldProductID)
	}
	if m.FieldCleared(paymentorder.FieldSubscriptionID) {
		fields = append(fields, paymentorder.FieldSubscriptionID)
	}
	if m.FieldCleared(paymentorder.FieldPaidAt) {
		fields = append(fields, paymentorder.FieldPaidAt)
	}
	if m.FieldCleared(paymentorder.FieldProviderRef) {
		fields = append(fields, paymentorder.FieldProviderRef)
	}
	if m.FieldCleared(paymentorder.FieldDescription) {
		fields = append(fields, paymentorder.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentOrderMutation) ClearField(name string) error {
	switch name {
	case paymentorder.FieldExtras:
		m.ClearExtras()
		return nil
	case paymentorder.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case paymentorder.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case paymentorder.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case paymentorder.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case paymentorder.FieldTenantID:
		m.ClearTenantID()
		return nil
	case paymentorder.FieldProductID:
		m.ClearProductID()
		return nil
	case paymentorder.FieldSubscriptionID:
		m.ClearSubscriptionID()
		return nil
	case paymentorder.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	case paymentorder.FieldProviderRef:
		m.ClearProviderRef()
		return nil
	case paymentorder.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown PaymentOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentOrderMutation) ResetField(name string) error {
	switch name {
	case paymentorder.FieldExtras:
		m.ResetExtras()
		return nil
	case paymentorder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case paymentorder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case paymentorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentorder.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case paymentorder.FieldAmount:
		m.ResetAmount()
		return nil
	case paymentorder.FieldCurrency:
		m.ResetCurrency()
		return nil
	case paymentorder.FieldStatus:
		m.ResetStatus()
		return nil
	case paymentorder.FieldType:
		m.ResetType()
		return nil
	case paymentorder.FieldChannelID:
		m.ResetChannelID()
		return nil
	case paymentorder.FieldUserID:
		m.ResetUserID()
		return nil
	case paymentorder.FieldTenantID:
		m.ResetTenantID()
		return nil
	case paymentorder.FieldProductID:
		m.ResetProductID()
		return nil
	case paymentorder.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case paymentorder.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case paymentorder.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case paymentorder.FieldProviderRef:
		m.ResetProviderRef()
		return nil
	case paymentorder.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown PaymentOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.logs != nil {
		edges = append(edges, paymentorder.EdgeLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentorder.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlogs != nil {
		edges = append(edges, paymentorder.EdgeLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paymentorder.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlogs {
		edges = append(edges, paymentorder.EdgeLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentorder.EdgeLogs:
		return m.clearedlogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentOrderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentOrderMutation) ResetEdge(name string) error {
	switch name {
	case paymentorder.EdgeLogs:
		m.ResetLogs()
		return nil
	}
	return fmt.Errorf("unknown PaymentOrder edge %s", name)
}

// PaymentProductMutation represents an operation that mutates the PaymentProduct nodes in the graph.
type PaymentProductMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	name                 *string
	description          *string
	extras               *map[string]interface{}
	created_by           *string
	updated_by           *string
	created_at           *int64
	addcreated_at        *int64
	updated_at           *int64
	addupdated_at        *int64
	status               *string
	pricing_type         *string
	price                *float64
	addprice             *float64
	currency             *string
	billing_interval     *string
	trial_days           *int
	addtrial_days        *int
	features             *[]string
	appendfeatures       []string
	tenant_id            *string
	clearedFields        map[string]struct{}
	subscriptions        map[string]struct{}
	removedsubscriptions map[string]struct{}
	clearedsubscriptions bool
	done                 bool
	oldValue             func(context.Context) (*PaymentProduct, error)
	predicates           []predicate.PaymentProduct
}

var _ ent.Mutation = (*PaymentProductMutation)(nil)

// paymentproductOption allows management of the mutation configuration using functional options.
type paymentproductOption func(*PaymentProductMutation)

// newPaymentProductMutation creates new mutation for the PaymentProduct entity.
func newPaymentProductMutation(c config, op Op, opts ...paymentproductOption) *PaymentProductMutation {
	m := &PaymentProductMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentProductID sets the ID field of the mutation.
func withPaymentProductID(id string) paymentproductOption {
	return func(m *PaymentProductMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentProduct
		)
		m.oldValue = func(ctx context.Context) (*PaymentProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentProduct sets the old PaymentProduct of the mutation.
func withPaymentProduct(node *PaymentProduct) paymentproductOption {
	return func(m *PaymentProductMutation) {
		m.oldValue = func(context.Context) (*PaymentProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentProduct entities.
func (m *PaymentProductMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentProductMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentProductMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PaymentProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PaymentProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PaymentProductMutation) ClearName() {
	m.name = nil
	m.clearedFields[paymentproduct.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PaymentProductMutation) NameCleared() bool {
	_, ok := m.clearedFields[paymentproduct.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PaymentProductMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, paymentproduct.FieldName)
}

// SetDescription sets the "description" field.
func (m *PaymentProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PaymentProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PaymentProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[paymentproduct.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PaymentProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[paymentproduct.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PaymentProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, paymentproduct.FieldDescription)
}

// SetExtras sets the "extras" field.
func (m *PaymentProductMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *PaymentProductMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *PaymentProductMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[paymentproduct.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *PaymentProductMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[paymentproduct.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *PaymentProductMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, paymentproduct.FieldExtras)
}

// SetCreatedBy sets the "created_by" field.
func (m *PaymentProductMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PaymentProductMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PaymentProductMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[paymentproduct.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PaymentProductMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[paymentproduct.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PaymentProductMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, paymentproduct.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PaymentProductMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PaymentProductMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PaymentProductMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[paymentproduct.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PaymentProductMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[paymentproduct.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PaymentProductMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, paymentproduct.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentProductMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentProductMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *PaymentProductMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PaymentProductMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PaymentProductMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[paymentproduct.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PaymentProductMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[paymentproduct.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentProductMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, paymentproduct.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentProductMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentProductMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *PaymentProductMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PaymentProductMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PaymentProductMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[paymentproduct.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PaymentProductMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[paymentproduct.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, paymentproduct.FieldUpdatedAt)
}

// SetStatus sets the "status" field.
func (m *PaymentProductMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentProductMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentProductMutation) ResetStatus() {
	m.status = nil
}

// SetPricingType sets the "pricing_type" field.
func (m *PaymentProductMutation) SetPricingType(s string) {
	m.pricing_type = &s
}

// PricingType returns the value of the "pricing_type" field in the mutation.
func (m *PaymentProductMutation) PricingType() (r string, exists bool) {
	v := m.pricing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPricingType returns the old "pricing_type" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldPricingType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricingType: %w", err)
	}
	return oldValue.PricingType, nil
}

// ResetPricingType resets all changes to the "pricing_type" field.
func (m *PaymentProductMutation) ResetPricingType() {
	m.pricing_type = nil
}

// SetPrice sets the "price" field.
func (m *PaymentProductMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PaymentProductMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *PaymentProductMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PaymentProductMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *PaymentProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetCurrency sets the "currency" field.
func (m *PaymentProductMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PaymentProductMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PaymentProductMutation) ResetCurrency() {
	m.currency = nil
}

// SetBillingInterval sets the "billing_interval" field.
func (m *PaymentProductMutation) SetBillingInterval(s string) {
	m.billing_interval = &s
}

// BillingInterval returns the value of the "billing_interval" field in the mutation.
func (m *PaymentProductMutation) BillingInterval() (r string, exists bool) {
	v := m.billing_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingInterval returns the old "billing_interval" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldBillingInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingInterval: %w", err)
	}
	return oldValue.BillingInterval, nil
}

// ClearBillingInterval clears the value of the "billing_interval" field.
func (m *PaymentProductMutation) ClearBillingInterval() {
	m.billing_interval = nil
	m.clearedFields[paymentproduct.FieldBillingInterval] = struct{}{}
}

// BillingIntervalCleared returns if the "billing_interval" field was cleared in this mutation.
func (m *PaymentProductMutation) BillingIntervalCleared() bool {
	_, ok := m.clearedFields[paymentproduct.FieldBillingInterval]
	return ok
}

// ResetBillingInterval resets all changes to the "billing_interval" field.
func (m *PaymentProductMutation) ResetBillingInterval() {
	m.billing_interval = nil
	delete(m.clearedFields, paymentproduct.FieldBillingInterval)
}

// SetTrialDays sets the "trial_days" field.
func (m *PaymentProductMutation) SetTrialDays(i int) {
	m.trial_days = &i
	m.addtrial_days = nil
}

// TrialDays returns the value of the "trial_days" field in the mutation.
func (m *PaymentProductMutation) TrialDays() (r int, exists bool) {
	v := m.trial_days
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialDays returns the old "trial_days" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldTrialDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialDays: %w", err)
	}
	return oldValue.TrialDays, nil
}

// AddTrialDays adds i to the "trial_days" field.
func (m *PaymentProductMutation) AddTrialDays(i int) {
	if m.addtrial_days != nil {
		*m.addtrial_days += i
	} else {
		m.addtrial_days = &i
	}
}

// AddedTrialDays returns the value that was added to the "trial_days" field in this mutation.
func (m *PaymentProductMutation) AddedTrialDays() (r int, exists bool) {
	v := m.addtrial_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetTrialDays resets all changes to the "trial_days" field.
func (m *PaymentProductMutation) ResetTrialDays() {
	m.trial_days = nil
	m.addtrial_days = nil
}

// SetFeatures sets the "features" field.
func (m *PaymentProductMutation) SetFeatures(s []string) {
	m.features = &s
	m.appendfeatures = nil
}

// Features returns the value of the "features" field in the mutation.
func (m *PaymentProductMutation) Features() (r []string, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatures returns the old "features" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldFeatures(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatures: %w", err)
	}
	return oldValue.Features, nil
}

// AppendFeatures adds s to the "features" field.
func (m *PaymentProductMutation) AppendFeatures(s []string) {
	m.appendfeatures = append(m.appendfeatures, s...)
}

// AppendedFeatures returns the list of values that were appended to the "features" field in this mutation.
func (m *PaymentProductMutation) AppendedFeatures() ([]string, bool) {
	if len(m.appendfeatures) == 0 {
		return nil, false
	}
	return m.appendfeatures, true
}

// ResetFeatures resets all changes to the "features" field.
func (m *PaymentProductMutation) ResetFeatures() {
	m.features = nil
	m.appendfeatures = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *PaymentProductMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PaymentProductMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PaymentProduct entity.
// If the PaymentProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentProductMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *PaymentProductMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[paymentproduct.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *PaymentProductMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[paymentproduct.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PaymentProductMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, paymentproduct.FieldTenantID)
}

// AddSubscriptionIDs adds the "subscriptions" edge to the PaymentSubscription entity by ids.
func (m *PaymentProductMutation) AddSubscriptionIDs(ids ...string) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[string]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the PaymentSubscription entity.
func (m *PaymentProductMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the PaymentSubscription entity was cleared.
func (m *PaymentProductMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the PaymentSubscription entity by IDs.
func (m *PaymentProductMutation) RemoveSubscriptionIDs(ids ...string) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the PaymentSubscription entity.
func (m *PaymentProductMutation) RemovedSubscriptionsIDs() (ids []string) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *PaymentProductMutation) SubscriptionsIDs() (ids []string) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *PaymentProductMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// Where appends a list predicates to the PaymentProductMutation builder.
func (m *PaymentProductMutation) Where(ps ...predicate.PaymentProduct) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentProduct, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentProduct).
func (m *PaymentProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentProductMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.name != nil {
		fields = append(fields, paymentproduct.FieldName)
	}
	if m.description != nil {
		fields = append(fields, paymentproduct.FieldDescription)
	}
	if m.extras != nil {
		fields = append(fields, paymentproduct.FieldExtras)
	}
	if m.created_by != nil {
		fields = append(fields, paymentproduct.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, paymentproduct.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, paymentproduct.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentproduct.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, paymentproduct.FieldStatus)
	}
	if m.pricing_type != nil {
		fields = append(fields, paymentproduct.FieldPricingType)
	}
	if m.price != nil {
		fields = append(fields, paymentproduct.FieldPrice)
	}
	if m.currency != nil {
		fields = append(fields, paymentproduct.FieldCurrency)
	}
	if m.billing_interval != nil {
		fields = append(fields, paymentproduct.FieldBillingInterval)
	}
	if m.trial_days != nil {
		fields = append(fields, paymentproduct.FieldTrialDays)
	}
	if m.features != nil {
		fields = append(fields, paymentproduct.FieldFeatures)
	}
	if m.tenant_id != nil {
		fields = append(fields, paymentproduct.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentproduct.FieldName:
		return m.Name()
	case paymentproduct.FieldDescription:
		return m.Description()
	case paymentproduct.FieldExtras:
		return m.Extras()
	case paymentproduct.FieldCreatedBy:
		return m.CreatedBy()
	case paymentproduct.FieldUpdatedBy:
		return m.UpdatedBy()
	case paymentproduct.FieldCreatedAt:
		return m.CreatedAt()
	case paymentproduct.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentproduct.FieldStatus:
		return m.Status()
	case paymentproduct.FieldPricingType:
		return m.PricingType()
	case paymentproduct.FieldPrice:
		return m.Price()
	case paymentproduct.FieldCurrency:
		return m.Currency()
	case paymentproduct.FieldBillingInterval:
		return m.BillingInterval()
	case paymentproduct.FieldTrialDays:
		return m.TrialDays()
	case paymentproduct.FieldFeatures:
		return m.Features()
	case paymentproduct.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentproduct.FieldName:
		return m.OldName(ctx)
	case paymentproduct.FieldDescription:
		return m.OldDescription(ctx)
	case paymentproduct.FieldExtras:
		return m.OldExtras(ctx)
	case paymentproduct.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case paymentproduct.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case paymentproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentproduct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentproduct.FieldStatus:
		return m.OldStatus(ctx)
	case paymentproduct.FieldPricingType:
		return m.OldPricingType(ctx)
	case paymentproduct.FieldPrice:
		return m.OldPrice(ctx)
	case paymentproduct.FieldCurrency:
		return m.OldCurrency(ctx)
	case paymentproduct.FieldBillingInterval:
		return m.OldBillingInterval(ctx)
	case paymentproduct.FieldTrialDays:
		return m.OldTrialDays(ctx)
	case paymentproduct.FieldFeatures:
		return m.OldFeatures(ctx)
	case paymentproduct.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentproduct.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case paymentproduct.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case paymentproduct.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case paymentproduct.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case paymentproduct.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case paymentproduct.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentproduct.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentproduct.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case paymentproduct.FieldPricingType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricingType(v)
		return nil
	case paymentproduct.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case paymentproduct.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case paymentproduct.FieldBillingInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingInterval(v)
		return nil
	case paymentproduct.FieldTrialDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialDays(v)
		return nil
	case paymentproduct.FieldFeatures:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatures(v)
		return nil
	case paymentproduct.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentProductMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, paymentproduct.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, paymentproduct.FieldUpdatedAt)
	}
	if m.addprice != nil {
		fields = append(fields, paymentproduct.FieldPrice)
	}
	if m.addtrial_days != nil {
		fields = append(fields, paymentproduct.FieldTrialDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentproduct.FieldCreatedAt:
		return m.AddedCreatedAt()
	case paymentproduct.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case paymentproduct.FieldPrice:
		return m.AddedPrice()
	case paymentproduct.FieldTrialDays:
		return m.AddedTrialDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentproduct.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case paymentproduct.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case paymentproduct.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case paymentproduct.FieldTrialDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTrialDays(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentproduct.FieldName) {
		fields = append(fields, paymentproduct.FieldName)
	}
	if m.FieldCleared(paymentproduct.FieldDescription) {
		fields = append(fields, paymentproduct.FieldDescription)
	}
	if m.FieldCleared(paymentproduct.FieldExtras) {
		fields = append(fields, paymentproduct.FieldExtras)
	}
	if m.FieldCleared(paymentproduct.FieldCreatedBy) {
		fields = append(fields, paymentproduct.FieldCreatedBy)
	}
	if m.FieldCleared(paymentproduct.FieldUpdatedBy) {
		fields = append(fields, paymentproduct.FieldUpdatedBy)
	}
	if m.FieldCleared(paymentproduct.FieldCreatedAt) {
		fields = append(fields, paymentproduct.FieldCreatedAt)
	}
	if m.FieldCleared(paymentproduct.FieldUpdatedAt) {
		fields = append(fields, paymentproduct.FieldUpdatedAt)
	}
	if m.FieldCleared(paymentproduct.FieldBillingInterval) {
		fields = append(fields, paymentproduct.FieldBillingInterval)
	}
	if m.FieldCleared(paymentproduct.FieldTenantID) {
		fields = append(fields, paymentproduct.FieldTenantID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentProductMutation) ClearField(name string) error {
	switch name {
	case paymentproduct.FieldName:
		m.ClearName()
		return nil
	case paymentproduct.FieldDescription:
		m.ClearDescription()
		return nil
	case paymentproduct.FieldExtras:
		m.ClearExtras()
		return nil
	case paymentproduct.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case paymentproduct.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case paymentproduct.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case paymentproduct.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case paymentproduct.FieldBillingInterval:
		m.ClearBillingInterval()
		return nil
	case paymentproduct.FieldTenantID:
		m.ClearTenantID()
		return nil
	}
	return fmt.Errorf("unknown PaymentProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentProductMutation) ResetField(name string) error {
	switch name {
	case paymentproduct.FieldName:
		m.ResetName()
		return nil
	case paymentproduct.FieldDescription:
		m.ResetDescription()
		return nil
	case paymentproduct.FieldExtras:
		m.ResetExtras()
		return nil
	case paymentproduct.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case paymentproduct.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case paymentproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentproduct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentproduct.FieldStatus:
		m.ResetStatus()
		return nil
	case paymentproduct.FieldPricingType:
		m.ResetPricingType()
		return nil
	case paymentproduct.FieldPrice:
		m.ResetPrice()
		return nil
	case paymentproduct.FieldCurrency:
		m.ResetCurrency()
		return nil
	case paymentproduct.FieldBillingInterval:
		m.ResetBillingInterval()
		return nil
	case paymentproduct.FieldTrialDays:
		m.ResetTrialDays()
		return nil
	case paymentproduct.FieldFeatures:
		m.ResetFeatures()
		return nil
	case paymentproduct.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown PaymentProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subscriptions != nil {
		edges = append(edges, paymentproduct.EdgeSubscriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentproduct.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubscriptions != nil {
		edges = append(edges, paymentproduct.EdgeSubscriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paymentproduct.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubscriptions {
		edges = append(edges, paymentproduct.EdgeSubscriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentProductMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentproduct.EdgeSubscriptions:
		return m.clearedsubscriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentProductMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentProductMutation) ResetEdge(name string) error {
	switch name {
	case paymentproduct.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	}
	return fmt.Errorf("unknown PaymentProduct edge %s", name)
}

// PaymentSubscriptionMutation represents an operation that mutates the PaymentSubscription nodes in the graph.
type PaymentSubscriptionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	extras               *map[string]interface{}
	created_by           *string
	updated_by           *string
	created_at           *int64
	addcreated_at        *int64
	updated_at           *int64
	addupdated_at        *int64
	status               *string
	user_id              *string
	tenant_id            *string
	channel_id           *string
	current_period_start *time.Time
	current_period_end   *time.Time
	cancel_at            *time.Time
	cancelled_at         *time.Time
	trial_start          *time.Time
	trial_end            *time.Time
	provider_ref         *string
	clearedFields        map[string]struct{}
	product              *string
	clearedproduct       bool
	done                 bool
	oldValue             func(context.Context) (*PaymentSubscription, error)
	predicates           []predicate.PaymentSubscription
}

var _ ent.Mutation = (*PaymentSubscriptionMutation)(nil)

// paymentsubscriptionOption allows management of the mutation configuration using functional options.
type paymentsubscriptionOption func(*PaymentSubscriptionMutation)

// newPaymentSubscriptionMutation creates new mutation for the PaymentSubscription entity.
func newPaymentSubscriptionMutation(c config, op Op, opts ...paymentsubscriptionOption) *PaymentSubscriptionMutation {
	m := &PaymentSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentSubscriptionID sets the ID field of the mutation.
func withPaymentSubscriptionID(id string) paymentsubscriptionOption {
	return func(m *PaymentSubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentSubscription
		)
		m.oldValue = func(ctx context.Context) (*PaymentSubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentSubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentSubscription sets the old PaymentSubscription of the mutation.
func withPaymentSubscription(node *PaymentSubscription) paymentsubscriptionOption {
	return func(m *PaymentSubscriptionMutation) {
		m.oldValue = func(context.Context) (*PaymentSubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentSubscription entities.
func (m *PaymentSubscriptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentSubscriptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentSubscriptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentSubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExtras sets the "extras" field.
func (m *PaymentSubscriptionMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *PaymentSubscriptionMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *PaymentSubscriptionMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[paymentsubscription.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *PaymentSubscriptionMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[paymentsubscription.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *PaymentSubscriptionMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, paymentsubscription.FieldExtras)
}

// SetCreatedBy sets the "created_by" field.
func (m *PaymentSubscriptionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PaymentSubscriptionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PaymentSubscriptionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[paymentsubscription.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PaymentSubscriptionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[paymentsubscription.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PaymentSubscriptionMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, paymentsubscription.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PaymentSubscriptionMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PaymentSubscriptionMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PaymentSubscriptionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[paymentsubscription.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PaymentSubscriptionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[paymentsubscription.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PaymentSubscriptionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, paymentsubscription.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentSubscriptionMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentSubscriptionMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *PaymentSubscriptionMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PaymentSubscriptionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PaymentSubscriptionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[paymentsubscription.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PaymentSubscriptionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[paymentsubscription.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentSubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, paymentsubscription.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentSubscriptionMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentSubscriptionMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *PaymentSubscriptionMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PaymentSubscriptionMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PaymentSubscriptionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[paymentsubscription.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PaymentSubscriptionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[paymentsubscription.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentSubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, paymentsubscription.FieldUpdatedAt)
}

// SetStatus sets the "status" field.
func (m *PaymentSubscriptionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentSubscriptionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentSubscriptionMutation) ResetStatus() {
	m.status = nil
}

// SetUserID sets the "user_id" field.
func (m *PaymentSubscriptionMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PaymentSubscriptionMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PaymentSubscriptionMutation) ResetUserID() {
	m.user_id = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *PaymentSubscriptionMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PaymentSubscriptionMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *PaymentSubscriptionMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[paymentsubscription.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *PaymentSubscriptionMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[paymentsubscription.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PaymentSubscriptionMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, paymentsubscription.FieldTenantID)
}

// SetProductID sets the "product_id" field.
func (m *PaymentSubscriptionMutation) SetProductID(s string) {
	m.product = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *PaymentSubscriptionMutation) ProductID() (r string, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *PaymentSubscriptionMutation) ResetProductID() {
	m.product = nil
}

// SetChannelID sets the "channel_id" field.
func (m *PaymentSubscriptionMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *PaymentSubscriptionMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *PaymentSubscriptionMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetCurrentPeriodStart sets the "current_period_start" field.
func (m *PaymentSubscriptionMutation) SetCurrentPeriodStart(t time.Time) {
	m.current_period_start = &t
}

// CurrentPeriodStart returns the value of the "current_period_start" field in the mutation.
func (m *PaymentSubscriptionMutation) CurrentPeriodStart() (r time.Time, exists bool) {
	v := m.current_period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPeriodStart returns the old "current_period_start" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldCurrentPeriodStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPeriodStart: %w", err)
	}
	return oldValue.CurrentPeriodStart, nil
}

// ResetCurrentPeriodStart resets all changes to the "current_period_start" field.
func (m *PaymentSubscriptionMutation) ResetCurrentPeriodStart() {
	m.current_period_start = nil
}

// SetCurrentPeriodEnd sets the "current_period_end" field.
func (m *PaymentSubscriptionMutation) SetCurrentPeriodEnd(t time.Time) {
	m.current_period_end = &t
}

// CurrentPeriodEnd returns the value of the "current_period_end" field in the mutation.
func (m *PaymentSubscriptionMutation) CurrentPeriodEnd() (r time.Time, exists bool) {
	v := m.current_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPeriodEnd returns the old "current_period_end" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldCurrentPeriodEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPeriodEnd: %w", err)
	}
	return oldValue.CurrentPeriodEnd, nil
}

// ResetCurrentPeriodEnd resets all changes to the "current_period_end" field.
func (m *PaymentSubscriptionMutation) ResetCurrentPeriodEnd() {
	m.current_period_end = nil
}

// SetCancelAt sets the "cancel_at" field.
func (m *PaymentSubscriptionMutation) SetCancelAt(t time.Time) {
	m.cancel_at = &t
}

// CancelAt returns the value of the "cancel_at" field in the mutation.
func (m *PaymentSubscriptionMutation) CancelAt() (r time.Time, exists bool) {
	v := m.cancel_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelAt returns the old "cancel_at" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldCancelAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelAt: %w", err)
	}
	return oldValue.CancelAt, nil
}

// ClearCancelAt clears the value of the "cancel_at" field.
func (m *PaymentSubscriptionMutation) ClearCancelAt() {
	m.cancel_at = nil
	m.clearedFields[paymentsubscription.FieldCancelAt] = struct{}{}
}

// CancelAtCleared returns if the "cancel_at" field was cleared in this mutation.
func (m *PaymentSubscriptionMutation) CancelAtCleared() bool {
	_, ok := m.clearedFields[paymentsubscription.FieldCancelAt]
	return ok
}

// ResetCancelAt resets all changes to the "cancel_at" field.
func (m *PaymentSubscriptionMutation) ResetCancelAt() {
	m.cancel_at = nil
	delete(m.clearedFields, paymentsubscription.FieldCancelAt)
}

// SetCancelledAt sets the "cancelled_at" field.
func (m *PaymentSubscriptionMutation) SetCancelledAt(t time.Time) {
	m.cancelled_at = &t
}

// CancelledAt returns the value of the "cancelled_at" field in the mutation.
func (m *PaymentSubscriptionMutation) CancelledAt() (r time.Time, exists bool) {
	v := m.cancelled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelledAt returns the old "cancelled_at" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldCancelledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelledAt: %w", err)
	}
	return oldValue.CancelledAt, nil
}

// ClearCancelledAt clears the value of the "cancelled_at" field.
func (m *PaymentSubscriptionMutation) ClearCancelledAt() {
	m.cancelled_at = nil
	m.clearedFields[paymentsubscription.FieldCancelledAt] = struct{}{}
}

// CancelledAtCleared returns if the "cancelled_at" field was cleared in this mutation.
func (m *PaymentSubscriptionMutation) CancelledAtCleared() bool {
	_, ok := m.clearedFields[paymentsubscription.FieldCancelledAt]
	return ok
}

// ResetCancelledAt resets all changes to the "cancelled_at" field.
func (m *PaymentSubscriptionMutation) ResetCancelledAt() {
	m.cancelled_at = nil
	delete(m.clearedFields, paymentsubscription.FieldCancelledAt)
}

// SetTrialStart sets the "trial_start" field.
func (m *PaymentSubscriptionMutation) SetTrialStart(t time.Time) {
	m.trial_start = &t
}

// TrialStart returns the value of the "trial_start" field in the mutation.
func (m *PaymentSubscriptionMutation) TrialStart() (r time.Time, exists bool) {
	v := m.trial_start
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialStart returns the old "trial_start" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldTrialStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialStart: %w", err)
	}
	return oldValue.TrialStart, nil
}

// ClearTrialStart clears the value of the "trial_start" field.
func (m *PaymentSubscriptionMutation) ClearTrialStart() {
	m.trial_start = nil
	m.clearedFields[paymentsubscription.FieldTrialStart] = struct{}{}
}

// TrialStartCleared returns if the "trial_start" field was cleared in this mutation.
func (m *PaymentSubscriptionMutation) TrialStartCleared() bool {
	_, ok := m.clearedFields[paymentsubscription.FieldTrialStart]
	return ok
}

// ResetTrialStart resets all changes to the "trial_start" field.
func (m *PaymentSubscriptionMutation) ResetTrialStart() {
	m.trial_start = nil
	delete(m.clearedFields, paymentsubscription.FieldTrialStart)
}

// SetTrialEnd sets the "trial_end" field.
func (m *PaymentSubscriptionMutation) SetTrialEnd(t time.Time) {
	m.trial_end = &t
}

// TrialEnd returns the value of the "trial_end" field in the mutation.
func (m *PaymentSubscriptionMutation) TrialEnd() (r time.Time, exists bool) {
	v := m.trial_end
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialEnd returns the old "trial_end" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldTrialEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialEnd: %w", err)
	}
	return oldValue.TrialEnd, nil
}

// ClearTrialEnd clears the value of the "trial_end" field.
func (m *PaymentSubscriptionMutation) ClearTrialEnd() {
	m.trial_end = nil
	m.clearedFields[paymentsubscription.FieldTrialEnd] = struct{}{}
}

// TrialEndCleared returns if the "trial_end" field was cleared in this mutation.
func (m *PaymentSubscriptionMutation) TrialEndCleared() bool {
	_, ok := m.clearedFields[paymentsubscription.FieldTrialEnd]
	return ok
}

// ResetTrialEnd resets all changes to the "trial_end" field.
func (m *PaymentSubscriptionMutation) ResetTrialEnd() {
	m.trial_end = nil
	delete(m.clearedFields, paymentsubscription.FieldTrialEnd)
}

// SetProviderRef sets the "provider_ref" field.
func (m *PaymentSubscriptionMutation) SetProviderRef(s string) {
	m.provider_ref = &s
}

// ProviderRef returns the value of the "provider_ref" field in the mutation.
func (m *PaymentSubscriptionMutation) ProviderRef() (r string, exists bool) {
	v := m.provider_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderRef returns the old "provider_ref" field's value of the PaymentSubscription entity.
// If the PaymentSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentSubscriptionMutation) OldProviderRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderRef: %w", err)
	}
	return oldValue.ProviderRef, nil
}

// ClearProviderRef clears the value of the "provider_ref" field.
func (m *PaymentSubscriptionMutation) ClearProviderRef() {
	m.provider_ref = nil
	m.clearedFields[paymentsubscription.FieldProviderRef] = struct{}{}
}

// ProviderRefCleared returns if the "provider_ref" field was cleared in this mutation.
func (m *PaymentSubscriptionMutation) ProviderRefCleared() bool {
	_, ok := m.clearedFields[paymentsubscription.FieldProviderRef]
	return ok
}

// ResetProviderRef resets all changes to the "provider_ref" field.
func (m *PaymentSubscriptionMutation) ResetProviderRef() {
	m.provider_ref = nil
	delete(m.clearedFields, paymentsubscription.FieldProviderRef)
}

// ClearProduct clears the "product" edge to the PaymentProduct entity.
func (m *PaymentSubscriptionMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[paymentsubscription.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the PaymentProduct entity was cleared.
func (m *PaymentSubscriptionMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *PaymentSubscriptionMutation) ProductIDs() (ids []string) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *PaymentSubscriptionMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the PaymentSubscriptionMutation builder.
func (m *PaymentSubscriptionMutation) Where(ps ...predicate.PaymentSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentSubscription).
func (m *PaymentSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.extras != nil {
		fields = append(fields, paymentsubscription.FieldExtras)
	}
	if m.created_by != nil {
		fields = append(fields, paymentsubscription.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, paymentsubscription.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, paymentsubscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentsubscription.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, paymentsubscription.FieldStatus)
	}
	if m.user_id != nil {
		fields = append(fields, paymentsubscription.FieldUserID)
	}
	if m.tenant_id != nil {
		fields = append(fields, paymentsubscription.FieldTenantID)
	}
	if m.product != nil {
		fields = append(fields, paymentsubscription.FieldProductID)
	}
	if m.channel_id != nil {
		fields = append(fields, paymentsubscription.FieldChannelID)
	}
	if m.current_period_start != nil {
		fields = append(fields, paymentsubscription.FieldCurrentPeriodStart)
	}
	if m.current_period_end != nil {
		fields = append(fields, paymentsubscription.FieldCurrentPeriodEnd)
	}
	if m.cancel_at != nil {
		fields = append(fields, paymentsubscription.FieldCancelAt)
	}
	if m.cancelled_at != nil {
		fields = append(fields, paymentsubscription.FieldCancelledAt)
	}
	if m.trial_start != nil {
		fields = append(fields, paymentsubscription.FieldTrialStart)
	}
	if m.trial_end != nil {
		fields = append(fields, paymentsubscription.FieldTrialEnd)
	}
	if m.provider_ref != nil {
		fields = append(fields, paymentsubscription.FieldProviderRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentsubscription.FieldExtras:
		return m.Extras()
	case paymentsubscription.FieldCreatedBy:
		return m.CreatedBy()
	case paymentsubscription.FieldUpdatedBy:
		return m.UpdatedBy()
	case paymentsubscription.FieldCreatedAt:
		return m.CreatedAt()
	case paymentsubscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentsubscription.FieldStatus:
		return m.Status()
	case paymentsubscription.FieldUserID:
		return m.UserID()
	case paymentsubscription.FieldTenantID:
		return m.TenantID()
	case paymentsubscription.FieldProductID:
		return m.ProductID()
	case paymentsubscription.FieldChannelID:
		return m.ChannelID()
	case paymentsubscription.FieldCurrentPeriodStart:
		return m.CurrentPeriodStart()
	case paymentsubscription.FieldCurrentPeriodEnd:
		return m.CurrentPeriodEnd()
	case paymentsubscription.FieldCancelAt:
		return m.CancelAt()
	case paymentsubscription.FieldCancelledAt:
		return m.CancelledAt()
	case paymentsubscription.FieldTrialStart:
		return m.TrialStart()
	case paymentsubscription.FieldTrialEnd:
		return m.TrialEnd()
	case paymentsubscription.FieldProviderRef:
		return m.ProviderRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentsubscription.FieldExtras:
		return m.OldExtras(ctx)
	case paymentsubscription.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case paymentsubscription.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case paymentsubscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentsubscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentsubscription.FieldStatus:
		return m.OldStatus(ctx)
	case paymentsubscription.FieldUserID:
		return m.OldUserID(ctx)
	case paymentsubscription.FieldTenantID:
		return m.OldTenantID(ctx)
	case paymentsubscription.FieldProductID:
		return m.OldProductID(ctx)
	case paymentsubscription.FieldChannelID:
		return m.OldChannelID(ctx)
	case paymentsubscription.FieldCurrentPeriodStart:
		return m.OldCurrentPeriodStart(ctx)
	case paymentsubscription.FieldCurrentPeriodEnd:
		return m.OldCurrentPeriodEnd(ctx)
	case paymentsubscription.FieldCancelAt:
		return m.OldCancelAt(ctx)
	case paymentsubscription.FieldCancelledAt:
		return m.OldCancelledAt(ctx)
	case paymentsubscription.FieldTrialStart:
		return m.OldTrialStart(ctx)
	case paymentsubscription.FieldTrialEnd:
		return m.OldTrialEnd(ctx)
	case paymentsubscription.FieldProviderRef:
		return m.OldProviderRef(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentSubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentsubscription.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case paymentsubscription.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case paymentsubscription.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case paymentsubscription.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentsubscription.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentsubscription.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case paymentsubscription.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case paymentsubscription.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case paymentsubscription.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case paymentsubscription.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case paymentsubscription.FieldCurrentPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPeriodStart(v)
		return nil
	case paymentsubscription.FieldCurrentPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPeriodEnd(v)
		return nil
	case paymentsubscription.FieldCancelAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelAt(v)
		return nil
	case paymentsubscription.FieldCancelledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelledAt(v)
		return nil
	case paymentsubscription.FieldTrialStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialStart(v)
		return nil
	case paymentsubscription.FieldTrialEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialEnd(v)
		return nil
	case paymentsubscription.FieldProviderRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderRef(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentSubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, paymentsubscription.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, paymentsubscription.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentsubscription.FieldCreatedAt:
		return m.AddedCreatedAt()
	case paymentsubscription.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentsubscription.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case paymentsubscription.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentSubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentsubscription.FieldExtras) {
		fields = append(fields, paymentsubscription.FieldExtras)
	}
	if m.FieldCleared(paymentsubscription.FieldCreatedBy) {
		fields = append(fields, paymentsubscription.FieldCreatedBy)
	}
	if m.FieldCleared(paymentsubscription.FieldUpdatedBy) {
		fields = append(fields, paymentsubscription.FieldUpdatedBy)
	}
	if m.FieldCleared(paymentsubscription.FieldCreatedAt) {
		fields = append(fields, paymentsubscription.FieldCreatedAt)
	}
	if m.FieldCleared(paymentsubscription.FieldUpdatedAt) {
		fields = append(fields, paymentsubscription.FieldUpdatedAt)
	}
	if m.FieldCleared(paymentsubscription.FieldTenantID) {
		fields = append(fields, paymentsubscription.FieldTenantID)
	}
	if m.FieldCleared(paymentsubscription.FieldCancelAt) {
		fields = append(fields, paymentsubscription.FieldCancelAt)
	}
	if m.FieldCleared(paymentsubscription.FieldCancelledAt) {
		fields = append(fields, paymentsubscription.FieldCancelledAt)
	}
	if m.FieldCleared(paymentsubscription.FieldTrialStart) {
		fields = append(fields, paymentsubscription.FieldTrialStart)
	}
	if m.FieldCleared(paymentsubscription.FieldTrialEnd) {
		fields = append(fields, paymentsubscription.FieldTrialEnd)
	}
	if m.FieldCleared(paymentsubscription.FieldProviderRef) {
		fields = append(fields, paymentsubscription.FieldProviderRef)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentSubscriptionMutation) ClearField(name string) error {
	switch name {
	case paymentsubscription.FieldExtras:
		m.ClearExtras()
		return nil
	case paymentsubscription.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case paymentsubscription.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case paymentsubscription.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case paymentsubscription.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case paymentsubscription.FieldTenantID:
		m.ClearTenantID()
		return nil
	case paymentsubscription.FieldCancelAt:
		m.ClearCancelAt()
		return nil
	case paymentsubscription.FieldCancelledAt:
		m.ClearCancelledAt()
		return nil
	case paymentsubscription.FieldTrialStart:
		m.ClearTrialStart()
		return nil
	case paymentsubscription.FieldTrialEnd:
		m.ClearTrialEnd()
		return nil
	case paymentsubscription.FieldProviderRef:
		m.ClearProviderRef()
		return nil
	}
	return fmt.Errorf("unknown PaymentSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentSubscriptionMutation) ResetField(name string) error {
	switch name {
	case paymentsubscription.FieldExtras:
		m.ResetExtras()
		return nil
	case paymentsubscription.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case paymentsubscription.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case paymentsubscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentsubscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentsubscription.FieldStatus:
		m.ResetStatus()
		return nil
	case paymentsubscription.FieldUserID:
		m.ResetUserID()
		return nil
	case paymentsubscription.FieldTenantID:
		m.ResetTenantID()
		return nil
	case paymentsubscription.FieldProductID:
		m.ResetProductID()
		return nil
	case paymentsubscription.FieldChannelID:
		m.ResetChannelID()
		return nil
	case paymentsubscription.FieldCurrentPeriodStart:
		m.ResetCurrentPeriodStart()
		return nil
	case paymentsubscription.FieldCurrentPeriodEnd:
		m.ResetCurrentPeriodEnd()
		return nil
	case paymentsubscription.FieldCancelAt:
		m.ResetCancelAt()
		return nil
	case paymentsubscription.FieldCancelledAt:
		m.ResetCancelledAt()
		return nil
	case paymentsubscription.FieldTrialStart:
		m.ResetTrialStart()
		return nil
	case paymentsubscription.FieldTrialEnd:
		m.ResetTrialEnd()
		return nil
	case paymentsubscription.FieldProviderRef:
		m.ResetProviderRef()
		return nil
	}
	return fmt.Errorf("unknown PaymentSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product != nil {
		edges = append(edges, paymentsubscription.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentsubscription.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct {
		edges = append(edges, paymentsubscription.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentsubscription.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case paymentsubscription.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown PaymentSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case paymentsubscription.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown PaymentSubscription edge %s", name)
}
