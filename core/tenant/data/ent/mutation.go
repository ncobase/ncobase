// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"ncobase/tenant/data/ent/predicate"
	"ncobase/tenant/data/ent/tenant"
	"ncobase/tenant/data/ent/tenantbilling"
	"ncobase/tenant/data/ent/tenantgroup"
	"ncobase/tenant/data/ent/tenantquota"
	"ncobase/tenant/data/ent/tenantsetting"
	"ncobase/tenant/data/ent/usertenant"
	"ncobase/tenant/data/ent/usertenantrole"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeTenant         = "Tenant"
	TypeTenantBilling  = "TenantBilling"
	TypeTenantGroup    = "TenantGroup"
	TypeTenantQuota    = "TenantQuota"
	TypeTenantSetting  = "TenantSetting"
	TypeUserTenant     = "UserTenant"
	TypeUserTenantRole = "UserTenantRole"
)

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	slug          *string
	_type         *string
	title         *string
	url           *string
	logo          *string
	logo_alt      *string
	keywords      *string
	copyright     *string
	description   *string
	_order        *int
	add_order     *int
	disabled      *bool
	extras        *map[string]interface{}
	created_by    *string
	updated_by    *string
	expired_at    *int64
	addexpired_at *int64
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tenant, error)
	predicates    []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id string) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tenant entities.
func (m *TenantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TenantMutation) ClearName() {
	m.name = nil
	m.clearedFields[tenant.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TenantMutation) NameCleared() bool {
	_, ok := m.clearedFields[tenant.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, tenant.FieldName)
}

// SetSlug sets the "slug" field.
func (m *TenantMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TenantMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *TenantMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[tenant.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *TenantMutation) SlugCleared() bool {
	_, ok := m.clearedFields[tenant.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *TenantMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, tenant.FieldSlug)
}

// SetType sets the "type" field.
func (m *TenantMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TenantMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *TenantMutation) ClearType() {
	m._type = nil
	m.clearedFields[tenant.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *TenantMutation) TypeCleared() bool {
	_, ok := m.clearedFields[tenant.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *TenantMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, tenant.FieldType)
}

// SetTitle sets the "title" field.
func (m *TenantMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TenantMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *TenantMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[tenant.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *TenantMutation) TitleCleared() bool {
	_, ok := m.clearedFields[tenant.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *TenantMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, tenant.FieldTitle)
}

// SetURL sets the "url" field.
func (m *TenantMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *TenantMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *TenantMutation) ClearURL() {
	m.url = nil
	m.clearedFields[tenant.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *TenantMutation) URLCleared() bool {
	_, ok := m.clearedFields[tenant.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *TenantMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, tenant.FieldURL)
}

// SetLogo sets the "logo" field.
func (m *TenantMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *TenantMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *TenantMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[tenant.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *TenantMutation) LogoCleared() bool {
	_, ok := m.clearedFields[tenant.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *TenantMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, tenant.FieldLogo)
}

// SetLogoAlt sets the "logo_alt" field.
func (m *TenantMutation) SetLogoAlt(s string) {
	m.logo_alt = &s
}

// LogoAlt returns the value of the "logo_alt" field in the mutation.
func (m *TenantMutation) LogoAlt() (r string, exists bool) {
	v := m.logo_alt
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoAlt returns the old "logo_alt" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldLogoAlt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoAlt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoAlt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoAlt: %w", err)
	}
	return oldValue.LogoAlt, nil
}

// ClearLogoAlt clears the value of the "logo_alt" field.
func (m *TenantMutation) ClearLogoAlt() {
	m.logo_alt = nil
	m.clearedFields[tenant.FieldLogoAlt] = struct{}{}
}

// LogoAltCleared returns if the "logo_alt" field was cleared in this mutation.
func (m *TenantMutation) LogoAltCleared() bool {
	_, ok := m.clearedFields[tenant.FieldLogoAlt]
	return ok
}

// ResetLogoAlt resets all changes to the "logo_alt" field.
func (m *TenantMutation) ResetLogoAlt() {
	m.logo_alt = nil
	delete(m.clearedFields, tenant.FieldLogoAlt)
}

// SetKeywords sets the "keywords" field.
func (m *TenantMutation) SetKeywords(s string) {
	m.keywords = &s
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *TenantMutation) Keywords() (r string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldKeywords(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// ClearKeywords clears the value of the "keywords" field.
func (m *TenantMutation) ClearKeywords() {
	m.keywords = nil
	m.clearedFields[tenant.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *TenantMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[tenant.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *TenantMutation) ResetKeywords() {
	m.keywords = nil
	delete(m.clearedFields, tenant.FieldKeywords)
}

// SetCopyright sets the "copyright" field.
func (m *TenantMutation) SetCopyright(s string) {
	m.copyright = &s
}

// Copyright returns the value of the "copyright" field in the mutation.
func (m *TenantMutation) Copyright() (r string, exists bool) {
	v := m.copyright
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyright returns the old "copyright" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCopyright(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyright is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyright requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyright: %w", err)
	}
	return oldValue.Copyright, nil
}

// ClearCopyright clears the value of the "copyright" field.
func (m *TenantMutation) ClearCopyright() {
	m.copyright = nil
	m.clearedFields[tenant.FieldCopyright] = struct{}{}
}

// CopyrightCleared returns if the "copyright" field was cleared in this mutation.
func (m *TenantMutation) CopyrightCleared() bool {
	_, ok := m.clearedFields[tenant.FieldCopyright]
	return ok
}

// ResetCopyright resets all changes to the "copyright" field.
func (m *TenantMutation) ResetCopyright() {
	m.copyright = nil
	delete(m.clearedFields, tenant.FieldCopyright)
}

// SetDescription sets the "description" field.
func (m *TenantMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TenantMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TenantMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tenant.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TenantMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TenantMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tenant.FieldDescription)
}

// SetOrder sets the "order" field.
func (m *TenantMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *TenantMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *TenantMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *TenantMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *TenantMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetDisabled sets the "disabled" field.
func (m *TenantMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *TenantMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *TenantMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[tenant.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *TenantMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *TenantMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, tenant.FieldDisabled)
}

// SetExtras sets the "extras" field.
func (m *TenantMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *TenantMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *TenantMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[tenant.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *TenantMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[tenant.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *TenantMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, tenant.FieldExtras)
}

// SetCreatedBy sets the "created_by" field.
func (m *TenantMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TenantMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TenantMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[tenant.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TenantMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[tenant.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TenantMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, tenant.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TenantMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TenantMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TenantMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[tenant.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TenantMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[tenant.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TenantMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, tenant.FieldUpdatedBy)
}

// SetExpiredAt sets the "expired_at" field.
func (m *TenantMutation) SetExpiredAt(i int64) {
	m.expired_at = &i
	m.addexpired_at = nil
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TenantMutation) ExpiredAt() (r int64, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldExpiredAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// AddExpiredAt adds i to the "expired_at" field.
func (m *TenantMutation) AddExpiredAt(i int64) {
	if m.addexpired_at != nil {
		*m.addexpired_at += i
	} else {
		m.addexpired_at = &i
	}
}

// AddedExpiredAt returns the value that was added to the "expired_at" field in this mutation.
func (m *TenantMutation) AddedExpiredAt() (r int64, exists bool) {
	v := m.addexpired_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *TenantMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.addexpired_at = nil
	m.clearedFields[tenant.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *TenantMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TenantMutation) ResetExpiredAt() {
	m.expired_at = nil
	m.addexpired_at = nil
	delete(m.clearedFields, tenant.FieldExpiredAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TenantMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TenantMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TenantMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[tenant.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TenantMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, tenant.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TenantMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TenantMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TenantMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[tenant.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TenantMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, tenant.FieldUpdatedAt)
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, tenant.FieldSlug)
	}
	if m._type != nil {
		fields = append(fields, tenant.FieldType)
	}
	if m.title != nil {
		fields = append(fields, tenant.FieldTitle)
	}
	if m.url != nil {
		fields = append(fields, tenant.FieldURL)
	}
	if m.logo != nil {
		fields = append(fields, tenant.FieldLogo)
	}
	if m.logo_alt != nil {
		fields = append(fields, tenant.FieldLogoAlt)
	}
	if m.keywords != nil {
		fields = append(fields, tenant.FieldKeywords)
	}
	if m.copyright != nil {
		fields = append(fields, tenant.FieldCopyright)
	}
	if m.description != nil {
		fields = append(fields, tenant.FieldDescription)
	}
	if m._order != nil {
		fields = append(fields, tenant.FieldOrder)
	}
	if m.disabled != nil {
		fields = append(fields, tenant.FieldDisabled)
	}
	if m.extras != nil {
		fields = append(fields, tenant.FieldExtras)
	}
	if m.created_by != nil {
		fields = append(fields, tenant.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, tenant.FieldUpdatedBy)
	}
	if m.expired_at != nil {
		fields = append(fields, tenant.FieldExpiredAt)
	}
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldSlug:
		return m.Slug()
	case tenant.FieldType:
		return m.GetType()
	case tenant.FieldTitle:
		return m.Title()
	case tenant.FieldURL:
		return m.URL()
	case tenant.FieldLogo:
		return m.Logo()
	case tenant.FieldLogoAlt:
		return m.LogoAlt()
	case tenant.FieldKeywords:
		return m.Keywords()
	case tenant.FieldCopyright:
		return m.Copyright()
	case tenant.FieldDescription:
		return m.Description()
	case tenant.FieldOrder:
		return m.Order()
	case tenant.FieldDisabled:
		return m.Disabled()
	case tenant.FieldExtras:
		return m.Extras()
	case tenant.FieldCreatedBy:
		return m.CreatedBy()
	case tenant.FieldUpdatedBy:
		return m.UpdatedBy()
	case tenant.FieldExpiredAt:
		return m.ExpiredAt()
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldSlug:
		return m.OldSlug(ctx)
	case tenant.FieldType:
		return m.OldType(ctx)
	case tenant.FieldTitle:
		return m.OldTitle(ctx)
	case tenant.FieldURL:
		return m.OldURL(ctx)
	case tenant.FieldLogo:
		return m.OldLogo(ctx)
	case tenant.FieldLogoAlt:
		return m.OldLogoAlt(ctx)
	case tenant.FieldKeywords:
		return m.OldKeywords(ctx)
	case tenant.FieldCopyright:
		return m.OldCopyright(ctx)
	case tenant.FieldDescription:
		return m.OldDescription(ctx)
	case tenant.FieldOrder:
		return m.OldOrder(ctx)
	case tenant.FieldDisabled:
		return m.OldDisabled(ctx)
	case tenant.FieldExtras:
		return m.OldExtras(ctx)
	case tenant.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tenant.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case tenant.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case tenant.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tenant.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case tenant.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case tenant.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case tenant.FieldLogoAlt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoAlt(v)
		return nil
	case tenant.FieldKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case tenant.FieldCopyright:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyright(v)
		return nil
	case tenant.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tenant.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case tenant.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case tenant.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case tenant.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tenant.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case tenant.FieldExpiredAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case tenant.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, tenant.FieldOrder)
	}
	if m.addexpired_at != nil {
		fields = append(fields, tenant.FieldExpiredAt)
	}
	if m.addcreated_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldOrder:
		return m.AddedOrder()
	case tenant.FieldExpiredAt:
		return m.AddedExpiredAt()
	case tenant.FieldCreatedAt:
		return m.AddedCreatedAt()
	case tenant.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case tenant.FieldExpiredAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiredAt(v)
		return nil
	case tenant.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldName) {
		fields = append(fields, tenant.FieldName)
	}
	if m.FieldCleared(tenant.FieldSlug) {
		fields = append(fields, tenant.FieldSlug)
	}
	if m.FieldCleared(tenant.FieldType) {
		fields = append(fields, tenant.FieldType)
	}
	if m.FieldCleared(tenant.FieldTitle) {
		fields = append(fields, tenant.FieldTitle)
	}
	if m.FieldCleared(tenant.FieldURL) {
		fields = append(fields, tenant.FieldURL)
	}
	if m.FieldCleared(tenant.FieldLogo) {
		fields = append(fields, tenant.FieldLogo)
	}
	if m.FieldCleared(tenant.FieldLogoAlt) {
		fields = append(fields, tenant.FieldLogoAlt)
	}
	if m.FieldCleared(tenant.FieldKeywords) {
		fields = append(fields, tenant.FieldKeywords)
	}
	if m.FieldCleared(tenant.FieldCopyright) {
		fields = append(fields, tenant.FieldCopyright)
	}
	if m.FieldCleared(tenant.FieldDescription) {
		fields = append(fields, tenant.FieldDescription)
	}
	if m.FieldCleared(tenant.FieldDisabled) {
		fields = append(fields, tenant.FieldDisabled)
	}
	if m.FieldCleared(tenant.FieldExtras) {
		fields = append(fields, tenant.FieldExtras)
	}
	if m.FieldCleared(tenant.FieldCreatedBy) {
		fields = append(fields, tenant.FieldCreatedBy)
	}
	if m.FieldCleared(tenant.FieldUpdatedBy) {
		fields = append(fields, tenant.FieldUpdatedBy)
	}
	if m.FieldCleared(tenant.FieldExpiredAt) {
		fields = append(fields, tenant.FieldExpiredAt)
	}
	if m.FieldCleared(tenant.FieldCreatedAt) {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.FieldCleared(tenant.FieldUpdatedAt) {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldName:
		m.ClearName()
		return nil
	case tenant.FieldSlug:
		m.ClearSlug()
		return nil
	case tenant.FieldType:
		m.ClearType()
		return nil
	case tenant.FieldTitle:
		m.ClearTitle()
		return nil
	case tenant.FieldURL:
		m.ClearURL()
		return nil
	case tenant.FieldLogo:
		m.ClearLogo()
		return nil
	case tenant.FieldLogoAlt:
		m.ClearLogoAlt()
		return nil
	case tenant.FieldKeywords:
		m.ClearKeywords()
		return nil
	case tenant.FieldCopyright:
		m.ClearCopyright()
		return nil
	case tenant.FieldDescription:
		m.ClearDescription()
		return nil
	case tenant.FieldDisabled:
		m.ClearDisabled()
		return nil
	case tenant.FieldExtras:
		m.ClearExtras()
		return nil
	case tenant.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tenant.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case tenant.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	case tenant.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldSlug:
		m.ResetSlug()
		return nil
	case tenant.FieldType:
		m.ResetType()
		return nil
	case tenant.FieldTitle:
		m.ResetTitle()
		return nil
	case tenant.FieldURL:
		m.ResetURL()
		return nil
	case tenant.FieldLogo:
		m.ResetLogo()
		return nil
	case tenant.FieldLogoAlt:
		m.ResetLogoAlt()
		return nil
	case tenant.FieldKeywords:
		m.ResetKeywords()
		return nil
	case tenant.FieldCopyright:
		m.ResetCopyright()
		return nil
	case tenant.FieldDescription:
		m.ResetDescription()
		return nil
	case tenant.FieldOrder:
		m.ResetOrder()
		return nil
	case tenant.FieldDisabled:
		m.ResetDisabled()
		return nil
	case tenant.FieldExtras:
		m.ResetExtras()
		return nil
	case tenant.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tenant.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case tenant.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TenantBillingMutation represents an operation that mutates the TenantBilling nodes in the graph.
type TenantBillingMutation struct {
	config
	op              Op
	typ             string
	id              *string
	tenant_id       *string
	description     *string
	extras          *map[string]interface{}
	created_by      *string
	updated_by      *string
	created_at      *int64
	addcreated_at   *int64
	updated_at      *int64
	addupdated_at   *int64
	billing_period  *string
	period_start    *int64
	addperiod_start *int64
	period_end      *int64
	addperiod_end   *int64
	amount          *float64
	addamount       *float64
	currency        *string
	status          *string
	invoice_number  *string
	payment_method  *string
	paid_at         *int64
	addpaid_at      *int64
	due_date        *int64
	adddue_date     *int64
	usage_details   *map[string]interface{}
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TenantBilling, error)
	predicates      []predicate.TenantBilling
}

var _ ent.Mutation = (*TenantBillingMutation)(nil)

// tenantbillingOption allows management of the mutation configuration using functional options.
type tenantbillingOption func(*TenantBillingMutation)

// newTenantBillingMutation creates new mutation for the TenantBilling entity.
func newTenantBillingMutation(c config, op Op, opts ...tenantbillingOption) *TenantBillingMutation {
	m := &TenantBillingMutation{
		config:        c,
		op:            op,
		typ:           TypeTenantBilling,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantBillingID sets the ID field of the mutation.
func withTenantBillingID(id string) tenantbillingOption {
	return func(m *TenantBillingMutation) {
		var (
			err   error
			once  sync.Once
			value *TenantBilling
		)
		m.oldValue = func(ctx context.Context) (*TenantBilling, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TenantBilling.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenantBilling sets the old TenantBilling of the mutation.
func withTenantBilling(node *TenantBilling) tenantbillingOption {
	return func(m *TenantBillingMutation) {
		m.oldValue = func(context.Context) (*TenantBilling, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantBillingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantBillingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TenantBilling entities.
func (m *TenantBillingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantBillingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantBillingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TenantBilling.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TenantBillingMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TenantBillingMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *TenantBillingMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[tenantbilling.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *TenantBillingMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TenantBillingMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, tenantbilling.FieldTenantID)
}

// SetDescription sets the "description" field.
func (m *TenantBillingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TenantBillingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TenantBillingMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tenantbilling.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TenantBillingMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TenantBillingMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tenantbilling.FieldDescription)
}

// SetExtras sets the "extras" field.
func (m *TenantBillingMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *TenantBillingMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *TenantBillingMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[tenantbilling.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *TenantBillingMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *TenantBillingMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, tenantbilling.FieldExtras)
}

// SetCreatedBy sets the "created_by" field.
func (m *TenantBillingMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TenantBillingMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TenantBillingMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[tenantbilling.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TenantBillingMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TenantBillingMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, tenantbilling.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TenantBillingMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TenantBillingMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TenantBillingMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[tenantbilling.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TenantBillingMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TenantBillingMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, tenantbilling.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantBillingMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantBillingMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TenantBillingMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TenantBillingMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TenantBillingMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[tenantbilling.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TenantBillingMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantBillingMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, tenantbilling.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantBillingMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantBillingMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TenantBillingMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TenantBillingMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TenantBillingMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[tenantbilling.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TenantBillingMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantBillingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, tenantbilling.FieldUpdatedAt)
}

// SetBillingPeriod sets the "billing_period" field.
func (m *TenantBillingMutation) SetBillingPeriod(s string) {
	m.billing_period = &s
}

// BillingPeriod returns the value of the "billing_period" field in the mutation.
func (m *TenantBillingMutation) BillingPeriod() (r string, exists bool) {
	v := m.billing_period
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingPeriod returns the old "billing_period" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldBillingPeriod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingPeriod: %w", err)
	}
	return oldValue.BillingPeriod, nil
}

// ResetBillingPeriod resets all changes to the "billing_period" field.
func (m *TenantBillingMutation) ResetBillingPeriod() {
	m.billing_period = nil
}

// SetPeriodStart sets the "period_start" field.
func (m *TenantBillingMutation) SetPeriodStart(i int64) {
	m.period_start = &i
	m.addperiod_start = nil
}

// PeriodStart returns the value of the "period_start" field in the mutation.
func (m *TenantBillingMutation) PeriodStart() (r int64, exists bool) {
	v := m.period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodStart returns the old "period_start" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldPeriodStart(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodStart: %w", err)
	}
	return oldValue.PeriodStart, nil
}

// AddPeriodStart adds i to the "period_start" field.
func (m *TenantBillingMutation) AddPeriodStart(i int64) {
	if m.addperiod_start != nil {
		*m.addperiod_start += i
	} else {
		m.addperiod_start = &i
	}
}

// AddedPeriodStart returns the value that was added to the "period_start" field in this mutation.
func (m *TenantBillingMutation) AddedPeriodStart() (r int64, exists bool) {
	v := m.addperiod_start
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeriodStart clears the value of the "period_start" field.
func (m *TenantBillingMutation) ClearPeriodStart() {
	m.period_start = nil
	m.addperiod_start = nil
	m.clearedFields[tenantbilling.FieldPeriodStart] = struct{}{}
}

// PeriodStartCleared returns if the "period_start" field was cleared in this mutation.
func (m *TenantBillingMutation) PeriodStartCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldPeriodStart]
	return ok
}

// ResetPeriodStart resets all changes to the "period_start" field.
func (m *TenantBillingMutation) ResetPeriodStart() {
	m.period_start = nil
	m.addperiod_start = nil
	delete(m.clearedFields, tenantbilling.FieldPeriodStart)
}

// SetPeriodEnd sets the "period_end" field.
func (m *TenantBillingMutation) SetPeriodEnd(i int64) {
	m.period_end = &i
	m.addperiod_end = nil
}

// PeriodEnd returns the value of the "period_end" field in the mutation.
func (m *TenantBillingMutation) PeriodEnd() (r int64, exists bool) {
	v := m.period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodEnd returns the old "period_end" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldPeriodEnd(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodEnd: %w", err)
	}
	return oldValue.PeriodEnd, nil
}

// AddPeriodEnd adds i to the "period_end" field.
func (m *TenantBillingMutation) AddPeriodEnd(i int64) {
	if m.addperiod_end != nil {
		*m.addperiod_end += i
	} else {
		m.addperiod_end = &i
	}
}

// AddedPeriodEnd returns the value that was added to the "period_end" field in this mutation.
func (m *TenantBillingMutation) AddedPeriodEnd() (r int64, exists bool) {
	v := m.addperiod_end
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeriodEnd clears the value of the "period_end" field.
func (m *TenantBillingMutation) ClearPeriodEnd() {
	m.period_end = nil
	m.addperiod_end = nil
	m.clearedFields[tenantbilling.FieldPeriodEnd] = struct{}{}
}

// PeriodEndCleared returns if the "period_end" field was cleared in this mutation.
func (m *TenantBillingMutation) PeriodEndCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldPeriodEnd]
	return ok
}

// ResetPeriodEnd resets all changes to the "period_end" field.
func (m *TenantBillingMutation) ResetPeriodEnd() {
	m.period_end = nil
	m.addperiod_end = nil
	delete(m.clearedFields, tenantbilling.FieldPeriodEnd)
}

// SetAmount sets the "amount" field.
func (m *TenantBillingMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TenantBillingMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TenantBillingMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TenantBillingMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TenantBillingMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCurrency sets the "currency" field.
func (m *TenantBillingMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *TenantBillingMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *TenantBillingMutation) ResetCurrency() {
	m.currency = nil
}

// SetStatus sets the "status" field.
func (m *TenantBillingMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TenantBillingMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TenantBillingMutation) ResetStatus() {
	m.status = nil
}

// SetInvoiceNumber sets the "invoice_number" field.
func (m *TenantBillingMutation) SetInvoiceNumber(s string) {
	m.invoice_number = &s
}

// InvoiceNumber returns the value of the "invoice_number" field in the mutation.
func (m *TenantBillingMutation) InvoiceNumber() (r string, exists bool) {
	v := m.invoice_number
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceNumber returns the old "invoice_number" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldInvoiceNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceNumber: %w", err)
	}
	return oldValue.InvoiceNumber, nil
}

// ClearInvoiceNumber clears the value of the "invoice_number" field.
func (m *TenantBillingMutation) ClearInvoiceNumber() {
	m.invoice_number = nil
	m.clearedFields[tenantbilling.FieldInvoiceNumber] = struct{}{}
}

// InvoiceNumberCleared returns if the "invoice_number" field was cleared in this mutation.
func (m *TenantBillingMutation) InvoiceNumberCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldInvoiceNumber]
	return ok
}

// ResetInvoiceNumber resets all changes to the "invoice_number" field.
func (m *TenantBillingMutation) ResetInvoiceNumber() {
	m.invoice_number = nil
	delete(m.clearedFields, tenantbilling.FieldInvoiceNumber)
}

// SetPaymentMethod sets the "payment_method" field.
func (m *TenantBillingMutation) SetPaymentMethod(s string) {
	m.payment_method = &s
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *TenantBillingMutation) PaymentMethod() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldPaymentMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ClearPaymentMethod clears the value of the "payment_method" field.
func (m *TenantBillingMutation) ClearPaymentMethod() {
	m.payment_method = nil
	m.clearedFields[tenantbilling.FieldPaymentMethod] = struct{}{}
}

// PaymentMethodCleared returns if the "payment_method" field was cleared in this mutation.
func (m *TenantBillingMutation) PaymentMethodCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldPaymentMethod]
	return ok
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *TenantBillingMutation) ResetPaymentMethod() {
	m.payment_method = nil
	delete(m.clearedFields, tenantbilling.FieldPaymentMethod)
}

// SetPaidAt sets the "paid_at" field.
func (m *TenantBillingMutation) SetPaidAt(i int64) {
	m.paid_at = &i
	m.addpaid_at = nil
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *TenantBillingMutation) PaidAt() (r int64, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldPaidAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// AddPaidAt adds i to the "paid_at" field.
func (m *TenantBillingMutation) AddPaidAt(i int64) {
	if m.addpaid_at != nil {
		*m.addpaid_at += i
	} else {
		m.addpaid_at = &i
	}
}

// AddedPaidAt returns the value that was added to the "paid_at" field in this mutation.
func (m *TenantBillingMutation) AddedPaidAt() (r int64, exists bool) {
	v := m.addpaid_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *TenantBillingMutation) ClearPaidAt() {
	m.paid_at = nil
	m.addpaid_at = nil
	m.clearedFields[tenantbilling.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *TenantBillingMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *TenantBillingMutation) ResetPaidAt() {
	m.paid_at = nil
	m.addpaid_at = nil
	delete(m.clearedFields, tenantbilling.FieldPaidAt)
}

// SetDueDate sets the "due_date" field.
func (m *TenantBillingMutation) SetDueDate(i int64) {
	m.due_date = &i
	m.adddue_date = nil
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *TenantBillingMutation) DueDate() (r int64, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldDueDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// AddDueDate adds i to the "due_date" field.
func (m *TenantBillingMutation) AddDueDate(i int64) {
	if m.adddue_date != nil {
		*m.adddue_date += i
	} else {
		m.adddue_date = &i
	}
}

// AddedDueDate returns the value that was added to the "due_date" field in this mutation.
func (m *TenantBillingMutation) AddedDueDate() (r int64, exists bool) {
	v := m.adddue_date
	if v == nil {
		return
	}
	return *v, true
}

// ClearDueDate clears the value of the "due_date" field.
func (m *TenantBillingMutation) ClearDueDate() {
	m.due_date = nil
	m.adddue_date = nil
	m.clearedFields[tenantbilling.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *TenantBillingMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *TenantBillingMutation) ResetDueDate() {
	m.due_date = nil
	m.adddue_date = nil
	delete(m.clearedFields, tenantbilling.FieldDueDate)
}

// SetUsageDetails sets the "usage_details" field.
func (m *TenantBillingMutation) SetUsageDetails(value map[string]interface{}) {
	m.usage_details = &value
}

// UsageDetails returns the value of the "usage_details" field in the mutation.
func (m *TenantBillingMutation) UsageDetails() (r map[string]interface{}, exists bool) {
	v := m.usage_details
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageDetails returns the old "usage_details" field's value of the TenantBilling entity.
// If the TenantBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantBillingMutation) OldUsageDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageDetails: %w", err)
	}
	return oldValue.UsageDetails, nil
}

// ClearUsageDetails clears the value of the "usage_details" field.
func (m *TenantBillingMutation) ClearUsageDetails() {
	m.usage_details = nil
	m.clearedFields[tenantbilling.FieldUsageDetails] = struct{}{}
}

// UsageDetailsCleared returns if the "usage_details" field was cleared in this mutation.
func (m *TenantBillingMutation) UsageDetailsCleared() bool {
	_, ok := m.clearedFields[tenantbilling.FieldUsageDetails]
	return ok
}

// ResetUsageDetails resets all changes to the "usage_details" field.
func (m *TenantBillingMutation) ResetUsageDetails() {
	m.usage_details = nil
	delete(m.clearedFields, tenantbilling.FieldUsageDetails)
}

// Where appends a list predicates to the TenantBillingMutation builder.
func (m *TenantBillingMutation) Where(ps ...predicate.TenantBilling) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantBillingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantBillingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TenantBilling, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantBillingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantBillingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TenantBilling).
func (m *TenantBillingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantBillingMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.tenant_id != nil {
		fields = append(fields, tenantbilling.FieldTenantID)
	}
	if m.description != nil {
		fields = append(fields, tenantbilling.FieldDescription)
	}
	if m.extras != nil {
		fields = append(fields, tenantbilling.FieldExtras)
	}
	if m.created_by != nil {
		fields = append(fields, tenantbilling.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, tenantbilling.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, tenantbilling.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenantbilling.FieldUpdatedAt)
	}
	if m.billing_period != nil {
		fields = append(fields, tenantbilling.FieldBillingPeriod)
	}
	if m.period_start != nil {
		fields = append(fields, tenantbilling.FieldPeriodStart)
	}
	if m.period_end != nil {
		fields = append(fields, tenantbilling.FieldPeriodEnd)
	}
	if m.amount != nil {
		fields = append(fields, tenantbilling.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, tenantbilling.FieldCurrency)
	}
	if m.status != nil {
		fields = append(fields, tenantbilling.FieldStatus)
	}
	if m.invoice_number != nil {
		fields = append(fields, tenantbilling.FieldInvoiceNumber)
	}
	if m.payment_method != nil {
		fields = append(fields, tenantbilling.FieldPaymentMethod)
	}
	if m.paid_at != nil {
		fields = append(fields, tenantbilling.FieldPaidAt)
	}
	if m.due_date != nil {
		fields = append(fields, tenantbilling.FieldDueDate)
	}
	if m.usage_details != nil {
		fields = append(fields, tenantbilling.FieldUsageDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantBillingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenantbilling.FieldTenantID:
		return m.TenantID()
	case tenantbilling.FieldDescription:
		return m.Description()
	case tenantbilling.FieldExtras:
		return m.Extras()
	case tenantbilling.FieldCreatedBy:
		return m.CreatedBy()
	case tenantbilling.FieldUpdatedBy:
		return m.UpdatedBy()
	case tenantbilling.FieldCreatedAt:
		return m.CreatedAt()
	case tenantbilling.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenantbilling.FieldBillingPeriod:
		return m.BillingPeriod()
	case tenantbilling.FieldPeriodStart:
		return m.PeriodStart()
	case tenantbilling.FieldPeriodEnd:
		return m.PeriodEnd()
	case tenantbilling.FieldAmount:
		return m.Amount()
	case tenantbilling.FieldCurrency:
		return m.Currency()
	case tenantbilling.FieldStatus:
		return m.Status()
	case tenantbilling.FieldInvoiceNumber:
		return m.InvoiceNumber()
	case tenantbilling.FieldPaymentMethod:
		return m.PaymentMethod()
	case tenantbilling.FieldPaidAt:
		return m.PaidAt()
	case tenantbilling.FieldDueDate:
		return m.DueDate()
	case tenantbilling.FieldUsageDetails:
		return m.UsageDetails()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantBillingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenantbilling.FieldTenantID:
		return m.OldTenantID(ctx)
	case tenantbilling.FieldDescription:
		return m.OldDescription(ctx)
	case tenantbilling.FieldExtras:
		return m.OldExtras(ctx)
	case tenantbilling.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tenantbilling.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case tenantbilling.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenantbilling.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenantbilling.FieldBillingPeriod:
		return m.OldBillingPeriod(ctx)
	case tenantbilling.FieldPeriodStart:
		return m.OldPeriodStart(ctx)
	case tenantbilling.FieldPeriodEnd:
		return m.OldPeriodEnd(ctx)
	case tenantbilling.FieldAmount:
		return m.OldAmount(ctx)
	case tenantbilling.FieldCurrency:
		return m.OldCurrency(ctx)
	case tenantbilling.FieldStatus:
		return m.OldStatus(ctx)
	case tenantbilling.FieldInvoiceNumber:
		return m.OldInvoiceNumber(ctx)
	case tenantbilling.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case tenantbilling.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case tenantbilling.FieldDueDate:
		return m.OldDueDate(ctx)
	case tenantbilling.FieldUsageDetails:
		return m.OldUsageDetails(ctx)
	}
	return nil, fmt.Errorf("unknown TenantBilling field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantBillingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenantbilling.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tenantbilling.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tenantbilling.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case tenantbilling.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tenantbilling.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case tenantbilling.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenantbilling.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenantbilling.FieldBillingPeriod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingPeriod(v)
		return nil
	case tenantbilling.FieldPeriodStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodStart(v)
		return nil
	case tenantbilling.FieldPeriodEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodEnd(v)
		return nil
	case tenantbilling.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case tenantbilling.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case tenantbilling.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tenantbilling.FieldInvoiceNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceNumber(v)
		return nil
	case tenantbilling.FieldPaymentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case tenantbilling.FieldPaidAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case tenantbilling.FieldDueDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case tenantbilling.FieldUsageDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageDetails(v)
		return nil
	}
	return fmt.Errorf("unknown TenantBilling field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantBillingMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, tenantbilling.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, tenantbilling.FieldUpdatedAt)
	}
	if m.addperiod_start != nil {
		fields = append(fields, tenantbilling.FieldPeriodStart)
	}
	if m.addperiod_end != nil {
		fields = append(fields, tenantbilling.FieldPeriodEnd)
	}
	if m.addamount != nil {
		fields = append(fields, tenantbilling.FieldAmount)
	}
	if m.addpaid_at != nil {
		fields = append(fields, tenantbilling.FieldPaidAt)
	}
	if m.adddue_date != nil {
		fields = append(fields, tenantbilling.FieldDueDate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantBillingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenantbilling.FieldCreatedAt:
		return m.AddedCreatedAt()
	case tenantbilling.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case tenantbilling.FieldPeriodStart:
		return m.AddedPeriodStart()
	case tenantbilling.FieldPeriodEnd:
		return m.AddedPeriodEnd()
	case tenantbilling.FieldAmount:
		return m.AddedAmount()
	case tenantbilling.FieldPaidAt:
		return m.AddedPaidAt()
	case tenantbilling.FieldDueDate:
		return m.AddedDueDate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantBillingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenantbilling.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case tenantbilling.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case tenantbilling.FieldPeriodStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriodStart(v)
		return nil
	case tenantbilling.FieldPeriodEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriodEnd(v)
		return nil
	case tenantbilling.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case tenantbilling.FieldPaidAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaidAt(v)
		return nil
	case tenantbilling.FieldDueDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDueDate(v)
		return nil
	}
	return fmt.Errorf("unknown TenantBilling numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantBillingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenantbilling.FieldTenantID) {
		fields = append(fields, tenantbilling.FieldTenantID)
	}
	if m.FieldCleared(tenantbilling.FieldDescription) {
		fields = append(fields, tenantbilling.FieldDescription)
	}
	if m.FieldCleared(tenantbilling.FieldExtras) {
		fields = append(fields, tenantbilling.FieldExtras)
	}
	if m.FieldCleared(tenantbilling.FieldCreatedBy) {
		fields = append(fields, tenantbilling.FieldCreatedBy)
	}
	if m.FieldCleared(tenantbilling.FieldUpdatedBy) {
		fields = append(fields, tenantbilling.FieldUpdatedBy)
	}
	if m.FieldCleared(tenantbilling.FieldCreatedAt) {
		fields = append(fields, tenantbilling.FieldCreatedAt)
	}
	if m.FieldCleared(tenantbilling.FieldUpdatedAt) {
		fields = append(fields, tenantbilling.FieldUpdatedAt)
	}
	if m.FieldCleared(tenantbilling.FieldPeriodStart) {
		fields = append(fields, tenantbilling.FieldPeriodStart)
	}
	if m.FieldCleared(tenantbilling.FieldPeriodEnd) {
		fields = append(fields, tenantbilling.FieldPeriodEnd)
	}
	if m.FieldCleared(tenantbilling.FieldInvoiceNumber) {
		fields = append(fields, tenantbilling.FieldInvoiceNumber)
	}
	if m.FieldCleared(tenantbilling.FieldPaymentMethod) {
		fields = append(fields, tenantbilling.FieldPaymentMethod)
	}
	if m.FieldCleared(tenantbilling.FieldPaidAt) {
		fields = append(fields, tenantbilling.FieldPaidAt)
	}
	if m.FieldCleared(tenantbilling.FieldDueDate) {
		fields = append(fields, tenantbilling.FieldDueDate)
	}
	if m.FieldCleared(tenantbilling.FieldUsageDetails) {
		fields = append(fields, tenantbilling.FieldUsageDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantBillingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantBillingMutation) ClearField(name string) error {
	switch name {
	case tenantbilling.FieldTenantID:
		m.ClearTenantID()
		return nil
	case tenantbilling.FieldDescription:
		m.ClearDescription()
		return nil
	case tenantbilling.FieldExtras:
		m.ClearExtras()
		return nil
	case tenantbilling.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tenantbilling.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case tenantbilling.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tenantbilling.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tenantbilling.FieldPeriodStart:
		m.ClearPeriodStart()
		return nil
	case tenantbilling.FieldPeriodEnd:
		m.ClearPeriodEnd()
		return nil
	case tenantbilling.FieldInvoiceNumber:
		m.ClearInvoiceNumber()
		return nil
	case tenantbilling.FieldPaymentMethod:
		m.ClearPaymentMethod()
		return nil
	case tenantbilling.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	case tenantbilling.FieldDueDate:
		m.ClearDueDate()
		return nil
	case tenantbilling.FieldUsageDetails:
		m.ClearUsageDetails()
		return nil
	}
	return fmt.Errorf("unknown TenantBilling nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantBillingMutation) ResetField(name string) error {
	switch name {
	case tenantbilling.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tenantbilling.FieldDescription:
		m.ResetDescription()
		return nil
	case tenantbilling.FieldExtras:
		m.ResetExtras()
		return nil
	case tenantbilling.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tenantbilling.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case tenantbilling.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenantbilling.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenantbilling.FieldBillingPeriod:
		m.ResetBillingPeriod()
		return nil
	case tenantbilling.FieldPeriodStart:
		m.ResetPeriodStart()
		return nil
	case tenantbilling.FieldPeriodEnd:
		m.ResetPeriodEnd()
		return nil
	case tenantbilling.FieldAmount:
		m.ResetAmount()
		return nil
	case tenantbilling.FieldCurrency:
		m.ResetCurrency()
		return nil
	case tenantbilling.FieldStatus:
		m.ResetStatus()
		return nil
	case tenantbilling.FieldInvoiceNumber:
		m.ResetInvoiceNumber()
		return nil
	case tenantbilling.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case tenantbilling.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case tenantbilling.FieldDueDate:
		m.ResetDueDate()
		return nil
	case tenantbilling.FieldUsageDetails:
		m.ResetUsageDetails()
		return nil
	}
	return fmt.Errorf("unknown TenantBilling field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantBillingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantBillingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantBillingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantBillingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantBillingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantBillingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantBillingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TenantBilling unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantBillingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TenantBilling edge %s", name)
}

// TenantGroupMutation represents an operation that mutates the TenantGroup nodes in the graph.
type TenantGroupMutation struct {
	config
	op            Op
	typ           string
	id            *string
	tenant_id     *string
	group_id      *string
	created_by    *string
	updated_by    *string
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	relation_type *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TenantGroup, error)
	predicates    []predicate.TenantGroup
}

var _ ent.Mutation = (*TenantGroupMutation)(nil)

// tenantgroupOption allows management of the mutation configuration using functional options.
type tenantgroupOption func(*TenantGroupMutation)

// newTenantGroupMutation creates new mutation for the TenantGroup entity.
func newTenantGroupMutation(c config, op Op, opts ...tenantgroupOption) *TenantGroupMutation {
	m := &TenantGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeTenantGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantGroupID sets the ID field of the mutation.
func withTenantGroupID(id string) tenantgroupOption {
	return func(m *TenantGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *TenantGroup
		)
		m.oldValue = func(ctx context.Context) (*TenantGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TenantGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenantGroup sets the old TenantGroup of the mutation.
func withTenantGroup(node *TenantGroup) tenantgroupOption {
	return func(m *TenantGroupMutation) {
		m.oldValue = func(context.Context) (*TenantGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TenantGroup entities.
func (m *TenantGroupMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantGroupMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantGroupMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TenantGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TenantGroupMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TenantGroupMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TenantGroup entity.
// If the TenantGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantGroupMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *TenantGroupMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[tenantgroup.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *TenantGroupMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[tenantgroup.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TenantGroupMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, tenantgroup.FieldTenantID)
}

// SetGroupID sets the "group_id" field.
func (m *TenantGroupMutation) SetGroupID(s string) {
	m.group_id = &s
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *TenantGroupMutation) GroupID() (r string, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the TenantGroup entity.
// If the TenantGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantGroupMutation) OldGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *TenantGroupMutation) ClearGroupID() {
	m.group_id = nil
	m.clearedFields[tenantgroup.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *TenantGroupMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[tenantgroup.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *TenantGroupMutation) ResetGroupID() {
	m.group_id = nil
	delete(m.clearedFields, tenantgroup.FieldGroupID)
}

// SetCreatedBy sets the "created_by" field.
func (m *TenantGroupMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TenantGroupMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TenantGroup entity.
// If the TenantGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantGroupMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TenantGroupMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[tenantgroup.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TenantGroupMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[tenantgroup.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TenantGroupMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, tenantgroup.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TenantGroupMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TenantGroupMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TenantGroup entity.
// If the TenantGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantGroupMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TenantGroupMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[tenantgroup.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TenantGroupMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[tenantgroup.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TenantGroupMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, tenantgroup.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantGroupMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantGroupMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TenantGroup entity.
// If the TenantGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantGroupMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TenantGroupMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TenantGroupMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TenantGroupMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[tenantgroup.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TenantGroupMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tenantgroup.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantGroupMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, tenantgroup.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantGroupMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantGroupMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TenantGroup entity.
// If the TenantGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantGroupMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TenantGroupMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TenantGroupMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TenantGroupMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[tenantgroup.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TenantGroupMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tenantgroup.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, tenantgroup.FieldUpdatedAt)
}

// SetRelationType sets the "relation_type" field.
func (m *TenantGroupMutation) SetRelationType(s string) {
	m.relation_type = &s
}

// RelationType returns the value of the "relation_type" field in the mutation.
func (m *TenantGroupMutation) RelationType() (r string, exists bool) {
	v := m.relation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationType returns the old "relation_type" field's value of the TenantGroup entity.
// If the TenantGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantGroupMutation) OldRelationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationType: %w", err)
	}
	return oldValue.RelationType, nil
}

// ResetRelationType resets all changes to the "relation_type" field.
func (m *TenantGroupMutation) ResetRelationType() {
	m.relation_type = nil
}

// Where appends a list predicates to the TenantGroupMutation builder.
func (m *TenantGroupMutation) Where(ps ...predicate.TenantGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TenantGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TenantGroup).
func (m *TenantGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantGroupMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant_id != nil {
		fields = append(fields, tenantgroup.FieldTenantID)
	}
	if m.group_id != nil {
		fields = append(fields, tenantgroup.FieldGroupID)
	}
	if m.created_by != nil {
		fields = append(fields, tenantgroup.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, tenantgroup.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, tenantgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenantgroup.FieldUpdatedAt)
	}
	if m.relation_type != nil {
		fields = append(fields, tenantgroup.FieldRelationType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenantgroup.FieldTenantID:
		return m.TenantID()
	case tenantgroup.FieldGroupID:
		return m.GroupID()
	case tenantgroup.FieldCreatedBy:
		return m.CreatedBy()
	case tenantgroup.FieldUpdatedBy:
		return m.UpdatedBy()
	case tenantgroup.FieldCreatedAt:
		return m.CreatedAt()
	case tenantgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenantgroup.FieldRelationType:
		return m.RelationType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenantgroup.FieldTenantID:
		return m.OldTenantID(ctx)
	case tenantgroup.FieldGroupID:
		return m.OldGroupID(ctx)
	case tenantgroup.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tenantgroup.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case tenantgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenantgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenantgroup.FieldRelationType:
		return m.OldRelationType(ctx)
	}
	return nil, fmt.Errorf("unknown TenantGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenantgroup.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tenantgroup.FieldGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case tenantgroup.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tenantgroup.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case tenantgroup.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenantgroup.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenantgroup.FieldRelationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationType(v)
		return nil
	}
	return fmt.Errorf("unknown TenantGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantGroupMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, tenantgroup.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, tenantgroup.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenantgroup.FieldCreatedAt:
		return m.AddedCreatedAt()
	case tenantgroup.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenantgroup.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case tenantgroup.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TenantGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenantgroup.FieldTenantID) {
		fields = append(fields, tenantgroup.FieldTenantID)
	}
	if m.FieldCleared(tenantgroup.FieldGroupID) {
		fields = append(fields, tenantgroup.FieldGroupID)
	}
	if m.FieldCleared(tenantgroup.FieldCreatedBy) {
		fields = append(fields, tenantgroup.FieldCreatedBy)
	}
	if m.FieldCleared(tenantgroup.FieldUpdatedBy) {
		fields = append(fields, tenantgroup.FieldUpdatedBy)
	}
	if m.FieldCleared(tenantgroup.FieldCreatedAt) {
		fields = append(fields, tenantgroup.FieldCreatedAt)
	}
	if m.FieldCleared(tenantgroup.FieldUpdatedAt) {
		fields = append(fields, tenantgroup.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantGroupMutation) ClearField(name string) error {
	switch name {
	case tenantgroup.FieldTenantID:
		m.ClearTenantID()
		return nil
	case tenantgroup.FieldGroupID:
		m.ClearGroupID()
		return nil
	case tenantgroup.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tenantgroup.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case tenantgroup.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tenantgroup.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TenantGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantGroupMutation) ResetField(name string) error {
	switch name {
	case tenantgroup.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tenantgroup.FieldGroupID:
		m.ResetGroupID()
		return nil
	case tenantgroup.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tenantgroup.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case tenantgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenantgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenantgroup.FieldRelationType:
		m.ResetRelationType()
		return nil
	}
	return fmt.Errorf("unknown TenantGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TenantGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TenantGroup edge %s", name)
}

// TenantQuotaMutation represents an operation that mutates the TenantQuota nodes in the graph.
type TenantQuotaMutation struct {
	config
	op              Op
	typ             string
	id              *string
	tenant_id       *string
	description     *string
	extras          *map[string]interface{}
	created_by      *string
	updated_by      *string
	created_at      *int64
	addcreated_at   *int64
	updated_at      *int64
	addupdated_at   *int64
	quota_type      *string
	quota_name      *string
	max_value       *int64
	addmax_value    *int64
	current_used    *int64
	addcurrent_used *int64
	unit            *string
	enabled         *bool
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TenantQuota, error)
	predicates      []predicate.TenantQuota
}

var _ ent.Mutation = (*TenantQuotaMutation)(nil)

// tenantquotaOption allows management of the mutation configuration using functional options.
type tenantquotaOption func(*TenantQuotaMutation)

// newTenantQuotaMutation creates new mutation for the TenantQuota entity.
func newTenantQuotaMutation(c config, op Op, opts ...tenantquotaOption) *TenantQuotaMutation {
	m := &TenantQuotaMutation{
		config:        c,
		op:            op,
		typ:           TypeTenantQuota,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantQuotaID sets the ID field of the mutation.
func withTenantQuotaID(id string) tenantquotaOption {
	return func(m *TenantQuotaMutation) {
		var (
			err   error
			once  sync.Once
			value *TenantQuota
		)
		m.oldValue = func(ctx context.Context) (*TenantQuota, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TenantQuota.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenantQuota sets the old TenantQuota of the mutation.
func withTenantQuota(node *TenantQuota) tenantquotaOption {
	return func(m *TenantQuotaMutation) {
		m.oldValue = func(context.Context) (*TenantQuota, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantQuotaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantQuotaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TenantQuota entities.
func (m *TenantQuotaMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantQuotaMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantQuotaMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TenantQuota.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TenantQuotaMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TenantQuotaMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *TenantQuotaMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[tenantquota.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *TenantQuotaMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[tenantquota.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TenantQuotaMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, tenantquota.FieldTenantID)
}

// SetDescription sets the "description" field.
func (m *TenantQuotaMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TenantQuotaMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TenantQuotaMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tenantquota.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TenantQuotaMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tenantquota.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TenantQuotaMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tenantquota.FieldDescription)
}

// SetExtras sets the "extras" field.
func (m *TenantQuotaMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *TenantQuotaMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *TenantQuotaMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[tenantquota.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *TenantQuotaMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[tenantquota.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *TenantQuotaMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, tenantquota.FieldExtras)
}

// SetCreatedBy sets the "created_by" field.
func (m *TenantQuotaMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TenantQuotaMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TenantQuotaMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[tenantquota.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TenantQuotaMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[tenantquota.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TenantQuotaMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, tenantquota.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TenantQuotaMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TenantQuotaMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TenantQuotaMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[tenantquota.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TenantQuotaMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[tenantquota.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TenantQuotaMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, tenantquota.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantQuotaMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantQuotaMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TenantQuotaMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TenantQuotaMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TenantQuotaMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[tenantquota.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TenantQuotaMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tenantquota.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantQuotaMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, tenantquota.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantQuotaMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantQuotaMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TenantQuotaMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TenantQuotaMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TenantQuotaMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[tenantquota.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TenantQuotaMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tenantquota.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantQuotaMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, tenantquota.FieldUpdatedAt)
}

// SetQuotaType sets the "quota_type" field.
func (m *TenantQuotaMutation) SetQuotaType(s string) {
	m.quota_type = &s
}

// QuotaType returns the value of the "quota_type" field in the mutation.
func (m *TenantQuotaMutation) QuotaType() (r string, exists bool) {
	v := m.quota_type
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaType returns the old "quota_type" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldQuotaType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotaType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotaType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaType: %w", err)
	}
	return oldValue.QuotaType, nil
}

// ResetQuotaType resets all changes to the "quota_type" field.
func (m *TenantQuotaMutation) ResetQuotaType() {
	m.quota_type = nil
}

// SetQuotaName sets the "quota_name" field.
func (m *TenantQuotaMutation) SetQuotaName(s string) {
	m.quota_name = &s
}

// QuotaName returns the value of the "quota_name" field in the mutation.
func (m *TenantQuotaMutation) QuotaName() (r string, exists bool) {
	v := m.quota_name
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaName returns the old "quota_name" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldQuotaName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotaName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotaName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaName: %w", err)
	}
	return oldValue.QuotaName, nil
}

// ResetQuotaName resets all changes to the "quota_name" field.
func (m *TenantQuotaMutation) ResetQuotaName() {
	m.quota_name = nil
}

// SetMaxValue sets the "max_value" field.
func (m *TenantQuotaMutation) SetMaxValue(i int64) {
	m.max_value = &i
	m.addmax_value = nil
}

// MaxValue returns the value of the "max_value" field in the mutation.
func (m *TenantQuotaMutation) MaxValue() (r int64, exists bool) {
	v := m.max_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxValue returns the old "max_value" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldMaxValue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxValue: %w", err)
	}
	return oldValue.MaxValue, nil
}

// AddMaxValue adds i to the "max_value" field.
func (m *TenantQuotaMutation) AddMaxValue(i int64) {
	if m.addmax_value != nil {
		*m.addmax_value += i
	} else {
		m.addmax_value = &i
	}
}

// AddedMaxValue returns the value that was added to the "max_value" field in this mutation.
func (m *TenantQuotaMutation) AddedMaxValue() (r int64, exists bool) {
	v := m.addmax_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxValue resets all changes to the "max_value" field.
func (m *TenantQuotaMutation) ResetMaxValue() {
	m.max_value = nil
	m.addmax_value = nil
}

// SetCurrentUsed sets the "current_used" field.
func (m *TenantQuotaMutation) SetCurrentUsed(i int64) {
	m.current_used = &i
	m.addcurrent_used = nil
}

// CurrentUsed returns the value of the "current_used" field in the mutation.
func (m *TenantQuotaMutation) CurrentUsed() (r int64, exists bool) {
	v := m.current_used
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentUsed returns the old "current_used" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldCurrentUsed(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentUsed: %w", err)
	}
	return oldValue.CurrentUsed, nil
}

// AddCurrentUsed adds i to the "current_used" field.
func (m *TenantQuotaMutation) AddCurrentUsed(i int64) {
	if m.addcurrent_used != nil {
		*m.addcurrent_used += i
	} else {
		m.addcurrent_used = &i
	}
}

// AddedCurrentUsed returns the value that was added to the "current_used" field in this mutation.
func (m *TenantQuotaMutation) AddedCurrentUsed() (r int64, exists bool) {
	v := m.addcurrent_used
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentUsed resets all changes to the "current_used" field.
func (m *TenantQuotaMutation) ResetCurrentUsed() {
	m.current_used = nil
	m.addcurrent_used = nil
}

// SetUnit sets the "unit" field.
func (m *TenantQuotaMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *TenantQuotaMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *TenantQuotaMutation) ResetUnit() {
	m.unit = nil
}

// SetEnabled sets the "enabled" field.
func (m *TenantQuotaMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *TenantQuotaMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the TenantQuota entity.
// If the TenantQuota object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantQuotaMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *TenantQuotaMutation) ResetEnabled() {
	m.enabled = nil
}

// Where appends a list predicates to the TenantQuotaMutation builder.
func (m *TenantQuotaMutation) Where(ps ...predicate.TenantQuota) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantQuotaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantQuotaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TenantQuota, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantQuotaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantQuotaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TenantQuota).
func (m *TenantQuotaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantQuotaMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.tenant_id != nil {
		fields = append(fields, tenantquota.FieldTenantID)
	}
	if m.description != nil {
		fields = append(fields, tenantquota.FieldDescription)
	}
	if m.extras != nil {
		fields = append(fields, tenantquota.FieldExtras)
	}
	if m.created_by != nil {
		fields = append(fields, tenantquota.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, tenantquota.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, tenantquota.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenantquota.FieldUpdatedAt)
	}
	if m.quota_type != nil {
		fields = append(fields, tenantquota.FieldQuotaType)
	}
	if m.quota_name != nil {
		fields = append(fields, tenantquota.FieldQuotaName)
	}
	if m.max_value != nil {
		fields = append(fields, tenantquota.FieldMaxValue)
	}
	if m.current_used != nil {
		fields = append(fields, tenantquota.FieldCurrentUsed)
	}
	if m.unit != nil {
		fields = append(fields, tenantquota.FieldUnit)
	}
	if m.enabled != nil {
		fields = append(fields, tenantquota.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantQuotaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenantquota.FieldTenantID:
		return m.TenantID()
	case tenantquota.FieldDescription:
		return m.Description()
	case tenantquota.FieldExtras:
		return m.Extras()
	case tenantquota.FieldCreatedBy:
		return m.CreatedBy()
	case tenantquota.FieldUpdatedBy:
		return m.UpdatedBy()
	case tenantquota.FieldCreatedAt:
		return m.CreatedAt()
	case tenantquota.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenantquota.FieldQuotaType:
		return m.QuotaType()
	case tenantquota.FieldQuotaName:
		return m.QuotaName()
	case tenantquota.FieldMaxValue:
		return m.MaxValue()
	case tenantquota.FieldCurrentUsed:
		return m.CurrentUsed()
	case tenantquota.FieldUnit:
		return m.Unit()
	case tenantquota.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantQuotaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenantquota.FieldTenantID:
		return m.OldTenantID(ctx)
	case tenantquota.FieldDescription:
		return m.OldDescription(ctx)
	case tenantquota.FieldExtras:
		return m.OldExtras(ctx)
	case tenantquota.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tenantquota.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case tenantquota.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenantquota.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenantquota.FieldQuotaType:
		return m.OldQuotaType(ctx)
	case tenantquota.FieldQuotaName:
		return m.OldQuotaName(ctx)
	case tenantquota.FieldMaxValue:
		return m.OldMaxValue(ctx)
	case tenantquota.FieldCurrentUsed:
		return m.OldCurrentUsed(ctx)
	case tenantquota.FieldUnit:
		return m.OldUnit(ctx)
	case tenantquota.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown TenantQuota field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantQuotaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenantquota.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tenantquota.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tenantquota.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case tenantquota.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tenantquota.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case tenantquota.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenantquota.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenantquota.FieldQuotaType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaType(v)
		return nil
	case tenantquota.FieldQuotaName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaName(v)
		return nil
	case tenantquota.FieldMaxValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxValue(v)
		return nil
	case tenantquota.FieldCurrentUsed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentUsed(v)
		return nil
	case tenantquota.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case tenantquota.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown TenantQuota field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantQuotaMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, tenantquota.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, tenantquota.FieldUpdatedAt)
	}
	if m.addmax_value != nil {
		fields = append(fields, tenantquota.FieldMaxValue)
	}
	if m.addcurrent_used != nil {
		fields = append(fields, tenantquota.FieldCurrentUsed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantQuotaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenantquota.FieldCreatedAt:
		return m.AddedCreatedAt()
	case tenantquota.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case tenantquota.FieldMaxValue:
		return m.AddedMaxValue()
	case tenantquota.FieldCurrentUsed:
		return m.AddedCurrentUsed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantQuotaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenantquota.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case tenantquota.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case tenantquota.FieldMaxValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxValue(v)
		return nil
	case tenantquota.FieldCurrentUsed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentUsed(v)
		return nil
	}
	return fmt.Errorf("unknown TenantQuota numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantQuotaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenantquota.FieldTenantID) {
		fields = append(fields, tenantquota.FieldTenantID)
	}
	if m.FieldCleared(tenantquota.FieldDescription) {
		fields = append(fields, tenantquota.FieldDescription)
	}
	if m.FieldCleared(tenantquota.FieldExtras) {
		fields = append(fields, tenantquota.FieldExtras)
	}
	if m.FieldCleared(tenantquota.FieldCreatedBy) {
		fields = append(fields, tenantquota.FieldCreatedBy)
	}
	if m.FieldCleared(tenantquota.FieldUpdatedBy) {
		fields = append(fields, tenantquota.FieldUpdatedBy)
	}
	if m.FieldCleared(tenantquota.FieldCreatedAt) {
		fields = append(fields, tenantquota.FieldCreatedAt)
	}
	if m.FieldCleared(tenantquota.FieldUpdatedAt) {
		fields = append(fields, tenantquota.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantQuotaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantQuotaMutation) ClearField(name string) error {
	switch name {
	case tenantquota.FieldTenantID:
		m.ClearTenantID()
		return nil
	case tenantquota.FieldDescription:
		m.ClearDescription()
		return nil
	case tenantquota.FieldExtras:
		m.ClearExtras()
		return nil
	case tenantquota.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tenantquota.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case tenantquota.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tenantquota.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TenantQuota nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantQuotaMutation) ResetField(name string) error {
	switch name {
	case tenantquota.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tenantquota.FieldDescription:
		m.ResetDescription()
		return nil
	case tenantquota.FieldExtras:
		m.ResetExtras()
		return nil
	case tenantquota.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tenantquota.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case tenantquota.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenantquota.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenantquota.FieldQuotaType:
		m.ResetQuotaType()
		return nil
	case tenantquota.FieldQuotaName:
		m.ResetQuotaName()
		return nil
	case tenantquota.FieldMaxValue:
		m.ResetMaxValue()
		return nil
	case tenantquota.FieldCurrentUsed:
		m.ResetCurrentUsed()
		return nil
	case tenantquota.FieldUnit:
		m.ResetUnit()
		return nil
	case tenantquota.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown TenantQuota field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantQuotaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantQuotaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantQuotaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantQuotaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantQuotaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantQuotaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantQuotaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TenantQuota unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantQuotaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TenantQuota edge %s", name)
}

// TenantSettingMutation represents an operation that mutates the TenantSetting nodes in the graph.
type TenantSettingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	tenant_id     *string
	description   *string
	extras        *map[string]interface{}
	created_by    *string
	updated_by    *string
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	setting_key   *string
	setting_name  *string
	setting_value *string
	default_value *string
	setting_type  *string
	scope         *string
	category      *string
	is_public     *bool
	is_required   *bool
	is_readonly   *bool
	validation    *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TenantSetting, error)
	predicates    []predicate.TenantSetting
}

var _ ent.Mutation = (*TenantSettingMutation)(nil)

// tenantsettingOption allows management of the mutation configuration using functional options.
type tenantsettingOption func(*TenantSettingMutation)

// newTenantSettingMutation creates new mutation for the TenantSetting entity.
func newTenantSettingMutation(c config, op Op, opts ...tenantsettingOption) *TenantSettingMutation {
	m := &TenantSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeTenantSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantSettingID sets the ID field of the mutation.
func withTenantSettingID(id string) tenantsettingOption {
	return func(m *TenantSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *TenantSetting
		)
		m.oldValue = func(ctx context.Context) (*TenantSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TenantSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenantSetting sets the old TenantSetting of the mutation.
func withTenantSetting(node *TenantSetting) tenantsettingOption {
	return func(m *TenantSettingMutation) {
		m.oldValue = func(context.Context) (*TenantSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TenantSetting entities.
func (m *TenantSettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantSettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantSettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TenantSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TenantSettingMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TenantSettingMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *TenantSettingMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[tenantsetting.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *TenantSettingMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[tenantsetting.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TenantSettingMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, tenantsetting.FieldTenantID)
}

// SetDescription sets the "description" field.
func (m *TenantSettingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TenantSettingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TenantSettingMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tenantsetting.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TenantSettingMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tenantsetting.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TenantSettingMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tenantsetting.FieldDescription)
}

// SetExtras sets the "extras" field.
func (m *TenantSettingMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *TenantSettingMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *TenantSettingMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[tenantsetting.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *TenantSettingMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[tenantsetting.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *TenantSettingMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, tenantsetting.FieldExtras)
}

// SetCreatedBy sets the "created_by" field.
func (m *TenantSettingMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TenantSettingMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TenantSettingMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[tenantsetting.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TenantSettingMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[tenantsetting.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TenantSettingMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, tenantsetting.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TenantSettingMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TenantSettingMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TenantSettingMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[tenantsetting.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TenantSettingMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[tenantsetting.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TenantSettingMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, tenantsetting.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantSettingMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantSettingMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TenantSettingMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TenantSettingMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TenantSettingMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[tenantsetting.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TenantSettingMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tenantsetting.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantSettingMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, tenantsetting.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantSettingMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantSettingMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TenantSettingMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TenantSettingMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TenantSettingMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[tenantsetting.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TenantSettingMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tenantsetting.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, tenantsetting.FieldUpdatedAt)
}

// SetSettingKey sets the "setting_key" field.
func (m *TenantSettingMutation) SetSettingKey(s string) {
	m.setting_key = &s
}

// SettingKey returns the value of the "setting_key" field in the mutation.
func (m *TenantSettingMutation) SettingKey() (r string, exists bool) {
	v := m.setting_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingKey returns the old "setting_key" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldSettingKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingKey: %w", err)
	}
	return oldValue.SettingKey, nil
}

// ResetSettingKey resets all changes to the "setting_key" field.
func (m *TenantSettingMutation) ResetSettingKey() {
	m.setting_key = nil
}

// SetSettingName sets the "setting_name" field.
func (m *TenantSettingMutation) SetSettingName(s string) {
	m.setting_name = &s
}

// SettingName returns the value of the "setting_name" field in the mutation.
func (m *TenantSettingMutation) SettingName() (r string, exists bool) {
	v := m.setting_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingName returns the old "setting_name" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldSettingName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingName: %w", err)
	}
	return oldValue.SettingName, nil
}

// ResetSettingName resets all changes to the "setting_name" field.
func (m *TenantSettingMutation) ResetSettingName() {
	m.setting_name = nil
}

// SetSettingValue sets the "setting_value" field.
func (m *TenantSettingMutation) SetSettingValue(s string) {
	m.setting_value = &s
}

// SettingValue returns the value of the "setting_value" field in the mutation.
func (m *TenantSettingMutation) SettingValue() (r string, exists bool) {
	v := m.setting_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingValue returns the old "setting_value" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldSettingValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingValue: %w", err)
	}
	return oldValue.SettingValue, nil
}

// ClearSettingValue clears the value of the "setting_value" field.
func (m *TenantSettingMutation) ClearSettingValue() {
	m.setting_value = nil
	m.clearedFields[tenantsetting.FieldSettingValue] = struct{}{}
}

// SettingValueCleared returns if the "setting_value" field was cleared in this mutation.
func (m *TenantSettingMutation) SettingValueCleared() bool {
	_, ok := m.clearedFields[tenantsetting.FieldSettingValue]
	return ok
}

// ResetSettingValue resets all changes to the "setting_value" field.
func (m *TenantSettingMutation) ResetSettingValue() {
	m.setting_value = nil
	delete(m.clearedFields, tenantsetting.FieldSettingValue)
}

// SetDefaultValue sets the "default_value" field.
func (m *TenantSettingMutation) SetDefaultValue(s string) {
	m.default_value = &s
}

// DefaultValue returns the value of the "default_value" field in the mutation.
func (m *TenantSettingMutation) DefaultValue() (r string, exists bool) {
	v := m.default_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultValue returns the old "default_value" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldDefaultValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultValue: %w", err)
	}
	return oldValue.DefaultValue, nil
}

// ClearDefaultValue clears the value of the "default_value" field.
func (m *TenantSettingMutation) ClearDefaultValue() {
	m.default_value = nil
	m.clearedFields[tenantsetting.FieldDefaultValue] = struct{}{}
}

// DefaultValueCleared returns if the "default_value" field was cleared in this mutation.
func (m *TenantSettingMutation) DefaultValueCleared() bool {
	_, ok := m.clearedFields[tenantsetting.FieldDefaultValue]
	return ok
}

// ResetDefaultValue resets all changes to the "default_value" field.
func (m *TenantSettingMutation) ResetDefaultValue() {
	m.default_value = nil
	delete(m.clearedFields, tenantsetting.FieldDefaultValue)
}

// SetSettingType sets the "setting_type" field.
func (m *TenantSettingMutation) SetSettingType(s string) {
	m.setting_type = &s
}

// SettingType returns the value of the "setting_type" field in the mutation.
func (m *TenantSettingMutation) SettingType() (r string, exists bool) {
	v := m.setting_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingType returns the old "setting_type" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldSettingType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingType: %w", err)
	}
	return oldValue.SettingType, nil
}

// ResetSettingType resets all changes to the "setting_type" field.
func (m *TenantSettingMutation) ResetSettingType() {
	m.setting_type = nil
}

// SetScope sets the "scope" field.
func (m *TenantSettingMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *TenantSettingMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *TenantSettingMutation) ResetScope() {
	m.scope = nil
}

// SetCategory sets the "category" field.
func (m *TenantSettingMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *TenantSettingMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TenantSettingMutation) ResetCategory() {
	m.category = nil
}

// SetIsPublic sets the "is_public" field.
func (m *TenantSettingMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *TenantSettingMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *TenantSettingMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetIsRequired sets the "is_required" field.
func (m *TenantSettingMutation) SetIsRequired(b bool) {
	m.is_required = &b
}

// IsRequired returns the value of the "is_required" field in the mutation.
func (m *TenantSettingMutation) IsRequired() (r bool, exists bool) {
	v := m.is_required
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequired returns the old "is_required" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldIsRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequired: %w", err)
	}
	return oldValue.IsRequired, nil
}

// ResetIsRequired resets all changes to the "is_required" field.
func (m *TenantSettingMutation) ResetIsRequired() {
	m.is_required = nil
}

// SetIsReadonly sets the "is_readonly" field.
func (m *TenantSettingMutation) SetIsReadonly(b bool) {
	m.is_readonly = &b
}

// IsReadonly returns the value of the "is_readonly" field in the mutation.
func (m *TenantSettingMutation) IsReadonly() (r bool, exists bool) {
	v := m.is_readonly
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReadonly returns the old "is_readonly" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldIsReadonly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReadonly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReadonly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReadonly: %w", err)
	}
	return oldValue.IsReadonly, nil
}

// ResetIsReadonly resets all changes to the "is_readonly" field.
func (m *TenantSettingMutation) ResetIsReadonly() {
	m.is_readonly = nil
}

// SetValidation sets the "validation" field.
func (m *TenantSettingMutation) SetValidation(value map[string]interface{}) {
	m.validation = &value
}

// Validation returns the value of the "validation" field in the mutation.
func (m *TenantSettingMutation) Validation() (r map[string]interface{}, exists bool) {
	v := m.validation
	if v == nil {
		return
	}
	return *v, true
}

// OldValidation returns the old "validation" field's value of the TenantSetting entity.
// If the TenantSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantSettingMutation) OldValidation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidation: %w", err)
	}
	return oldValue.Validation, nil
}

// ClearValidation clears the value of the "validation" field.
func (m *TenantSettingMutation) ClearValidation() {
	m.validation = nil
	m.clearedFields[tenantsetting.FieldValidation] = struct{}{}
}

// ValidationCleared returns if the "validation" field was cleared in this mutation.
func (m *TenantSettingMutation) ValidationCleared() bool {
	_, ok := m.clearedFields[tenantsetting.FieldValidation]
	return ok
}

// ResetValidation resets all changes to the "validation" field.
func (m *TenantSettingMutation) ResetValidation() {
	m.validation = nil
	delete(m.clearedFields, tenantsetting.FieldValidation)
}

// Where appends a list predicates to the TenantSettingMutation builder.
func (m *TenantSettingMutation) Where(ps ...predicate.TenantSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TenantSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TenantSetting).
func (m *TenantSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantSettingMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.tenant_id != nil {
		fields = append(fields, tenantsetting.FieldTenantID)
	}
	if m.description != nil {
		fields = append(fields, tenantsetting.FieldDescription)
	}
	if m.extras != nil {
		fields = append(fields, tenantsetting.FieldExtras)
	}
	if m.created_by != nil {
		fields = append(fields, tenantsetting.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, tenantsetting.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, tenantsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenantsetting.FieldUpdatedAt)
	}
	if m.setting_key != nil {
		fields = append(fields, tenantsetting.FieldSettingKey)
	}
	if m.setting_name != nil {
		fields = append(fields, tenantsetting.FieldSettingName)
	}
	if m.setting_value != nil {
		fields = append(fields, tenantsetting.FieldSettingValue)
	}
	if m.default_value != nil {
		fields = append(fields, tenantsetting.FieldDefaultValue)
	}
	if m.setting_type != nil {
		fields = append(fields, tenantsetting.FieldSettingType)
	}
	if m.scope != nil {
		fields = append(fields, tenantsetting.FieldScope)
	}
	if m.category != nil {
		fields = append(fields, tenantsetting.FieldCategory)
	}
	if m.is_public != nil {
		fields = append(fields, tenantsetting.FieldIsPublic)
	}
	if m.is_required != nil {
		fields = append(fields, tenantsetting.FieldIsRequired)
	}
	if m.is_readonly != nil {
		fields = append(fields, tenantsetting.FieldIsReadonly)
	}
	if m.validation != nil {
		fields = append(fields, tenantsetting.FieldValidation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenantsetting.FieldTenantID:
		return m.TenantID()
	case tenantsetting.FieldDescription:
		return m.Description()
	case tenantsetting.FieldExtras:
		return m.Extras()
	case tenantsetting.FieldCreatedBy:
		return m.CreatedBy()
	case tenantsetting.FieldUpdatedBy:
		return m.UpdatedBy()
	case tenantsetting.FieldCreatedAt:
		return m.CreatedAt()
	case tenantsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenantsetting.FieldSettingKey:
		return m.SettingKey()
	case tenantsetting.FieldSettingName:
		return m.SettingName()
	case tenantsetting.FieldSettingValue:
		return m.SettingValue()
	case tenantsetting.FieldDefaultValue:
		return m.DefaultValue()
	case tenantsetting.FieldSettingType:
		return m.SettingType()
	case tenantsetting.FieldScope:
		return m.Scope()
	case tenantsetting.FieldCategory:
		return m.Category()
	case tenantsetting.FieldIsPublic:
		return m.IsPublic()
	case tenantsetting.FieldIsRequired:
		return m.IsRequired()
	case tenantsetting.FieldIsReadonly:
		return m.IsReadonly()
	case tenantsetting.FieldValidation:
		return m.Validation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenantsetting.FieldTenantID:
		return m.OldTenantID(ctx)
	case tenantsetting.FieldDescription:
		return m.OldDescription(ctx)
	case tenantsetting.FieldExtras:
		return m.OldExtras(ctx)
	case tenantsetting.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tenantsetting.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case tenantsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenantsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenantsetting.FieldSettingKey:
		return m.OldSettingKey(ctx)
	case tenantsetting.FieldSettingName:
		return m.OldSettingName(ctx)
	case tenantsetting.FieldSettingValue:
		return m.OldSettingValue(ctx)
	case tenantsetting.FieldDefaultValue:
		return m.OldDefaultValue(ctx)
	case tenantsetting.FieldSettingType:
		return m.OldSettingType(ctx)
	case tenantsetting.FieldScope:
		return m.OldScope(ctx)
	case tenantsetting.FieldCategory:
		return m.OldCategory(ctx)
	case tenantsetting.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case tenantsetting.FieldIsRequired:
		return m.OldIsRequired(ctx)
	case tenantsetting.FieldIsReadonly:
		return m.OldIsReadonly(ctx)
	case tenantsetting.FieldValidation:
		return m.OldValidation(ctx)
	}
	return nil, fmt.Errorf("unknown TenantSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenantsetting.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tenantsetting.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tenantsetting.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case tenantsetting.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tenantsetting.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case tenantsetting.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenantsetting.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenantsetting.FieldSettingKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingKey(v)
		return nil
	case tenantsetting.FieldSettingName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingName(v)
		return nil
	case tenantsetting.FieldSettingValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingValue(v)
		return nil
	case tenantsetting.FieldDefaultValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultValue(v)
		return nil
	case tenantsetting.FieldSettingType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingType(v)
		return nil
	case tenantsetting.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case tenantsetting.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case tenantsetting.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case tenantsetting.FieldIsRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequired(v)
		return nil
	case tenantsetting.FieldIsReadonly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReadonly(v)
		return nil
	case tenantsetting.FieldValidation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidation(v)
		return nil
	}
	return fmt.Errorf("unknown TenantSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantSettingMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, tenantsetting.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, tenantsetting.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenantsetting.FieldCreatedAt:
		return m.AddedCreatedAt()
	case tenantsetting.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenantsetting.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case tenantsetting.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TenantSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenantsetting.FieldTenantID) {
		fields = append(fields, tenantsetting.FieldTenantID)
	}
	if m.FieldCleared(tenantsetting.FieldDescription) {
		fields = append(fields, tenantsetting.FieldDescription)
	}
	if m.FieldCleared(tenantsetting.FieldExtras) {
		fields = append(fields, tenantsetting.FieldExtras)
	}
	if m.FieldCleared(tenantsetting.FieldCreatedBy) {
		fields = append(fields, tenantsetting.FieldCreatedBy)
	}
	if m.FieldCleared(tenantsetting.FieldUpdatedBy) {
		fields = append(fields, tenantsetting.FieldUpdatedBy)
	}
	if m.FieldCleared(tenantsetting.FieldCreatedAt) {
		fields = append(fields, tenantsetting.FieldCreatedAt)
	}
	if m.FieldCleared(tenantsetting.FieldUpdatedAt) {
		fields = append(fields, tenantsetting.FieldUpdatedAt)
	}
	if m.FieldCleared(tenantsetting.FieldSettingValue) {
		fields = append(fields, tenantsetting.FieldSettingValue)
	}
	if m.FieldCleared(tenantsetting.FieldDefaultValue) {
		fields = append(fields, tenantsetting.FieldDefaultValue)
	}
	if m.FieldCleared(tenantsetting.FieldValidation) {
		fields = append(fields, tenantsetting.FieldValidation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantSettingMutation) ClearField(name string) error {
	switch name {
	case tenantsetting.FieldTenantID:
		m.ClearTenantID()
		return nil
	case tenantsetting.FieldDescription:
		m.ClearDescription()
		return nil
	case tenantsetting.FieldExtras:
		m.ClearExtras()
		return nil
	case tenantsetting.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tenantsetting.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case tenantsetting.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tenantsetting.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tenantsetting.FieldSettingValue:
		m.ClearSettingValue()
		return nil
	case tenantsetting.FieldDefaultValue:
		m.ClearDefaultValue()
		return nil
	case tenantsetting.FieldValidation:
		m.ClearValidation()
		return nil
	}
	return fmt.Errorf("unknown TenantSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantSettingMutation) ResetField(name string) error {
	switch name {
	case tenantsetting.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tenantsetting.FieldDescription:
		m.ResetDescription()
		return nil
	case tenantsetting.FieldExtras:
		m.ResetExtras()
		return nil
	case tenantsetting.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tenantsetting.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case tenantsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenantsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenantsetting.FieldSettingKey:
		m.ResetSettingKey()
		return nil
	case tenantsetting.FieldSettingName:
		m.ResetSettingName()
		return nil
	case tenantsetting.FieldSettingValue:
		m.ResetSettingValue()
		return nil
	case tenantsetting.FieldDefaultValue:
		m.ResetDefaultValue()
		return nil
	case tenantsetting.FieldSettingType:
		m.ResetSettingType()
		return nil
	case tenantsetting.FieldScope:
		m.ResetScope()
		return nil
	case tenantsetting.FieldCategory:
		m.ResetCategory()
		return nil
	case tenantsetting.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case tenantsetting.FieldIsRequired:
		m.ResetIsRequired()
		return nil
	case tenantsetting.FieldIsReadonly:
		m.ResetIsReadonly()
		return nil
	case tenantsetting.FieldValidation:
		m.ResetValidation()
		return nil
	}
	return fmt.Errorf("unknown TenantSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantSettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantSettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantSettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TenantSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantSettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TenantSetting edge %s", name)
}

// UserTenantMutation represents an operation that mutates the UserTenant nodes in the graph.
type UserTenantMutation struct {
	config
	op            Op
	typ           string
	id            *string
	user_id       *string
	tenant_id     *string
	created_by    *string
	updated_by    *string
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserTenant, error)
	predicates    []predicate.UserTenant
}

var _ ent.Mutation = (*UserTenantMutation)(nil)

// usertenantOption allows management of the mutation configuration using functional options.
type usertenantOption func(*UserTenantMutation)

// newUserTenantMutation creates new mutation for the UserTenant entity.
func newUserTenantMutation(c config, op Op, opts ...usertenantOption) *UserTenantMutation {
	m := &UserTenantMutation{
		config:        c,
		op:            op,
		typ:           TypeUserTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserTenantID sets the ID field of the mutation.
func withUserTenantID(id string) usertenantOption {
	return func(m *UserTenantMutation) {
		var (
			err   error
			once  sync.Once
			value *UserTenant
		)
		m.oldValue = func(ctx context.Context) (*UserTenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserTenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserTenant sets the old UserTenant of the mutation.
func withUserTenant(node *UserTenant) usertenantOption {
	return func(m *UserTenantMutation) {
		m.oldValue = func(context.Context) (*UserTenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserTenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserTenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserTenant entities.
func (m *UserTenantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserTenantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserTenantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserTenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserTenantMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserTenantMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserTenant entity.
// If the UserTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserTenantMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[usertenant.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserTenantMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usertenant.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserTenantMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, usertenant.FieldUserID)
}

// SetTenantID sets the "tenant_id" field.
func (m *UserTenantMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserTenantMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the UserTenant entity.
// If the UserTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *UserTenantMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[usertenant.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *UserTenantMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[usertenant.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserTenantMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, usertenant.FieldTenantID)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserTenantMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserTenantMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserTenant entity.
// If the UserTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserTenantMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[usertenant.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserTenantMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[usertenant.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserTenantMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, usertenant.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserTenantMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserTenantMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserTenant entity.
// If the UserTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserTenantMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[usertenant.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserTenantMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[usertenant.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserTenantMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, usertenant.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserTenantMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserTenantMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserTenant entity.
// If the UserTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *UserTenantMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserTenantMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserTenantMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[usertenant.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserTenantMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usertenant.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserTenantMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, usertenant.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserTenantMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserTenantMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserTenant entity.
// If the UserTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *UserTenantMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserTenantMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserTenantMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[usertenant.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserTenantMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[usertenant.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserTenantMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, usertenant.FieldUpdatedAt)
}

// Where appends a list predicates to the UserTenantMutation builder.
func (m *UserTenantMutation) Where(ps ...predicate.UserTenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserTenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserTenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserTenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserTenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserTenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserTenant).
func (m *UserTenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserTenantMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_id != nil {
		fields = append(fields, usertenant.FieldUserID)
	}
	if m.tenant_id != nil {
		fields = append(fields, usertenant.FieldTenantID)
	}
	if m.created_by != nil {
		fields = append(fields, usertenant.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, usertenant.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, usertenant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usertenant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserTenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usertenant.FieldUserID:
		return m.UserID()
	case usertenant.FieldTenantID:
		return m.TenantID()
	case usertenant.FieldCreatedBy:
		return m.CreatedBy()
	case usertenant.FieldUpdatedBy:
		return m.UpdatedBy()
	case usertenant.FieldCreatedAt:
		return m.CreatedAt()
	case usertenant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserTenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usertenant.FieldUserID:
		return m.OldUserID(ctx)
	case usertenant.FieldTenantID:
		return m.OldTenantID(ctx)
	case usertenant.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case usertenant.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case usertenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usertenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserTenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usertenant.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usertenant.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case usertenant.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case usertenant.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case usertenant.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usertenant.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserTenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserTenantMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, usertenant.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, usertenant.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserTenantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usertenant.FieldCreatedAt:
		return m.AddedCreatedAt()
	case usertenant.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usertenant.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case usertenant.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserTenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserTenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usertenant.FieldUserID) {
		fields = append(fields, usertenant.FieldUserID)
	}
	if m.FieldCleared(usertenant.FieldTenantID) {
		fields = append(fields, usertenant.FieldTenantID)
	}
	if m.FieldCleared(usertenant.FieldCreatedBy) {
		fields = append(fields, usertenant.FieldCreatedBy)
	}
	if m.FieldCleared(usertenant.FieldUpdatedBy) {
		fields = append(fields, usertenant.FieldUpdatedBy)
	}
	if m.FieldCleared(usertenant.FieldCreatedAt) {
		fields = append(fields, usertenant.FieldCreatedAt)
	}
	if m.FieldCleared(usertenant.FieldUpdatedAt) {
		fields = append(fields, usertenant.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserTenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserTenantMutation) ClearField(name string) error {
	switch name {
	case usertenant.FieldUserID:
		m.ClearUserID()
		return nil
	case usertenant.FieldTenantID:
		m.ClearTenantID()
		return nil
	case usertenant.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case usertenant.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case usertenant.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usertenant.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserTenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserTenantMutation) ResetField(name string) error {
	switch name {
	case usertenant.FieldUserID:
		m.ResetUserID()
		return nil
	case usertenant.FieldTenantID:
		m.ResetTenantID()
		return nil
	case usertenant.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case usertenant.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case usertenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usertenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserTenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserTenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserTenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserTenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserTenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserTenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserTenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserTenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserTenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserTenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserTenant edge %s", name)
}

// UserTenantRoleMutation represents an operation that mutates the UserTenantRole nodes in the graph.
type UserTenantRoleMutation struct {
	config
	op            Op
	typ           string
	id            *string
	user_id       *string
	tenant_id     *string
	role_id       *string
	created_by    *string
	updated_by    *string
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserTenantRole, error)
	predicates    []predicate.UserTenantRole
}

var _ ent.Mutation = (*UserTenantRoleMutation)(nil)

// usertenantroleOption allows management of the mutation configuration using functional options.
type usertenantroleOption func(*UserTenantRoleMutation)

// newUserTenantRoleMutation creates new mutation for the UserTenantRole entity.
func newUserTenantRoleMutation(c config, op Op, opts ...usertenantroleOption) *UserTenantRoleMutation {
	m := &UserTenantRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserTenantRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserTenantRoleID sets the ID field of the mutation.
func withUserTenantRoleID(id string) usertenantroleOption {
	return func(m *UserTenantRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserTenantRole
		)
		m.oldValue = func(ctx context.Context) (*UserTenantRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserTenantRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserTenantRole sets the old UserTenantRole of the mutation.
func withUserTenantRole(node *UserTenantRole) usertenantroleOption {
	return func(m *UserTenantRoleMutation) {
		m.oldValue = func(context.Context) (*UserTenantRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserTenantRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserTenantRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserTenantRole entities.
func (m *UserTenantRoleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserTenantRoleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserTenantRoleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserTenantRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserTenantRoleMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserTenantRoleMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserTenantRole entity.
// If the UserTenantRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantRoleMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserTenantRoleMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[usertenantrole.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserTenantRoleMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usertenantrole.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserTenantRoleMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, usertenantrole.FieldUserID)
}

// SetTenantID sets the "tenant_id" field.
func (m *UserTenantRoleMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserTenantRoleMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the UserTenantRole entity.
// If the UserTenantRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantRoleMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *UserTenantRoleMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[usertenantrole.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *UserTenantRoleMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[usertenantrole.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserTenantRoleMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, usertenantrole.FieldTenantID)
}

// SetRoleID sets the "role_id" field.
func (m *UserTenantRoleMutation) SetRoleID(s string) {
	m.role_id = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserTenantRoleMutation) RoleID() (r string, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserTenantRole entity.
// If the UserTenantRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantRoleMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *UserTenantRoleMutation) ClearRoleID() {
	m.role_id = nil
	m.clearedFields[usertenantrole.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *UserTenantRoleMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[usertenantrole.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserTenantRoleMutation) ResetRoleID() {
	m.role_id = nil
	delete(m.clearedFields, usertenantrole.FieldRoleID)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserTenantRoleMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserTenantRoleMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserTenantRole entity.
// If the UserTenantRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantRoleMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserTenantRoleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[usertenantrole.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserTenantRoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[usertenantrole.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserTenantRoleMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, usertenantrole.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserTenantRoleMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserTenantRoleMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserTenantRole entity.
// If the UserTenantRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantRoleMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserTenantRoleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[usertenantrole.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserTenantRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[usertenantrole.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserTenantRoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, usertenantrole.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserTenantRoleMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserTenantRoleMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserTenantRole entity.
// If the UserTenantRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantRoleMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *UserTenantRoleMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *UserTenantRoleMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserTenantRoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[usertenantrole.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserTenantRoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usertenantrole.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserTenantRoleMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, usertenantrole.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserTenantRoleMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserTenantRoleMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserTenantRole entity.
// If the UserTenantRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTenantRoleMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *UserTenantRoleMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *UserTenantRoleMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserTenantRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[usertenantrole.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserTenantRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[usertenantrole.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserTenantRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, usertenantrole.FieldUpdatedAt)
}

// Where appends a list predicates to the UserTenantRoleMutation builder.
func (m *UserTenantRoleMutation) Where(ps ...predicate.UserTenantRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserTenantRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserTenantRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserTenantRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserTenantRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserTenantRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserTenantRole).
func (m *UserTenantRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserTenantRoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user_id != nil {
		fields = append(fields, usertenantrole.FieldUserID)
	}
	if m.tenant_id != nil {
		fields = append(fields, usertenantrole.FieldTenantID)
	}
	if m.role_id != nil {
		fields = append(fields, usertenantrole.FieldRoleID)
	}
	if m.created_by != nil {
		fields = append(fields, usertenantrole.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, usertenantrole.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, usertenantrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usertenantrole.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserTenantRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usertenantrole.FieldUserID:
		return m.UserID()
	case usertenantrole.FieldTenantID:
		return m.TenantID()
	case usertenantrole.FieldRoleID:
		return m.RoleID()
	case usertenantrole.FieldCreatedBy:
		return m.CreatedBy()
	case usertenantrole.FieldUpdatedBy:
		return m.UpdatedBy()
	case usertenantrole.FieldCreatedAt:
		return m.CreatedAt()
	case usertenantrole.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserTenantRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usertenantrole.FieldUserID:
		return m.OldUserID(ctx)
	case usertenantrole.FieldTenantID:
		return m.OldTenantID(ctx)
	case usertenantrole.FieldRoleID:
		return m.OldRoleID(ctx)
	case usertenantrole.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case usertenantrole.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case usertenantrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usertenantrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserTenantRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTenantRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usertenantrole.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usertenantrole.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case usertenantrole.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case usertenantrole.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case usertenantrole.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case usertenantrole.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usertenantrole.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserTenantRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserTenantRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, usertenantrole.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, usertenantrole.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserTenantRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usertenantrole.FieldCreatedAt:
		return m.AddedCreatedAt()
	case usertenantrole.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTenantRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usertenantrole.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case usertenantrole.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserTenantRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserTenantRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usertenantrole.FieldUserID) {
		fields = append(fields, usertenantrole.FieldUserID)
	}
	if m.FieldCleared(usertenantrole.FieldTenantID) {
		fields = append(fields, usertenantrole.FieldTenantID)
	}
	if m.FieldCleared(usertenantrole.FieldRoleID) {
		fields = append(fields, usertenantrole.FieldRoleID)
	}
	if m.FieldCleared(usertenantrole.FieldCreatedBy) {
		fields = append(fields, usertenantrole.FieldCreatedBy)
	}
	if m.FieldCleared(usertenantrole.FieldUpdatedBy) {
		fields = append(fields, usertenantrole.FieldUpdatedBy)
	}
	if m.FieldCleared(usertenantrole.FieldCreatedAt) {
		fields = append(fields, usertenantrole.FieldCreatedAt)
	}
	if m.FieldCleared(usertenantrole.FieldUpdatedAt) {
		fields = append(fields, usertenantrole.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserTenantRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserTenantRoleMutation) ClearField(name string) error {
	switch name {
	case usertenantrole.FieldUserID:
		m.ClearUserID()
		return nil
	case usertenantrole.FieldTenantID:
		m.ClearTenantID()
		return nil
	case usertenantrole.FieldRoleID:
		m.ClearRoleID()
		return nil
	case usertenantrole.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case usertenantrole.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case usertenantrole.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usertenantrole.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserTenantRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserTenantRoleMutation) ResetField(name string) error {
	switch name {
	case usertenantrole.FieldUserID:
		m.ResetUserID()
		return nil
	case usertenantrole.FieldTenantID:
		m.ResetTenantID()
		return nil
	case usertenantrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case usertenantrole.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case usertenantrole.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case usertenantrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usertenantrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserTenantRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserTenantRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserTenantRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserTenantRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserTenantRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserTenantRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserTenantRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserTenantRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserTenantRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserTenantRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserTenantRole edge %s", name)
}
