// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"ncobase/core/workflow/data/ent/business"
	"ncobase/core/workflow/data/ent/delegation"
	"ncobase/core/workflow/data/ent/history"
	"ncobase/core/workflow/data/ent/node"
	"ncobase/core/workflow/data/ent/predicate"
	"ncobase/core/workflow/data/ent/process"
	"ncobase/core/workflow/data/ent/processdesign"
	"ncobase/core/workflow/data/ent/rule"
	"ncobase/core/workflow/data/ent/task"
	"ncobase/core/workflow/data/ent/template"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBusiness      = "Business"
	TypeDelegation    = "Delegation"
	TypeHistory       = "History"
	TypeNode          = "Node"
	TypeProcess       = "Process"
	TypeProcessDesign = "ProcessDesign"
	TypeRule          = "Rule"
	TypeTask          = "Task"
	TypeTemplate      = "Template"
)

// BusinessMutation represents an operation that mutates the Business nodes in the graph.
type BusinessMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	code                 *string
	status               *string
	form_code            *string
	form_version         *string
	form_config          *map[string]interface{}
	form_permissions     *map[string]interface{}
	field_permissions    *map[string]interface{}
	process_id           *string
	template_id          *string
	business_key         *string
	origin_data          *map[string]interface{}
	current_data         *map[string]interface{}
	change_logs          *[]map[string]interface{}
	appendchange_logs    []map[string]interface{}
	last_modified        *int64
	addlast_modified     *int64
	last_modifier        *string
	operation_logs       *[]map[string]interface{}
	appendoperation_logs []map[string]interface{}
	flow_status          *string
	flow_variables       *map[string]interface{}
	is_draft             *bool
	is_terminated        *bool
	is_suspended         *bool
	suspend_reason       *string
	business_tags        *[]string
	appendbusiness_tags  []string
	module_code          *string
	category             *string
	viewers              *[]string
	appendviewers        []string
	editors              *[]string
	appendeditors        []string
	permission_configs   *map[string]interface{}
	role_configs         *map[string]interface{}
	visible_range        *map[string]interface{}
	extras               *map[string]interface{}
	tenant_id            *string
	created_by           *string
	updated_by           *string
	created_at           *int64
	addcreated_at        *int64
	updated_at           *int64
	addupdated_at        *int64
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Business, error)
	predicates           []predicate.Business
}

var _ ent.Mutation = (*BusinessMutation)(nil)

// businessOption allows management of the mutation configuration using functional options.
type businessOption func(*BusinessMutation)

// newBusinessMutation creates new mutation for the Business entity.
func newBusinessMutation(c config, op Op, opts ...businessOption) *BusinessMutation {
	m := &BusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessID sets the ID field of the mutation.
func withBusinessID(id string) businessOption {
	return func(m *BusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *Business
		)
		m.oldValue = func(ctx context.Context) (*Business, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Business.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusiness sets the old Business of the mutation.
func withBusiness(node *Business) businessOption {
	return func(m *BusinessMutation) {
		m.oldValue = func(context.Context) (*Business, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Business entities.
func (m *BusinessMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Business.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *BusinessMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *BusinessMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *BusinessMutation) ClearCode() {
	m.code = nil
	m.clearedFields[business.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *BusinessMutation) CodeCleared() bool {
	_, ok := m.clearedFields[business.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *BusinessMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, business.FieldCode)
}

// SetStatus sets the "status" field.
func (m *BusinessMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *BusinessMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *BusinessMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[business.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *BusinessMutation) StatusCleared() bool {
	_, ok := m.clearedFields[business.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *BusinessMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, business.FieldStatus)
}

// SetFormCode sets the "form_code" field.
func (m *BusinessMutation) SetFormCode(s string) {
	m.form_code = &s
}

// FormCode returns the value of the "form_code" field in the mutation.
func (m *BusinessMutation) FormCode() (r string, exists bool) {
	v := m.form_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFormCode returns the old "form_code" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldFormCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormCode: %w", err)
	}
	return oldValue.FormCode, nil
}

// ResetFormCode resets all changes to the "form_code" field.
func (m *BusinessMutation) ResetFormCode() {
	m.form_code = nil
}

// SetFormVersion sets the "form_version" field.
func (m *BusinessMutation) SetFormVersion(s string) {
	m.form_version = &s
}

// FormVersion returns the value of the "form_version" field in the mutation.
func (m *BusinessMutation) FormVersion() (r string, exists bool) {
	v := m.form_version
	if v == nil {
		return
	}
	return *v, true
}

// OldFormVersion returns the old "form_version" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldFormVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormVersion: %w", err)
	}
	return oldValue.FormVersion, nil
}

// ClearFormVersion clears the value of the "form_version" field.
func (m *BusinessMutation) ClearFormVersion() {
	m.form_version = nil
	m.clearedFields[business.FieldFormVersion] = struct{}{}
}

// FormVersionCleared returns if the "form_version" field was cleared in this mutation.
func (m *BusinessMutation) FormVersionCleared() bool {
	_, ok := m.clearedFields[business.FieldFormVersion]
	return ok
}

// ResetFormVersion resets all changes to the "form_version" field.
func (m *BusinessMutation) ResetFormVersion() {
	m.form_version = nil
	delete(m.clearedFields, business.FieldFormVersion)
}

// SetFormConfig sets the "form_config" field.
func (m *BusinessMutation) SetFormConfig(value map[string]interface{}) {
	m.form_config = &value
}

// FormConfig returns the value of the "form_config" field in the mutation.
func (m *BusinessMutation) FormConfig() (r map[string]interface{}, exists bool) {
	v := m.form_config
	if v == nil {
		return
	}
	return *v, true
}

// OldFormConfig returns the old "form_config" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldFormConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormConfig: %w", err)
	}
	return oldValue.FormConfig, nil
}

// ClearFormConfig clears the value of the "form_config" field.
func (m *BusinessMutation) ClearFormConfig() {
	m.form_config = nil
	m.clearedFields[business.FieldFormConfig] = struct{}{}
}

// FormConfigCleared returns if the "form_config" field was cleared in this mutation.
func (m *BusinessMutation) FormConfigCleared() bool {
	_, ok := m.clearedFields[business.FieldFormConfig]
	return ok
}

// ResetFormConfig resets all changes to the "form_config" field.
func (m *BusinessMutation) ResetFormConfig() {
	m.form_config = nil
	delete(m.clearedFields, business.FieldFormConfig)
}

// SetFormPermissions sets the "form_permissions" field.
func (m *BusinessMutation) SetFormPermissions(value map[string]interface{}) {
	m.form_permissions = &value
}

// FormPermissions returns the value of the "form_permissions" field in the mutation.
func (m *BusinessMutation) FormPermissions() (r map[string]interface{}, exists bool) {
	v := m.form_permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldFormPermissions returns the old "form_permissions" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldFormPermissions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormPermissions: %w", err)
	}
	return oldValue.FormPermissions, nil
}

// ClearFormPermissions clears the value of the "form_permissions" field.
func (m *BusinessMutation) ClearFormPermissions() {
	m.form_permissions = nil
	m.clearedFields[business.FieldFormPermissions] = struct{}{}
}

// FormPermissionsCleared returns if the "form_permissions" field was cleared in this mutation.
func (m *BusinessMutation) FormPermissionsCleared() bool {
	_, ok := m.clearedFields[business.FieldFormPermissions]
	return ok
}

// ResetFormPermissions resets all changes to the "form_permissions" field.
func (m *BusinessMutation) ResetFormPermissions() {
	m.form_permissions = nil
	delete(m.clearedFields, business.FieldFormPermissions)
}

// SetFieldPermissions sets the "field_permissions" field.
func (m *BusinessMutation) SetFieldPermissions(value map[string]interface{}) {
	m.field_permissions = &value
}

// FieldPermissions returns the value of the "field_permissions" field in the mutation.
func (m *BusinessMutation) FieldPermissions() (r map[string]interface{}, exists bool) {
	v := m.field_permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldPermissions returns the old "field_permissions" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldFieldPermissions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldPermissions: %w", err)
	}
	return oldValue.FieldPermissions, nil
}

// ClearFieldPermissions clears the value of the "field_permissions" field.
func (m *BusinessMutation) ClearFieldPermissions() {
	m.field_permissions = nil
	m.clearedFields[business.FieldFieldPermissions] = struct{}{}
}

// FieldPermissionsCleared returns if the "field_permissions" field was cleared in this mutation.
func (m *BusinessMutation) FieldPermissionsCleared() bool {
	_, ok := m.clearedFields[business.FieldFieldPermissions]
	return ok
}

// ResetFieldPermissions resets all changes to the "field_permissions" field.
func (m *BusinessMutation) ResetFieldPermissions() {
	m.field_permissions = nil
	delete(m.clearedFields, business.FieldFieldPermissions)
}

// SetProcessID sets the "process_id" field.
func (m *BusinessMutation) SetProcessID(s string) {
	m.process_id = &s
}

// ProcessID returns the value of the "process_id" field in the mutation.
func (m *BusinessMutation) ProcessID() (r string, exists bool) {
	v := m.process_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessID returns the old "process_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldProcessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessID: %w", err)
	}
	return oldValue.ProcessID, nil
}

// ResetProcessID resets all changes to the "process_id" field.
func (m *BusinessMutation) ResetProcessID() {
	m.process_id = nil
}

// SetTemplateID sets the "template_id" field.
func (m *BusinessMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *BusinessMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *BusinessMutation) ResetTemplateID() {
	m.template_id = nil
}

// SetBusinessKey sets the "business_key" field.
func (m *BusinessMutation) SetBusinessKey(s string) {
	m.business_key = &s
}

// BusinessKey returns the value of the "business_key" field in the mutation.
func (m *BusinessMutation) BusinessKey() (r string, exists bool) {
	v := m.business_key
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessKey returns the old "business_key" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldBusinessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessKey: %w", err)
	}
	return oldValue.BusinessKey, nil
}

// ResetBusinessKey resets all changes to the "business_key" field.
func (m *BusinessMutation) ResetBusinessKey() {
	m.business_key = nil
}

// SetOriginData sets the "origin_data" field.
func (m *BusinessMutation) SetOriginData(value map[string]interface{}) {
	m.origin_data = &value
}

// OriginData returns the value of the "origin_data" field in the mutation.
func (m *BusinessMutation) OriginData() (r map[string]interface{}, exists bool) {
	v := m.origin_data
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginData returns the old "origin_data" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldOriginData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginData: %w", err)
	}
	return oldValue.OriginData, nil
}

// ResetOriginData resets all changes to the "origin_data" field.
func (m *BusinessMutation) ResetOriginData() {
	m.origin_data = nil
}

// SetCurrentData sets the "current_data" field.
func (m *BusinessMutation) SetCurrentData(value map[string]interface{}) {
	m.current_data = &value
}

// CurrentData returns the value of the "current_data" field in the mutation.
func (m *BusinessMutation) CurrentData() (r map[string]interface{}, exists bool) {
	v := m.current_data
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentData returns the old "current_data" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCurrentData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentData: %w", err)
	}
	return oldValue.CurrentData, nil
}

// ResetCurrentData resets all changes to the "current_data" field.
func (m *BusinessMutation) ResetCurrentData() {
	m.current_data = nil
}

// SetChangeLogs sets the "change_logs" field.
func (m *BusinessMutation) SetChangeLogs(value []map[string]interface{}) {
	m.change_logs = &value
	m.appendchange_logs = nil
}

// ChangeLogs returns the value of the "change_logs" field in the mutation.
func (m *BusinessMutation) ChangeLogs() (r []map[string]interface{}, exists bool) {
	v := m.change_logs
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeLogs returns the old "change_logs" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldChangeLogs(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeLogs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeLogs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeLogs: %w", err)
	}
	return oldValue.ChangeLogs, nil
}

// AppendChangeLogs adds value to the "change_logs" field.
func (m *BusinessMutation) AppendChangeLogs(value []map[string]interface{}) {
	m.appendchange_logs = append(m.appendchange_logs, value...)
}

// AppendedChangeLogs returns the list of values that were appended to the "change_logs" field in this mutation.
func (m *BusinessMutation) AppendedChangeLogs() ([]map[string]interface{}, bool) {
	if len(m.appendchange_logs) == 0 {
		return nil, false
	}
	return m.appendchange_logs, true
}

// ClearChangeLogs clears the value of the "change_logs" field.
func (m *BusinessMutation) ClearChangeLogs() {
	m.change_logs = nil
	m.appendchange_logs = nil
	m.clearedFields[business.FieldChangeLogs] = struct{}{}
}

// ChangeLogsCleared returns if the "change_logs" field was cleared in this mutation.
func (m *BusinessMutation) ChangeLogsCleared() bool {
	_, ok := m.clearedFields[business.FieldChangeLogs]
	return ok
}

// ResetChangeLogs resets all changes to the "change_logs" field.
func (m *BusinessMutation) ResetChangeLogs() {
	m.change_logs = nil
	m.appendchange_logs = nil
	delete(m.clearedFields, business.FieldChangeLogs)
}

// SetLastModified sets the "last_modified" field.
func (m *BusinessMutation) SetLastModified(i int64) {
	m.last_modified = &i
	m.addlast_modified = nil
}

// LastModified returns the value of the "last_modified" field in the mutation.
func (m *BusinessMutation) LastModified() (r int64, exists bool) {
	v := m.last_modified
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModified returns the old "last_modified" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldLastModified(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModified: %w", err)
	}
	return oldValue.LastModified, nil
}

// AddLastModified adds i to the "last_modified" field.
func (m *BusinessMutation) AddLastModified(i int64) {
	if m.addlast_modified != nil {
		*m.addlast_modified += i
	} else {
		m.addlast_modified = &i
	}
}

// AddedLastModified returns the value that was added to the "last_modified" field in this mutation.
func (m *BusinessMutation) AddedLastModified() (r int64, exists bool) {
	v := m.addlast_modified
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastModified clears the value of the "last_modified" field.
func (m *BusinessMutation) ClearLastModified() {
	m.last_modified = nil
	m.addlast_modified = nil
	m.clearedFields[business.FieldLastModified] = struct{}{}
}

// LastModifiedCleared returns if the "last_modified" field was cleared in this mutation.
func (m *BusinessMutation) LastModifiedCleared() bool {
	_, ok := m.clearedFields[business.FieldLastModified]
	return ok
}

// ResetLastModified resets all changes to the "last_modified" field.
func (m *BusinessMutation) ResetLastModified() {
	m.last_modified = nil
	m.addlast_modified = nil
	delete(m.clearedFields, business.FieldLastModified)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BusinessMutation) SetLastModifier(s string) {
	m.last_modifier = &s
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BusinessMutation) LastModifier() (r string, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldLastModifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BusinessMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[business.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BusinessMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[business.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BusinessMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, business.FieldLastModifier)
}

// SetOperationLogs sets the "operation_logs" field.
func (m *BusinessMutation) SetOperationLogs(value []map[string]interface{}) {
	m.operation_logs = &value
	m.appendoperation_logs = nil
}

// OperationLogs returns the value of the "operation_logs" field in the mutation.
func (m *BusinessMutation) OperationLogs() (r []map[string]interface{}, exists bool) {
	v := m.operation_logs
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationLogs returns the old "operation_logs" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldOperationLogs(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationLogs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationLogs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationLogs: %w", err)
	}
	return oldValue.OperationLogs, nil
}

// AppendOperationLogs adds value to the "operation_logs" field.
func (m *BusinessMutation) AppendOperationLogs(value []map[string]interface{}) {
	m.appendoperation_logs = append(m.appendoperation_logs, value...)
}

// AppendedOperationLogs returns the list of values that were appended to the "operation_logs" field in this mutation.
func (m *BusinessMutation) AppendedOperationLogs() ([]map[string]interface{}, bool) {
	if len(m.appendoperation_logs) == 0 {
		return nil, false
	}
	return m.appendoperation_logs, true
}

// ClearOperationLogs clears the value of the "operation_logs" field.
func (m *BusinessMutation) ClearOperationLogs() {
	m.operation_logs = nil
	m.appendoperation_logs = nil
	m.clearedFields[business.FieldOperationLogs] = struct{}{}
}

// OperationLogsCleared returns if the "operation_logs" field was cleared in this mutation.
func (m *BusinessMutation) OperationLogsCleared() bool {
	_, ok := m.clearedFields[business.FieldOperationLogs]
	return ok
}

// ResetOperationLogs resets all changes to the "operation_logs" field.
func (m *BusinessMutation) ResetOperationLogs() {
	m.operation_logs = nil
	m.appendoperation_logs = nil
	delete(m.clearedFields, business.FieldOperationLogs)
}

// SetFlowStatus sets the "flow_status" field.
func (m *BusinessMutation) SetFlowStatus(s string) {
	m.flow_status = &s
}

// FlowStatus returns the value of the "flow_status" field in the mutation.
func (m *BusinessMutation) FlowStatus() (r string, exists bool) {
	v := m.flow_status
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowStatus returns the old "flow_status" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldFlowStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowStatus: %w", err)
	}
	return oldValue.FlowStatus, nil
}

// ClearFlowStatus clears the value of the "flow_status" field.
func (m *BusinessMutation) ClearFlowStatus() {
	m.flow_status = nil
	m.clearedFields[business.FieldFlowStatus] = struct{}{}
}

// FlowStatusCleared returns if the "flow_status" field was cleared in this mutation.
func (m *BusinessMutation) FlowStatusCleared() bool {
	_, ok := m.clearedFields[business.FieldFlowStatus]
	return ok
}

// ResetFlowStatus resets all changes to the "flow_status" field.
func (m *BusinessMutation) ResetFlowStatus() {
	m.flow_status = nil
	delete(m.clearedFields, business.FieldFlowStatus)
}

// SetFlowVariables sets the "flow_variables" field.
func (m *BusinessMutation) SetFlowVariables(value map[string]interface{}) {
	m.flow_variables = &value
}

// FlowVariables returns the value of the "flow_variables" field in the mutation.
func (m *BusinessMutation) FlowVariables() (r map[string]interface{}, exists bool) {
	v := m.flow_variables
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowVariables returns the old "flow_variables" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldFlowVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowVariables: %w", err)
	}
	return oldValue.FlowVariables, nil
}

// ClearFlowVariables clears the value of the "flow_variables" field.
func (m *BusinessMutation) ClearFlowVariables() {
	m.flow_variables = nil
	m.clearedFields[business.FieldFlowVariables] = struct{}{}
}

// FlowVariablesCleared returns if the "flow_variables" field was cleared in this mutation.
func (m *BusinessMutation) FlowVariablesCleared() bool {
	_, ok := m.clearedFields[business.FieldFlowVariables]
	return ok
}

// ResetFlowVariables resets all changes to the "flow_variables" field.
func (m *BusinessMutation) ResetFlowVariables() {
	m.flow_variables = nil
	delete(m.clearedFields, business.FieldFlowVariables)
}

// SetIsDraft sets the "is_draft" field.
func (m *BusinessMutation) SetIsDraft(b bool) {
	m.is_draft = &b
}

// IsDraft returns the value of the "is_draft" field in the mutation.
func (m *BusinessMutation) IsDraft() (r bool, exists bool) {
	v := m.is_draft
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDraft returns the old "is_draft" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldIsDraft(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDraft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDraft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDraft: %w", err)
	}
	return oldValue.IsDraft, nil
}

// ResetIsDraft resets all changes to the "is_draft" field.
func (m *BusinessMutation) ResetIsDraft() {
	m.is_draft = nil
}

// SetIsTerminated sets the "is_terminated" field.
func (m *BusinessMutation) SetIsTerminated(b bool) {
	m.is_terminated = &b
}

// IsTerminated returns the value of the "is_terminated" field in the mutation.
func (m *BusinessMutation) IsTerminated() (r bool, exists bool) {
	v := m.is_terminated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTerminated returns the old "is_terminated" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldIsTerminated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTerminated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTerminated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTerminated: %w", err)
	}
	return oldValue.IsTerminated, nil
}

// ResetIsTerminated resets all changes to the "is_terminated" field.
func (m *BusinessMutation) ResetIsTerminated() {
	m.is_terminated = nil
}

// SetIsSuspended sets the "is_suspended" field.
func (m *BusinessMutation) SetIsSuspended(b bool) {
	m.is_suspended = &b
}

// IsSuspended returns the value of the "is_suspended" field in the mutation.
func (m *BusinessMutation) IsSuspended() (r bool, exists bool) {
	v := m.is_suspended
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuspended returns the old "is_suspended" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldIsSuspended(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuspended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuspended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuspended: %w", err)
	}
	return oldValue.IsSuspended, nil
}

// ResetIsSuspended resets all changes to the "is_suspended" field.
func (m *BusinessMutation) ResetIsSuspended() {
	m.is_suspended = nil
}

// SetSuspendReason sets the "suspend_reason" field.
func (m *BusinessMutation) SetSuspendReason(s string) {
	m.suspend_reason = &s
}

// SuspendReason returns the value of the "suspend_reason" field in the mutation.
func (m *BusinessMutation) SuspendReason() (r string, exists bool) {
	v := m.suspend_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendReason returns the old "suspend_reason" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldSuspendReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendReason: %w", err)
	}
	return oldValue.SuspendReason, nil
}

// ClearSuspendReason clears the value of the "suspend_reason" field.
func (m *BusinessMutation) ClearSuspendReason() {
	m.suspend_reason = nil
	m.clearedFields[business.FieldSuspendReason] = struct{}{}
}

// SuspendReasonCleared returns if the "suspend_reason" field was cleared in this mutation.
func (m *BusinessMutation) SuspendReasonCleared() bool {
	_, ok := m.clearedFields[business.FieldSuspendReason]
	return ok
}

// ResetSuspendReason resets all changes to the "suspend_reason" field.
func (m *BusinessMutation) ResetSuspendReason() {
	m.suspend_reason = nil
	delete(m.clearedFields, business.FieldSuspendReason)
}

// SetBusinessTags sets the "business_tags" field.
func (m *BusinessMutation) SetBusinessTags(s []string) {
	m.business_tags = &s
	m.appendbusiness_tags = nil
}

// BusinessTags returns the value of the "business_tags" field in the mutation.
func (m *BusinessMutation) BusinessTags() (r []string, exists bool) {
	v := m.business_tags
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessTags returns the old "business_tags" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldBusinessTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessTags: %w", err)
	}
	return oldValue.BusinessTags, nil
}

// AppendBusinessTags adds s to the "business_tags" field.
func (m *BusinessMutation) AppendBusinessTags(s []string) {
	m.appendbusiness_tags = append(m.appendbusiness_tags, s...)
}

// AppendedBusinessTags returns the list of values that were appended to the "business_tags" field in this mutation.
func (m *BusinessMutation) AppendedBusinessTags() ([]string, bool) {
	if len(m.appendbusiness_tags) == 0 {
		return nil, false
	}
	return m.appendbusiness_tags, true
}

// ClearBusinessTags clears the value of the "business_tags" field.
func (m *BusinessMutation) ClearBusinessTags() {
	m.business_tags = nil
	m.appendbusiness_tags = nil
	m.clearedFields[business.FieldBusinessTags] = struct{}{}
}

// BusinessTagsCleared returns if the "business_tags" field was cleared in this mutation.
func (m *BusinessMutation) BusinessTagsCleared() bool {
	_, ok := m.clearedFields[business.FieldBusinessTags]
	return ok
}

// ResetBusinessTags resets all changes to the "business_tags" field.
func (m *BusinessMutation) ResetBusinessTags() {
	m.business_tags = nil
	m.appendbusiness_tags = nil
	delete(m.clearedFields, business.FieldBusinessTags)
}

// SetModuleCode sets the "module_code" field.
func (m *BusinessMutation) SetModuleCode(s string) {
	m.module_code = &s
}

// ModuleCode returns the value of the "module_code" field in the mutation.
func (m *BusinessMutation) ModuleCode() (r string, exists bool) {
	v := m.module_code
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleCode returns the old "module_code" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldModuleCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleCode: %w", err)
	}
	return oldValue.ModuleCode, nil
}

// ResetModuleCode resets all changes to the "module_code" field.
func (m *BusinessMutation) ResetModuleCode() {
	m.module_code = nil
}

// SetCategory sets the "category" field.
func (m *BusinessMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *BusinessMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *BusinessMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[business.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *BusinessMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[business.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *BusinessMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, business.FieldCategory)
}

// SetViewers sets the "viewers" field.
func (m *BusinessMutation) SetViewers(s []string) {
	m.viewers = &s
	m.appendviewers = nil
}

// Viewers returns the value of the "viewers" field in the mutation.
func (m *BusinessMutation) Viewers() (r []string, exists bool) {
	v := m.viewers
	if v == nil {
		return
	}
	return *v, true
}

// OldViewers returns the old "viewers" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldViewers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewers: %w", err)
	}
	return oldValue.Viewers, nil
}

// AppendViewers adds s to the "viewers" field.
func (m *BusinessMutation) AppendViewers(s []string) {
	m.appendviewers = append(m.appendviewers, s...)
}

// AppendedViewers returns the list of values that were appended to the "viewers" field in this mutation.
func (m *BusinessMutation) AppendedViewers() ([]string, bool) {
	if len(m.appendviewers) == 0 {
		return nil, false
	}
	return m.appendviewers, true
}

// ClearViewers clears the value of the "viewers" field.
func (m *BusinessMutation) ClearViewers() {
	m.viewers = nil
	m.appendviewers = nil
	m.clearedFields[business.FieldViewers] = struct{}{}
}

// ViewersCleared returns if the "viewers" field was cleared in this mutation.
func (m *BusinessMutation) ViewersCleared() bool {
	_, ok := m.clearedFields[business.FieldViewers]
	return ok
}

// ResetViewers resets all changes to the "viewers" field.
func (m *BusinessMutation) ResetViewers() {
	m.viewers = nil
	m.appendviewers = nil
	delete(m.clearedFields, business.FieldViewers)
}

// SetEditors sets the "editors" field.
func (m *BusinessMutation) SetEditors(s []string) {
	m.editors = &s
	m.appendeditors = nil
}

// Editors returns the value of the "editors" field in the mutation.
func (m *BusinessMutation) Editors() (r []string, exists bool) {
	v := m.editors
	if v == nil {
		return
	}
	return *v, true
}

// OldEditors returns the old "editors" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldEditors(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditors: %w", err)
	}
	return oldValue.Editors, nil
}

// AppendEditors adds s to the "editors" field.
func (m *BusinessMutation) AppendEditors(s []string) {
	m.appendeditors = append(m.appendeditors, s...)
}

// AppendedEditors returns the list of values that were appended to the "editors" field in this mutation.
func (m *BusinessMutation) AppendedEditors() ([]string, bool) {
	if len(m.appendeditors) == 0 {
		return nil, false
	}
	return m.appendeditors, true
}

// ClearEditors clears the value of the "editors" field.
func (m *BusinessMutation) ClearEditors() {
	m.editors = nil
	m.appendeditors = nil
	m.clearedFields[business.FieldEditors] = struct{}{}
}

// EditorsCleared returns if the "editors" field was cleared in this mutation.
func (m *BusinessMutation) EditorsCleared() bool {
	_, ok := m.clearedFields[business.FieldEditors]
	return ok
}

// ResetEditors resets all changes to the "editors" field.
func (m *BusinessMutation) ResetEditors() {
	m.editors = nil
	m.appendeditors = nil
	delete(m.clearedFields, business.FieldEditors)
}

// SetPermissionConfigs sets the "permission_configs" field.
func (m *BusinessMutation) SetPermissionConfigs(value map[string]interface{}) {
	m.permission_configs = &value
}

// PermissionConfigs returns the value of the "permission_configs" field in the mutation.
func (m *BusinessMutation) PermissionConfigs() (r map[string]interface{}, exists bool) {
	v := m.permission_configs
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionConfigs returns the old "permission_configs" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldPermissionConfigs(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionConfigs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionConfigs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionConfigs: %w", err)
	}
	return oldValue.PermissionConfigs, nil
}

// ClearPermissionConfigs clears the value of the "permission_configs" field.
func (m *BusinessMutation) ClearPermissionConfigs() {
	m.permission_configs = nil
	m.clearedFields[business.FieldPermissionConfigs] = struct{}{}
}

// PermissionConfigsCleared returns if the "permission_configs" field was cleared in this mutation.
func (m *BusinessMutation) PermissionConfigsCleared() bool {
	_, ok := m.clearedFields[business.FieldPermissionConfigs]
	return ok
}

// ResetPermissionConfigs resets all changes to the "permission_configs" field.
func (m *BusinessMutation) ResetPermissionConfigs() {
	m.permission_configs = nil
	delete(m.clearedFields, business.FieldPermissionConfigs)
}

// SetRoleConfigs sets the "role_configs" field.
func (m *BusinessMutation) SetRoleConfigs(value map[string]interface{}) {
	m.role_configs = &value
}

// RoleConfigs returns the value of the "role_configs" field in the mutation.
func (m *BusinessMutation) RoleConfigs() (r map[string]interface{}, exists bool) {
	v := m.role_configs
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleConfigs returns the old "role_configs" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldRoleConfigs(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleConfigs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleConfigs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleConfigs: %w", err)
	}
	return oldValue.RoleConfigs, nil
}

// ClearRoleConfigs clears the value of the "role_configs" field.
func (m *BusinessMutation) ClearRoleConfigs() {
	m.role_configs = nil
	m.clearedFields[business.FieldRoleConfigs] = struct{}{}
}

// RoleConfigsCleared returns if the "role_configs" field was cleared in this mutation.
func (m *BusinessMutation) RoleConfigsCleared() bool {
	_, ok := m.clearedFields[business.FieldRoleConfigs]
	return ok
}

// ResetRoleConfigs resets all changes to the "role_configs" field.
func (m *BusinessMutation) ResetRoleConfigs() {
	m.role_configs = nil
	delete(m.clearedFields, business.FieldRoleConfigs)
}

// SetVisibleRange sets the "visible_range" field.
func (m *BusinessMutation) SetVisibleRange(value map[string]interface{}) {
	m.visible_range = &value
}

// VisibleRange returns the value of the "visible_range" field in the mutation.
func (m *BusinessMutation) VisibleRange() (r map[string]interface{}, exists bool) {
	v := m.visible_range
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibleRange returns the old "visible_range" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldVisibleRange(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibleRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibleRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibleRange: %w", err)
	}
	return oldValue.VisibleRange, nil
}

// ClearVisibleRange clears the value of the "visible_range" field.
func (m *BusinessMutation) ClearVisibleRange() {
	m.visible_range = nil
	m.clearedFields[business.FieldVisibleRange] = struct{}{}
}

// VisibleRangeCleared returns if the "visible_range" field was cleared in this mutation.
func (m *BusinessMutation) VisibleRangeCleared() bool {
	_, ok := m.clearedFields[business.FieldVisibleRange]
	return ok
}

// ResetVisibleRange resets all changes to the "visible_range" field.
func (m *BusinessMutation) ResetVisibleRange() {
	m.visible_range = nil
	delete(m.clearedFields, business.FieldVisibleRange)
}

// SetExtras sets the "extras" field.
func (m *BusinessMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *BusinessMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *BusinessMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[business.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *BusinessMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[business.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *BusinessMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, business.FieldExtras)
}

// SetTenantID sets the "tenant_id" field.
func (m *BusinessMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *BusinessMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *BusinessMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[business.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *BusinessMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[business.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *BusinessMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, business.FieldTenantID)
}

// SetCreatedBy sets the "created_by" field.
func (m *BusinessMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BusinessMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *BusinessMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[business.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *BusinessMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[business.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BusinessMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, business.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BusinessMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BusinessMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *BusinessMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[business.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *BusinessMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[business.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BusinessMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, business.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *BusinessMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BusinessMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *BusinessMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BusinessMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *BusinessMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[business.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *BusinessMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[business.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BusinessMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, business.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BusinessMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BusinessMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *BusinessMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BusinessMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BusinessMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[business.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BusinessMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[business.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BusinessMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, business.FieldUpdatedAt)
}

// Where appends a list predicates to the BusinessMutation builder.
func (m *BusinessMutation) Where(ps ...predicate.Business) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Business, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Business).
func (m *BusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessMutation) Fields() []string {
	fields := make([]string, 0, 36)
	if m.code != nil {
		fields = append(fields, business.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, business.FieldStatus)
	}
	if m.form_code != nil {
		fields = append(fields, business.FieldFormCode)
	}
	if m.form_version != nil {
		fields = append(fields, business.FieldFormVersion)
	}
	if m.form_config != nil {
		fields = append(fields, business.FieldFormConfig)
	}
	if m.form_permissions != nil {
		fields = append(fields, business.FieldFormPermissions)
	}
	if m.field_permissions != nil {
		fields = append(fields, business.FieldFieldPermissions)
	}
	if m.process_id != nil {
		fields = append(fields, business.FieldProcessID)
	}
	if m.template_id != nil {
		fields = append(fields, business.FieldTemplateID)
	}
	if m.business_key != nil {
		fields = append(fields, business.FieldBusinessKey)
	}
	if m.origin_data != nil {
		fields = append(fields, business.FieldOriginData)
	}
	if m.current_data != nil {
		fields = append(fields, business.FieldCurrentData)
	}
	if m.change_logs != nil {
		fields = append(fields, business.FieldChangeLogs)
	}
	if m.last_modified != nil {
		fields = append(fields, business.FieldLastModified)
	}
	if m.last_modifier != nil {
		fields = append(fields, business.FieldLastModifier)
	}
	if m.operation_logs != nil {
		fields = append(fields, business.FieldOperationLogs)
	}
	if m.flow_status != nil {
		fields = append(fields, business.FieldFlowStatus)
	}
	if m.flow_variables != nil {
		fields = append(fields, business.FieldFlowVariables)
	}
	if m.is_draft != nil {
		fields = append(fields, business.FieldIsDraft)
	}
	if m.is_terminated != nil {
		fields = append(fields, business.FieldIsTerminated)
	}
	if m.is_suspended != nil {
		fields = append(fields, business.FieldIsSuspended)
	}
	if m.suspend_reason != nil {
		fields = append(fields, business.FieldSuspendReason)
	}
	if m.business_tags != nil {
		fields = append(fields, business.FieldBusinessTags)
	}
	if m.module_code != nil {
		fields = append(fields, business.FieldModuleCode)
	}
	if m.category != nil {
		fields = append(fields, business.FieldCategory)
	}
	if m.viewers != nil {
		fields = append(fields, business.FieldViewers)
	}
	if m.editors != nil {
		fields = append(fields, business.FieldEditors)
	}
	if m.permission_configs != nil {
		fields = append(fields, business.FieldPermissionConfigs)
	}
	if m.role_configs != nil {
		fields = append(fields, business.FieldRoleConfigs)
	}
	if m.visible_range != nil {
		fields = append(fields, business.FieldVisibleRange)
	}
	if m.extras != nil {
		fields = append(fields, business.FieldExtras)
	}
	if m.tenant_id != nil {
		fields = append(fields, business.FieldTenantID)
	}
	if m.created_by != nil {
		fields = append(fields, business.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, business.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, business.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, business.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case business.FieldCode:
		return m.Code()
	case business.FieldStatus:
		return m.Status()
	case business.FieldFormCode:
		return m.FormCode()
	case business.FieldFormVersion:
		return m.FormVersion()
	case business.FieldFormConfig:
		return m.FormConfig()
	case business.FieldFormPermissions:
		return m.FormPermissions()
	case business.FieldFieldPermissions:
		return m.FieldPermissions()
	case business.FieldProcessID:
		return m.ProcessID()
	case business.FieldTemplateID:
		return m.TemplateID()
	case business.FieldBusinessKey:
		return m.BusinessKey()
	case business.FieldOriginData:
		return m.OriginData()
	case business.FieldCurrentData:
		return m.CurrentData()
	case business.FieldChangeLogs:
		return m.ChangeLogs()
	case business.FieldLastModified:
		return m.LastModified()
	case business.FieldLastModifier:
		return m.LastModifier()
	case business.FieldOperationLogs:
		return m.OperationLogs()
	case business.FieldFlowStatus:
		return m.FlowStatus()
	case business.FieldFlowVariables:
		return m.FlowVariables()
	case business.FieldIsDraft:
		return m.IsDraft()
	case business.FieldIsTerminated:
		return m.IsTerminated()
	case business.FieldIsSuspended:
		return m.IsSuspended()
	case business.FieldSuspendReason:
		return m.SuspendReason()
	case business.FieldBusinessTags:
		return m.BusinessTags()
	case business.FieldModuleCode:
		return m.ModuleCode()
	case business.FieldCategory:
		return m.Category()
	case business.FieldViewers:
		return m.Viewers()
	case business.FieldEditors:
		return m.Editors()
	case business.FieldPermissionConfigs:
		return m.PermissionConfigs()
	case business.FieldRoleConfigs:
		return m.RoleConfigs()
	case business.FieldVisibleRange:
		return m.VisibleRange()
	case business.FieldExtras:
		return m.Extras()
	case business.FieldTenantID:
		return m.TenantID()
	case business.FieldCreatedBy:
		return m.CreatedBy()
	case business.FieldUpdatedBy:
		return m.UpdatedBy()
	case business.FieldCreatedAt:
		return m.CreatedAt()
	case business.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case business.FieldCode:
		return m.OldCode(ctx)
	case business.FieldStatus:
		return m.OldStatus(ctx)
	case business.FieldFormCode:
		return m.OldFormCode(ctx)
	case business.FieldFormVersion:
		return m.OldFormVersion(ctx)
	case business.FieldFormConfig:
		return m.OldFormConfig(ctx)
	case business.FieldFormPermissions:
		return m.OldFormPermissions(ctx)
	case business.FieldFieldPermissions:
		return m.OldFieldPermissions(ctx)
	case business.FieldProcessID:
		return m.OldProcessID(ctx)
	case business.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case business.FieldBusinessKey:
		return m.OldBusinessKey(ctx)
	case business.FieldOriginData:
		return m.OldOriginData(ctx)
	case business.FieldCurrentData:
		return m.OldCurrentData(ctx)
	case business.FieldChangeLogs:
		return m.OldChangeLogs(ctx)
	case business.FieldLastModified:
		return m.OldLastModified(ctx)
	case business.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case business.FieldOperationLogs:
		return m.OldOperationLogs(ctx)
	case business.FieldFlowStatus:
		return m.OldFlowStatus(ctx)
	case business.FieldFlowVariables:
		return m.OldFlowVariables(ctx)
	case business.FieldIsDraft:
		return m.OldIsDraft(ctx)
	case business.FieldIsTerminated:
		return m.OldIsTerminated(ctx)
	case business.FieldIsSuspended:
		return m.OldIsSuspended(ctx)
	case business.FieldSuspendReason:
		return m.OldSuspendReason(ctx)
	case business.FieldBusinessTags:
		return m.OldBusinessTags(ctx)
	case business.FieldModuleCode:
		return m.OldModuleCode(ctx)
	case business.FieldCategory:
		return m.OldCategory(ctx)
	case business.FieldViewers:
		return m.OldViewers(ctx)
	case business.FieldEditors:
		return m.OldEditors(ctx)
	case business.FieldPermissionConfigs:
		return m.OldPermissionConfigs(ctx)
	case business.FieldRoleConfigs:
		return m.OldRoleConfigs(ctx)
	case business.FieldVisibleRange:
		return m.OldVisibleRange(ctx)
	case business.FieldExtras:
		return m.OldExtras(ctx)
	case business.FieldTenantID:
		return m.OldTenantID(ctx)
	case business.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case business.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case business.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case business.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Business field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case business.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case business.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case business.FieldFormCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormCode(v)
		return nil
	case business.FieldFormVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormVersion(v)
		return nil
	case business.FieldFormConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormConfig(v)
		return nil
	case business.FieldFormPermissions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormPermissions(v)
		return nil
	case business.FieldFieldPermissions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldPermissions(v)
		return nil
	case business.FieldProcessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessID(v)
		return nil
	case business.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case business.FieldBusinessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessKey(v)
		return nil
	case business.FieldOriginData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginData(v)
		return nil
	case business.FieldCurrentData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentData(v)
		return nil
	case business.FieldChangeLogs:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeLogs(v)
		return nil
	case business.FieldLastModified:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModified(v)
		return nil
	case business.FieldLastModifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case business.FieldOperationLogs:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationLogs(v)
		return nil
	case business.FieldFlowStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowStatus(v)
		return nil
	case business.FieldFlowVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowVariables(v)
		return nil
	case business.FieldIsDraft:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDraft(v)
		return nil
	case business.FieldIsTerminated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTerminated(v)
		return nil
	case business.FieldIsSuspended:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuspended(v)
		return nil
	case business.FieldSuspendReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendReason(v)
		return nil
	case business.FieldBusinessTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessTags(v)
		return nil
	case business.FieldModuleCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleCode(v)
		return nil
	case business.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case business.FieldViewers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewers(v)
		return nil
	case business.FieldEditors:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditors(v)
		return nil
	case business.FieldPermissionConfigs:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionConfigs(v)
		return nil
	case business.FieldRoleConfigs:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleConfigs(v)
		return nil
	case business.FieldVisibleRange:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibleRange(v)
		return nil
	case business.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case business.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case business.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case business.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case business.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case business.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessMutation) AddedFields() []string {
	var fields []string
	if m.addlast_modified != nil {
		fields = append(fields, business.FieldLastModified)
	}
	if m.addcreated_at != nil {
		fields = append(fields, business.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, business.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case business.FieldLastModified:
		return m.AddedLastModified()
	case business.FieldCreatedAt:
		return m.AddedCreatedAt()
	case business.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) AddField(name string, value ent.Value) error {
	switch name {
	case business.FieldLastModified:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastModified(v)
		return nil
	case business.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case business.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Business numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(business.FieldCode) {
		fields = append(fields, business.FieldCode)
	}
	if m.FieldCleared(business.FieldStatus) {
		fields = append(fields, business.FieldStatus)
	}
	if m.FieldCleared(business.FieldFormVersion) {
		fields = append(fields, business.FieldFormVersion)
	}
	if m.FieldCleared(business.FieldFormConfig) {
		fields = append(fields, business.FieldFormConfig)
	}
	if m.FieldCleared(business.FieldFormPermissions) {
		fields = append(fields, business.FieldFormPermissions)
	}
	if m.FieldCleared(business.FieldFieldPermissions) {
		fields = append(fields, business.FieldFieldPermissions)
	}
	if m.FieldCleared(business.FieldChangeLogs) {
		fields = append(fields, business.FieldChangeLogs)
	}
	if m.FieldCleared(business.FieldLastModified) {
		fields = append(fields, business.FieldLastModified)
	}
	if m.FieldCleared(business.FieldLastModifier) {
		fields = append(fields, business.FieldLastModifier)
	}
	if m.FieldCleared(business.FieldOperationLogs) {
		fields = append(fields, business.FieldOperationLogs)
	}
	if m.FieldCleared(business.FieldFlowStatus) {
		fields = append(fields, business.FieldFlowStatus)
	}
	if m.FieldCleared(business.FieldFlowVariables) {
		fields = append(fields, business.FieldFlowVariables)
	}
	if m.FieldCleared(business.FieldSuspendReason) {
		fields = append(fields, business.FieldSuspendReason)
	}
	if m.FieldCleared(business.FieldBusinessTags) {
		fields = append(fields, business.FieldBusinessTags)
	}
	if m.FieldCleared(business.FieldCategory) {
		fields = append(fields, business.FieldCategory)
	}
	if m.FieldCleared(business.FieldViewers) {
		fields = append(fields, business.FieldViewers)
	}
	if m.FieldCleared(business.FieldEditors) {
		fields = append(fields, business.FieldEditors)
	}
	if m.FieldCleared(business.FieldPermissionConfigs) {
		fields = append(fields, business.FieldPermissionConfigs)
	}
	if m.FieldCleared(business.FieldRoleConfigs) {
		fields = append(fields, business.FieldRoleConfigs)
	}
	if m.FieldCleared(business.FieldVisibleRange) {
		fields = append(fields, business.FieldVisibleRange)
	}
	if m.FieldCleared(business.FieldExtras) {
		fields = append(fields, business.FieldExtras)
	}
	if m.FieldCleared(business.FieldTenantID) {
		fields = append(fields, business.FieldTenantID)
	}
	if m.FieldCleared(business.FieldCreatedBy) {
		fields = append(fields, business.FieldCreatedBy)
	}
	if m.FieldCleared(business.FieldUpdatedBy) {
		fields = append(fields, business.FieldUpdatedBy)
	}
	if m.FieldCleared(business.FieldCreatedAt) {
		fields = append(fields, business.FieldCreatedAt)
	}
	if m.FieldCleared(business.FieldUpdatedAt) {
		fields = append(fields, business.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessMutation) ClearField(name string) error {
	switch name {
	case business.FieldCode:
		m.ClearCode()
		return nil
	case business.FieldStatus:
		m.ClearStatus()
		return nil
	case business.FieldFormVersion:
		m.ClearFormVersion()
		return nil
	case business.FieldFormConfig:
		m.ClearFormConfig()
		return nil
	case business.FieldFormPermissions:
		m.ClearFormPermissions()
		return nil
	case business.FieldFieldPermissions:
		m.ClearFieldPermissions()
		return nil
	case business.FieldChangeLogs:
		m.ClearChangeLogs()
		return nil
	case business.FieldLastModified:
		m.ClearLastModified()
		return nil
	case business.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case business.FieldOperationLogs:
		m.ClearOperationLogs()
		return nil
	case business.FieldFlowStatus:
		m.ClearFlowStatus()
		return nil
	case business.FieldFlowVariables:
		m.ClearFlowVariables()
		return nil
	case business.FieldSuspendReason:
		m.ClearSuspendReason()
		return nil
	case business.FieldBusinessTags:
		m.ClearBusinessTags()
		return nil
	case business.FieldCategory:
		m.ClearCategory()
		return nil
	case business.FieldViewers:
		m.ClearViewers()
		return nil
	case business.FieldEditors:
		m.ClearEditors()
		return nil
	case business.FieldPermissionConfigs:
		m.ClearPermissionConfigs()
		return nil
	case business.FieldRoleConfigs:
		m.ClearRoleConfigs()
		return nil
	case business.FieldVisibleRange:
		m.ClearVisibleRange()
		return nil
	case business.FieldExtras:
		m.ClearExtras()
		return nil
	case business.FieldTenantID:
		m.ClearTenantID()
		return nil
	case business.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case business.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case business.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case business.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Business nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessMutation) ResetField(name string) error {
	switch name {
	case business.FieldCode:
		m.ResetCode()
		return nil
	case business.FieldStatus:
		m.ResetStatus()
		return nil
	case business.FieldFormCode:
		m.ResetFormCode()
		return nil
	case business.FieldFormVersion:
		m.ResetFormVersion()
		return nil
	case business.FieldFormConfig:
		m.ResetFormConfig()
		return nil
	case business.FieldFormPermissions:
		m.ResetFormPermissions()
		return nil
	case business.FieldFieldPermissions:
		m.ResetFieldPermissions()
		return nil
	case business.FieldProcessID:
		m.ResetProcessID()
		return nil
	case business.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case business.FieldBusinessKey:
		m.ResetBusinessKey()
		return nil
	case business.FieldOriginData:
		m.ResetOriginData()
		return nil
	case business.FieldCurrentData:
		m.ResetCurrentData()
		return nil
	case business.FieldChangeLogs:
		m.ResetChangeLogs()
		return nil
	case business.FieldLastModified:
		m.ResetLastModified()
		return nil
	case business.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case business.FieldOperationLogs:
		m.ResetOperationLogs()
		return nil
	case business.FieldFlowStatus:
		m.ResetFlowStatus()
		return nil
	case business.FieldFlowVariables:
		m.ResetFlowVariables()
		return nil
	case business.FieldIsDraft:
		m.ResetIsDraft()
		return nil
	case business.FieldIsTerminated:
		m.ResetIsTerminated()
		return nil
	case business.FieldIsSuspended:
		m.ResetIsSuspended()
		return nil
	case business.FieldSuspendReason:
		m.ResetSuspendReason()
		return nil
	case business.FieldBusinessTags:
		m.ResetBusinessTags()
		return nil
	case business.FieldModuleCode:
		m.ResetModuleCode()
		return nil
	case business.FieldCategory:
		m.ResetCategory()
		return nil
	case business.FieldViewers:
		m.ResetViewers()
		return nil
	case business.FieldEditors:
		m.ResetEditors()
		return nil
	case business.FieldPermissionConfigs:
		m.ResetPermissionConfigs()
		return nil
	case business.FieldRoleConfigs:
		m.ResetRoleConfigs()
		return nil
	case business.FieldVisibleRange:
		m.ResetVisibleRange()
		return nil
	case business.FieldExtras:
		m.ResetExtras()
		return nil
	case business.FieldTenantID:
		m.ResetTenantID()
		return nil
	case business.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case business.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case business.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case business.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Business unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Business edge %s", name)
}

// DelegationMutation represents an operation that mutates the Delegation nodes in the graph.
type DelegationMutation struct {
	config
	op               Op
	typ              string
	id               *string
	status           *string
	extras           *map[string]interface{}
	tenant_id        *string
	created_by       *string
	updated_by       *string
	created_at       *int64
	addcreated_at    *int64
	updated_at       *int64
	addupdated_at    *int64
	delegator_id     *string
	delegatee_id     *string
	template_id      *string
	node_type        *string
	conditions       *[]string
	appendconditions []string
	start_time       *int64
	addstart_time    *int64
	end_time         *int64
	addend_time      *int64
	is_enabled       *bool
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Delegation, error)
	predicates       []predicate.Delegation
}

var _ ent.Mutation = (*DelegationMutation)(nil)

// delegationOption allows management of the mutation configuration using functional options.
type delegationOption func(*DelegationMutation)

// newDelegationMutation creates new mutation for the Delegation entity.
func newDelegationMutation(c config, op Op, opts ...delegationOption) *DelegationMutation {
	m := &DelegationMutation{
		config:        c,
		op:            op,
		typ:           TypeDelegation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDelegationID sets the ID field of the mutation.
func withDelegationID(id string) delegationOption {
	return func(m *DelegationMutation) {
		var (
			err   error
			once  sync.Once
			value *Delegation
		)
		m.oldValue = func(ctx context.Context) (*Delegation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Delegation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDelegation sets the old Delegation of the mutation.
func withDelegation(node *Delegation) delegationOption {
	return func(m *DelegationMutation) {
		m.oldValue = func(context.Context) (*Delegation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DelegationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DelegationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Delegation entities.
func (m *DelegationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DelegationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DelegationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Delegation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *DelegationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *DelegationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *DelegationMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[delegation.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DelegationMutation) StatusCleared() bool {
	_, ok := m.clearedFields[delegation.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DelegationMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, delegation.FieldStatus)
}

// SetExtras sets the "extras" field.
func (m *DelegationMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *DelegationMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *DelegationMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[delegation.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *DelegationMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[delegation.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *DelegationMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, delegation.FieldExtras)
}

// SetTenantID sets the "tenant_id" field.
func (m *DelegationMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DelegationMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *DelegationMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[delegation.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *DelegationMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[delegation.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DelegationMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, delegation.FieldTenantID)
}

// SetCreatedBy sets the "created_by" field.
func (m *DelegationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DelegationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DelegationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[delegation.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DelegationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[delegation.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DelegationMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, delegation.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DelegationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DelegationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DelegationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[delegation.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DelegationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[delegation.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DelegationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, delegation.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *DelegationMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DelegationMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *DelegationMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *DelegationMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DelegationMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[delegation.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DelegationMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[delegation.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DelegationMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, delegation.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DelegationMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DelegationMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *DelegationMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *DelegationMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DelegationMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[delegation.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DelegationMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[delegation.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DelegationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, delegation.FieldUpdatedAt)
}

// SetDelegatorID sets the "delegator_id" field.
func (m *DelegationMutation) SetDelegatorID(s string) {
	m.delegator_id = &s
}

// DelegatorID returns the value of the "delegator_id" field in the mutation.
func (m *DelegationMutation) DelegatorID() (r string, exists bool) {
	v := m.delegator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegatorID returns the old "delegator_id" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldDelegatorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegatorID: %w", err)
	}
	return oldValue.DelegatorID, nil
}

// ResetDelegatorID resets all changes to the "delegator_id" field.
func (m *DelegationMutation) ResetDelegatorID() {
	m.delegator_id = nil
}

// SetDelegateeID sets the "delegatee_id" field.
func (m *DelegationMutation) SetDelegateeID(s string) {
	m.delegatee_id = &s
}

// DelegateeID returns the value of the "delegatee_id" field in the mutation.
func (m *DelegationMutation) DelegateeID() (r string, exists bool) {
	v := m.delegatee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegateeID returns the old "delegatee_id" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldDelegateeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegateeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegateeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegateeID: %w", err)
	}
	return oldValue.DelegateeID, nil
}

// ResetDelegateeID resets all changes to the "delegatee_id" field.
func (m *DelegationMutation) ResetDelegateeID() {
	m.delegatee_id = nil
}

// SetTemplateID sets the "template_id" field.
func (m *DelegationMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *DelegationMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ClearTemplateID clears the value of the "template_id" field.
func (m *DelegationMutation) ClearTemplateID() {
	m.template_id = nil
	m.clearedFields[delegation.FieldTemplateID] = struct{}{}
}

// TemplateIDCleared returns if the "template_id" field was cleared in this mutation.
func (m *DelegationMutation) TemplateIDCleared() bool {
	_, ok := m.clearedFields[delegation.FieldTemplateID]
	return ok
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *DelegationMutation) ResetTemplateID() {
	m.template_id = nil
	delete(m.clearedFields, delegation.FieldTemplateID)
}

// SetNodeType sets the "node_type" field.
func (m *DelegationMutation) SetNodeType(s string) {
	m.node_type = &s
}

// NodeType returns the value of the "node_type" field in the mutation.
func (m *DelegationMutation) NodeType() (r string, exists bool) {
	v := m.node_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeType returns the old "node_type" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldNodeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeType: %w", err)
	}
	return oldValue.NodeType, nil
}

// ClearNodeType clears the value of the "node_type" field.
func (m *DelegationMutation) ClearNodeType() {
	m.node_type = nil
	m.clearedFields[delegation.FieldNodeType] = struct{}{}
}

// NodeTypeCleared returns if the "node_type" field was cleared in this mutation.
func (m *DelegationMutation) NodeTypeCleared() bool {
	_, ok := m.clearedFields[delegation.FieldNodeType]
	return ok
}

// ResetNodeType resets all changes to the "node_type" field.
func (m *DelegationMutation) ResetNodeType() {
	m.node_type = nil
	delete(m.clearedFields, delegation.FieldNodeType)
}

// SetConditions sets the "conditions" field.
func (m *DelegationMutation) SetConditions(s []string) {
	m.conditions = &s
	m.appendconditions = nil
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *DelegationMutation) Conditions() (r []string, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldConditions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// AppendConditions adds s to the "conditions" field.
func (m *DelegationMutation) AppendConditions(s []string) {
	m.appendconditions = append(m.appendconditions, s...)
}

// AppendedConditions returns the list of values that were appended to the "conditions" field in this mutation.
func (m *DelegationMutation) AppendedConditions() ([]string, bool) {
	if len(m.appendconditions) == 0 {
		return nil, false
	}
	return m.appendconditions, true
}

// ClearConditions clears the value of the "conditions" field.
func (m *DelegationMutation) ClearConditions() {
	m.conditions = nil
	m.appendconditions = nil
	m.clearedFields[delegation.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *DelegationMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[delegation.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *DelegationMutation) ResetConditions() {
	m.conditions = nil
	m.appendconditions = nil
	delete(m.clearedFields, delegation.FieldConditions)
}

// SetStartTime sets the "start_time" field.
func (m *DelegationMutation) SetStartTime(i int64) {
	m.start_time = &i
	m.addstart_time = nil
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *DelegationMutation) StartTime() (r int64, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldStartTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// AddStartTime adds i to the "start_time" field.
func (m *DelegationMutation) AddStartTime(i int64) {
	if m.addstart_time != nil {
		*m.addstart_time += i
	} else {
		m.addstart_time = &i
	}
}

// AddedStartTime returns the value that was added to the "start_time" field in this mutation.
func (m *DelegationMutation) AddedStartTime() (r int64, exists bool) {
	v := m.addstart_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *DelegationMutation) ResetStartTime() {
	m.start_time = nil
	m.addstart_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *DelegationMutation) SetEndTime(i int64) {
	m.end_time = &i
	m.addend_time = nil
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *DelegationMutation) EndTime() (r int64, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldEndTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// AddEndTime adds i to the "end_time" field.
func (m *DelegationMutation) AddEndTime(i int64) {
	if m.addend_time != nil {
		*m.addend_time += i
	} else {
		m.addend_time = &i
	}
}

// AddedEndTime returns the value that was added to the "end_time" field in this mutation.
func (m *DelegationMutation) AddedEndTime() (r int64, exists bool) {
	v := m.addend_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *DelegationMutation) ResetEndTime() {
	m.end_time = nil
	m.addend_time = nil
}

// SetIsEnabled sets the "is_enabled" field.
func (m *DelegationMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *DelegationMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the Delegation entity.
// If the Delegation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegationMutation) OldIsEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *DelegationMutation) ResetIsEnabled() {
	m.is_enabled = nil
}

// Where appends a list predicates to the DelegationMutation builder.
func (m *DelegationMutation) Where(ps ...predicate.Delegation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DelegationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DelegationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Delegation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DelegationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DelegationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Delegation).
func (m *DelegationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DelegationMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.status != nil {
		fields = append(fields, delegation.FieldStatus)
	}
	if m.extras != nil {
		fields = append(fields, delegation.FieldExtras)
	}
	if m.tenant_id != nil {
		fields = append(fields, delegation.FieldTenantID)
	}
	if m.created_by != nil {
		fields = append(fields, delegation.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, delegation.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, delegation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, delegation.FieldUpdatedAt)
	}
	if m.delegator_id != nil {
		fields = append(fields, delegation.FieldDelegatorID)
	}
	if m.delegatee_id != nil {
		fields = append(fields, delegation.FieldDelegateeID)
	}
	if m.template_id != nil {
		fields = append(fields, delegation.FieldTemplateID)
	}
	if m.node_type != nil {
		fields = append(fields, delegation.FieldNodeType)
	}
	if m.conditions != nil {
		fields = append(fields, delegation.FieldConditions)
	}
	if m.start_time != nil {
		fields = append(fields, delegation.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, delegation.FieldEndTime)
	}
	if m.is_enabled != nil {
		fields = append(fields, delegation.FieldIsEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DelegationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case delegation.FieldStatus:
		return m.Status()
	case delegation.FieldExtras:
		return m.Extras()
	case delegation.FieldTenantID:
		return m.TenantID()
	case delegation.FieldCreatedBy:
		return m.CreatedBy()
	case delegation.FieldUpdatedBy:
		return m.UpdatedBy()
	case delegation.FieldCreatedAt:
		return m.CreatedAt()
	case delegation.FieldUpdatedAt:
		return m.UpdatedAt()
	case delegation.FieldDelegatorID:
		return m.DelegatorID()
	case delegation.FieldDelegateeID:
		return m.DelegateeID()
	case delegation.FieldTemplateID:
		return m.TemplateID()
	case delegation.FieldNodeType:
		return m.NodeType()
	case delegation.FieldConditions:
		return m.Conditions()
	case delegation.FieldStartTime:
		return m.StartTime()
	case delegation.FieldEndTime:
		return m.EndTime()
	case delegation.FieldIsEnabled:
		return m.IsEnabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DelegationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case delegation.FieldStatus:
		return m.OldStatus(ctx)
	case delegation.FieldExtras:
		return m.OldExtras(ctx)
	case delegation.FieldTenantID:
		return m.OldTenantID(ctx)
	case delegation.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case delegation.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case delegation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case delegation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case delegation.FieldDelegatorID:
		return m.OldDelegatorID(ctx)
	case delegation.FieldDelegateeID:
		return m.OldDelegateeID(ctx)
	case delegation.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case delegation.FieldNodeType:
		return m.OldNodeType(ctx)
	case delegation.FieldConditions:
		return m.OldConditions(ctx)
	case delegation.FieldStartTime:
		return m.OldStartTime(ctx)
	case delegation.FieldEndTime:
		return m.OldEndTime(ctx)
	case delegation.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown Delegation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DelegationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case delegation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case delegation.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case delegation.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case delegation.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case delegation.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case delegation.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case delegation.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case delegation.FieldDelegatorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegatorID(v)
		return nil
	case delegation.FieldDelegateeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegateeID(v)
		return nil
	case delegation.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case delegation.FieldNodeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeType(v)
		return nil
	case delegation.FieldConditions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case delegation.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case delegation.FieldEndTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case delegation.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown Delegation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DelegationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, delegation.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, delegation.FieldUpdatedAt)
	}
	if m.addstart_time != nil {
		fields = append(fields, delegation.FieldStartTime)
	}
	if m.addend_time != nil {
		fields = append(fields, delegation.FieldEndTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DelegationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case delegation.FieldCreatedAt:
		return m.AddedCreatedAt()
	case delegation.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case delegation.FieldStartTime:
		return m.AddedStartTime()
	case delegation.FieldEndTime:
		return m.AddedEndTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DelegationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case delegation.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case delegation.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case delegation.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTime(v)
		return nil
	case delegation.FieldEndTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown Delegation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DelegationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(delegation.FieldStatus) {
		fields = append(fields, delegation.FieldStatus)
	}
	if m.FieldCleared(delegation.FieldExtras) {
		fields = append(fields, delegation.FieldExtras)
	}
	if m.FieldCleared(delegation.FieldTenantID) {
		fields = append(fields, delegation.FieldTenantID)
	}
	if m.FieldCleared(delegation.FieldCreatedBy) {
		fields = append(fields, delegation.FieldCreatedBy)
	}
	if m.FieldCleared(delegation.FieldUpdatedBy) {
		fields = append(fields, delegation.FieldUpdatedBy)
	}
	if m.FieldCleared(delegation.FieldCreatedAt) {
		fields = append(fields, delegation.FieldCreatedAt)
	}
	if m.FieldCleared(delegation.FieldUpdatedAt) {
		fields = append(fields, delegation.FieldUpdatedAt)
	}
	if m.FieldCleared(delegation.FieldTemplateID) {
		fields = append(fields, delegation.FieldTemplateID)
	}
	if m.FieldCleared(delegation.FieldNodeType) {
		fields = append(fields, delegation.FieldNodeType)
	}
	if m.FieldCleared(delegation.FieldConditions) {
		fields = append(fields, delegation.FieldConditions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DelegationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DelegationMutation) ClearField(name string) error {
	switch name {
	case delegation.FieldStatus:
		m.ClearStatus()
		return nil
	case delegation.FieldExtras:
		m.ClearExtras()
		return nil
	case delegation.FieldTenantID:
		m.ClearTenantID()
		return nil
	case delegation.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case delegation.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case delegation.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case delegation.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case delegation.FieldTemplateID:
		m.ClearTemplateID()
		return nil
	case delegation.FieldNodeType:
		m.ClearNodeType()
		return nil
	case delegation.FieldConditions:
		m.ClearConditions()
		return nil
	}
	return fmt.Errorf("unknown Delegation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DelegationMutation) ResetField(name string) error {
	switch name {
	case delegation.FieldStatus:
		m.ResetStatus()
		return nil
	case delegation.FieldExtras:
		m.ResetExtras()
		return nil
	case delegation.FieldTenantID:
		m.ResetTenantID()
		return nil
	case delegation.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case delegation.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case delegation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case delegation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case delegation.FieldDelegatorID:
		m.ResetDelegatorID()
		return nil
	case delegation.FieldDelegateeID:
		m.ResetDelegateeID()
		return nil
	case delegation.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case delegation.FieldNodeType:
		m.ResetNodeType()
		return nil
	case delegation.FieldConditions:
		m.ResetConditions()
		return nil
	case delegation.FieldStartTime:
		m.ResetStartTime()
		return nil
	case delegation.FieldEndTime:
		m.ResetEndTime()
		return nil
	case delegation.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	}
	return fmt.Errorf("unknown Delegation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DelegationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DelegationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DelegationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DelegationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DelegationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DelegationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DelegationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Delegation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DelegationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Delegation edge %s", name)
}

// HistoryMutation represents an operation that mutates the History nodes in the graph.
type HistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	_type         *string
	process_id    *string
	template_id   *string
	business_key  *string
	node_key      *string
	node_type     *string
	node_config   *map[string]interface{}
	node_rules    *map[string]interface{}
	node_events   *map[string]interface{}
	tenant_id     *string
	created_by    *string
	updated_by    *string
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	node_name     *string
	operator      *string
	operator_dept *string
	task_id       *string
	variables     *map[string]interface{}
	form_data     *map[string]interface{}
	action        *string
	comment       *string
	details       *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*History, error)
	predicates    []predicate.History
}

var _ ent.Mutation = (*HistoryMutation)(nil)

// historyOption allows management of the mutation configuration using functional options.
type historyOption func(*HistoryMutation)

// newHistoryMutation creates new mutation for the History entity.
func newHistoryMutation(c config, op Op, opts ...historyOption) *HistoryMutation {
	m := &HistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHistoryID sets the ID field of the mutation.
func withHistoryID(id string) historyOption {
	return func(m *HistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *History
		)
		m.oldValue = func(ctx context.Context) (*History, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().History.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHistory sets the old History of the mutation.
func withHistory(node *History) historyOption {
	return func(m *HistoryMutation) {
		m.oldValue = func(context.Context) (*History, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of History entities.
func (m *HistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().History.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *HistoryMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *HistoryMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *HistoryMutation) ClearType() {
	m._type = nil
	m.clearedFields[history.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *HistoryMutation) TypeCleared() bool {
	_, ok := m.clearedFields[history.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *HistoryMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, history.FieldType)
}

// SetProcessID sets the "process_id" field.
func (m *HistoryMutation) SetProcessID(s string) {
	m.process_id = &s
}

// ProcessID returns the value of the "process_id" field in the mutation.
func (m *HistoryMutation) ProcessID() (r string, exists bool) {
	v := m.process_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessID returns the old "process_id" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldProcessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessID: %w", err)
	}
	return oldValue.ProcessID, nil
}

// ResetProcessID resets all changes to the "process_id" field.
func (m *HistoryMutation) ResetProcessID() {
	m.process_id = nil
}

// SetTemplateID sets the "template_id" field.
func (m *HistoryMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *HistoryMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *HistoryMutation) ResetTemplateID() {
	m.template_id = nil
}

// SetBusinessKey sets the "business_key" field.
func (m *HistoryMutation) SetBusinessKey(s string) {
	m.business_key = &s
}

// BusinessKey returns the value of the "business_key" field in the mutation.
func (m *HistoryMutation) BusinessKey() (r string, exists bool) {
	v := m.business_key
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessKey returns the old "business_key" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldBusinessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessKey: %w", err)
	}
	return oldValue.BusinessKey, nil
}

// ResetBusinessKey resets all changes to the "business_key" field.
func (m *HistoryMutation) ResetBusinessKey() {
	m.business_key = nil
}

// SetNodeKey sets the "node_key" field.
func (m *HistoryMutation) SetNodeKey(s string) {
	m.node_key = &s
}

// NodeKey returns the value of the "node_key" field in the mutation.
func (m *HistoryMutation) NodeKey() (r string, exists bool) {
	v := m.node_key
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeKey returns the old "node_key" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldNodeKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeKey: %w", err)
	}
	return oldValue.NodeKey, nil
}

// ResetNodeKey resets all changes to the "node_key" field.
func (m *HistoryMutation) ResetNodeKey() {
	m.node_key = nil
}

// SetNodeType sets the "node_type" field.
func (m *HistoryMutation) SetNodeType(s string) {
	m.node_type = &s
}

// NodeType returns the value of the "node_type" field in the mutation.
func (m *HistoryMutation) NodeType() (r string, exists bool) {
	v := m.node_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeType returns the old "node_type" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldNodeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeType: %w", err)
	}
	return oldValue.NodeType, nil
}

// ResetNodeType resets all changes to the "node_type" field.
func (m *HistoryMutation) ResetNodeType() {
	m.node_type = nil
}

// SetNodeConfig sets the "node_config" field.
func (m *HistoryMutation) SetNodeConfig(value map[string]interface{}) {
	m.node_config = &value
}

// NodeConfig returns the value of the "node_config" field in the mutation.
func (m *HistoryMutation) NodeConfig() (r map[string]interface{}, exists bool) {
	v := m.node_config
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeConfig returns the old "node_config" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldNodeConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeConfig: %w", err)
	}
	return oldValue.NodeConfig, nil
}

// ClearNodeConfig clears the value of the "node_config" field.
func (m *HistoryMutation) ClearNodeConfig() {
	m.node_config = nil
	m.clearedFields[history.FieldNodeConfig] = struct{}{}
}

// NodeConfigCleared returns if the "node_config" field was cleared in this mutation.
func (m *HistoryMutation) NodeConfigCleared() bool {
	_, ok := m.clearedFields[history.FieldNodeConfig]
	return ok
}

// ResetNodeConfig resets all changes to the "node_config" field.
func (m *HistoryMutation) ResetNodeConfig() {
	m.node_config = nil
	delete(m.clearedFields, history.FieldNodeConfig)
}

// SetNodeRules sets the "node_rules" field.
func (m *HistoryMutation) SetNodeRules(value map[string]interface{}) {
	m.node_rules = &value
}

// NodeRules returns the value of the "node_rules" field in the mutation.
func (m *HistoryMutation) NodeRules() (r map[string]interface{}, exists bool) {
	v := m.node_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeRules returns the old "node_rules" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldNodeRules(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeRules: %w", err)
	}
	return oldValue.NodeRules, nil
}

// ClearNodeRules clears the value of the "node_rules" field.
func (m *HistoryMutation) ClearNodeRules() {
	m.node_rules = nil
	m.clearedFields[history.FieldNodeRules] = struct{}{}
}

// NodeRulesCleared returns if the "node_rules" field was cleared in this mutation.
func (m *HistoryMutation) NodeRulesCleared() bool {
	_, ok := m.clearedFields[history.FieldNodeRules]
	return ok
}

// ResetNodeRules resets all changes to the "node_rules" field.
func (m *HistoryMutation) ResetNodeRules() {
	m.node_rules = nil
	delete(m.clearedFields, history.FieldNodeRules)
}

// SetNodeEvents sets the "node_events" field.
func (m *HistoryMutation) SetNodeEvents(value map[string]interface{}) {
	m.node_events = &value
}

// NodeEvents returns the value of the "node_events" field in the mutation.
func (m *HistoryMutation) NodeEvents() (r map[string]interface{}, exists bool) {
	v := m.node_events
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeEvents returns the old "node_events" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldNodeEvents(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeEvents: %w", err)
	}
	return oldValue.NodeEvents, nil
}

// ClearNodeEvents clears the value of the "node_events" field.
func (m *HistoryMutation) ClearNodeEvents() {
	m.node_events = nil
	m.clearedFields[history.FieldNodeEvents] = struct{}{}
}

// NodeEventsCleared returns if the "node_events" field was cleared in this mutation.
func (m *HistoryMutation) NodeEventsCleared() bool {
	_, ok := m.clearedFields[history.FieldNodeEvents]
	return ok
}

// ResetNodeEvents resets all changes to the "node_events" field.
func (m *HistoryMutation) ResetNodeEvents() {
	m.node_events = nil
	delete(m.clearedFields, history.FieldNodeEvents)
}

// SetTenantID sets the "tenant_id" field.
func (m *HistoryMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *HistoryMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *HistoryMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[history.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *HistoryMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[history.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *HistoryMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, history.FieldTenantID)
}

// SetCreatedBy sets the "created_by" field.
func (m *HistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *HistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[history.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *HistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[history.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, history.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *HistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *HistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *HistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[history.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *HistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[history.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *HistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, history.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *HistoryMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HistoryMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *HistoryMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *HistoryMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[history.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[history.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, history.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HistoryMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HistoryMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *HistoryMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *HistoryMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[history.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[history.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, history.FieldUpdatedAt)
}

// SetNodeName sets the "node_name" field.
func (m *HistoryMutation) SetNodeName(s string) {
	m.node_name = &s
}

// NodeName returns the value of the "node_name" field in the mutation.
func (m *HistoryMutation) NodeName() (r string, exists bool) {
	v := m.node_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeName returns the old "node_name" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldNodeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeName: %w", err)
	}
	return oldValue.NodeName, nil
}

// ResetNodeName resets all changes to the "node_name" field.
func (m *HistoryMutation) ResetNodeName() {
	m.node_name = nil
}

// SetOperator sets the "operator" field.
func (m *HistoryMutation) SetOperator(s string) {
	m.operator = &s
}

// Operator returns the value of the "operator" field in the mutation.
func (m *HistoryMutation) Operator() (r string, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOperator returns the old "operator" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldOperator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperator: %w", err)
	}
	return oldValue.Operator, nil
}

// ResetOperator resets all changes to the "operator" field.
func (m *HistoryMutation) ResetOperator() {
	m.operator = nil
}

// SetOperatorDept sets the "operator_dept" field.
func (m *HistoryMutation) SetOperatorDept(s string) {
	m.operator_dept = &s
}

// OperatorDept returns the value of the "operator_dept" field in the mutation.
func (m *HistoryMutation) OperatorDept() (r string, exists bool) {
	v := m.operator_dept
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorDept returns the old "operator_dept" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldOperatorDept(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorDept is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorDept requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorDept: %w", err)
	}
	return oldValue.OperatorDept, nil
}

// ClearOperatorDept clears the value of the "operator_dept" field.
func (m *HistoryMutation) ClearOperatorDept() {
	m.operator_dept = nil
	m.clearedFields[history.FieldOperatorDept] = struct{}{}
}

// OperatorDeptCleared returns if the "operator_dept" field was cleared in this mutation.
func (m *HistoryMutation) OperatorDeptCleared() bool {
	_, ok := m.clearedFields[history.FieldOperatorDept]
	return ok
}

// ResetOperatorDept resets all changes to the "operator_dept" field.
func (m *HistoryMutation) ResetOperatorDept() {
	m.operator_dept = nil
	delete(m.clearedFields, history.FieldOperatorDept)
}

// SetTaskID sets the "task_id" field.
func (m *HistoryMutation) SetTaskID(s string) {
	m.task_id = &s
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *HistoryMutation) TaskID() (r string, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ClearTaskID clears the value of the "task_id" field.
func (m *HistoryMutation) ClearTaskID() {
	m.task_id = nil
	m.clearedFields[history.FieldTaskID] = struct{}{}
}

// TaskIDCleared returns if the "task_id" field was cleared in this mutation.
func (m *HistoryMutation) TaskIDCleared() bool {
	_, ok := m.clearedFields[history.FieldTaskID]
	return ok
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *HistoryMutation) ResetTaskID() {
	m.task_id = nil
	delete(m.clearedFields, history.FieldTaskID)
}

// SetVariables sets the "variables" field.
func (m *HistoryMutation) SetVariables(value map[string]interface{}) {
	m.variables = &value
}

// Variables returns the value of the "variables" field in the mutation.
func (m *HistoryMutation) Variables() (r map[string]interface{}, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ResetVariables resets all changes to the "variables" field.
func (m *HistoryMutation) ResetVariables() {
	m.variables = nil
}

// SetFormData sets the "form_data" field.
func (m *HistoryMutation) SetFormData(value map[string]interface{}) {
	m.form_data = &value
}

// FormData returns the value of the "form_data" field in the mutation.
func (m *HistoryMutation) FormData() (r map[string]interface{}, exists bool) {
	v := m.form_data
	if v == nil {
		return
	}
	return *v, true
}

// OldFormData returns the old "form_data" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldFormData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormData: %w", err)
	}
	return oldValue.FormData, nil
}

// ClearFormData clears the value of the "form_data" field.
func (m *HistoryMutation) ClearFormData() {
	m.form_data = nil
	m.clearedFields[history.FieldFormData] = struct{}{}
}

// FormDataCleared returns if the "form_data" field was cleared in this mutation.
func (m *HistoryMutation) FormDataCleared() bool {
	_, ok := m.clearedFields[history.FieldFormData]
	return ok
}

// ResetFormData resets all changes to the "form_data" field.
func (m *HistoryMutation) ResetFormData() {
	m.form_data = nil
	delete(m.clearedFields, history.FieldFormData)
}

// SetAction sets the "action" field.
func (m *HistoryMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *HistoryMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *HistoryMutation) ResetAction() {
	m.action = nil
}

// SetComment sets the "comment" field.
func (m *HistoryMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *HistoryMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *HistoryMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[history.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *HistoryMutation) CommentCleared() bool {
	_, ok := m.clearedFields[history.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *HistoryMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, history.FieldComment)
}

// SetDetails sets the "details" field.
func (m *HistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *HistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *HistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[history.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *HistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[history.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *HistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, history.FieldDetails)
}

// Where appends a list predicates to the HistoryMutation builder.
func (m *HistoryMutation) Where(ps ...predicate.History) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.History, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (History).
func (m *HistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HistoryMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m._type != nil {
		fields = append(fields, history.FieldType)
	}
	if m.process_id != nil {
		fields = append(fields, history.FieldProcessID)
	}
	if m.template_id != nil {
		fields = append(fields, history.FieldTemplateID)
	}
	if m.business_key != nil {
		fields = append(fields, history.FieldBusinessKey)
	}
	if m.node_key != nil {
		fields = append(fields, history.FieldNodeKey)
	}
	if m.node_type != nil {
		fields = append(fields, history.FieldNodeType)
	}
	if m.node_config != nil {
		fields = append(fields, history.FieldNodeConfig)
	}
	if m.node_rules != nil {
		fields = append(fields, history.FieldNodeRules)
	}
	if m.node_events != nil {
		fields = append(fields, history.FieldNodeEvents)
	}
	if m.tenant_id != nil {
		fields = append(fields, history.FieldTenantID)
	}
	if m.created_by != nil {
		fields = append(fields, history.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, history.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, history.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, history.FieldUpdatedAt)
	}
	if m.node_name != nil {
		fields = append(fields, history.FieldNodeName)
	}
	if m.operator != nil {
		fields = append(fields, history.FieldOperator)
	}
	if m.operator_dept != nil {
		fields = append(fields, history.FieldOperatorDept)
	}
	if m.task_id != nil {
		fields = append(fields, history.FieldTaskID)
	}
	if m.variables != nil {
		fields = append(fields, history.FieldVariables)
	}
	if m.form_data != nil {
		fields = append(fields, history.FieldFormData)
	}
	if m.action != nil {
		fields = append(fields, history.FieldAction)
	}
	if m.comment != nil {
		fields = append(fields, history.FieldComment)
	}
	if m.details != nil {
		fields = append(fields, history.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case history.FieldType:
		return m.GetType()
	case history.FieldProcessID:
		return m.ProcessID()
	case history.FieldTemplateID:
		return m.TemplateID()
	case history.FieldBusinessKey:
		return m.BusinessKey()
	case history.FieldNodeKey:
		return m.NodeKey()
	case history.FieldNodeType:
		return m.NodeType()
	case history.FieldNodeConfig:
		return m.NodeConfig()
	case history.FieldNodeRules:
		return m.NodeRules()
	case history.FieldNodeEvents:
		return m.NodeEvents()
	case history.FieldTenantID:
		return m.TenantID()
	case history.FieldCreatedBy:
		return m.CreatedBy()
	case history.FieldUpdatedBy:
		return m.UpdatedBy()
	case history.FieldCreatedAt:
		return m.CreatedAt()
	case history.FieldUpdatedAt:
		return m.UpdatedAt()
	case history.FieldNodeName:
		return m.NodeName()
	case history.FieldOperator:
		return m.Operator()
	case history.FieldOperatorDept:
		return m.OperatorDept()
	case history.FieldTaskID:
		return m.TaskID()
	case history.FieldVariables:
		return m.Variables()
	case history.FieldFormData:
		return m.FormData()
	case history.FieldAction:
		return m.Action()
	case history.FieldComment:
		return m.Comment()
	case history.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case history.FieldType:
		return m.OldType(ctx)
	case history.FieldProcessID:
		return m.OldProcessID(ctx)
	case history.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case history.FieldBusinessKey:
		return m.OldBusinessKey(ctx)
	case history.FieldNodeKey:
		return m.OldNodeKey(ctx)
	case history.FieldNodeType:
		return m.OldNodeType(ctx)
	case history.FieldNodeConfig:
		return m.OldNodeConfig(ctx)
	case history.FieldNodeRules:
		return m.OldNodeRules(ctx)
	case history.FieldNodeEvents:
		return m.OldNodeEvents(ctx)
	case history.FieldTenantID:
		return m.OldTenantID(ctx)
	case history.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case history.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case history.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case history.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case history.FieldNodeName:
		return m.OldNodeName(ctx)
	case history.FieldOperator:
		return m.OldOperator(ctx)
	case history.FieldOperatorDept:
		return m.OldOperatorDept(ctx)
	case history.FieldTaskID:
		return m.OldTaskID(ctx)
	case history.FieldVariables:
		return m.OldVariables(ctx)
	case history.FieldFormData:
		return m.OldFormData(ctx)
	case history.FieldAction:
		return m.OldAction(ctx)
	case history.FieldComment:
		return m.OldComment(ctx)
	case history.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown History field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case history.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case history.FieldProcessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessID(v)
		return nil
	case history.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case history.FieldBusinessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessKey(v)
		return nil
	case history.FieldNodeKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeKey(v)
		return nil
	case history.FieldNodeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeType(v)
		return nil
	case history.FieldNodeConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeConfig(v)
		return nil
	case history.FieldNodeRules:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeRules(v)
		return nil
	case history.FieldNodeEvents:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeEvents(v)
		return nil
	case history.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case history.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case history.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case history.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case history.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case history.FieldNodeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeName(v)
		return nil
	case history.FieldOperator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperator(v)
		return nil
	case history.FieldOperatorDept:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorDept(v)
		return nil
	case history.FieldTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case history.FieldVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case history.FieldFormData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormData(v)
		return nil
	case history.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case history.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case history.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown History field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HistoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, history.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, history.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case history.FieldCreatedAt:
		return m.AddedCreatedAt()
	case history.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case history.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case history.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown History numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(history.FieldType) {
		fields = append(fields, history.FieldType)
	}
	if m.FieldCleared(history.FieldNodeConfig) {
		fields = append(fields, history.FieldNodeConfig)
	}
	if m.FieldCleared(history.FieldNodeRules) {
		fields = append(fields, history.FieldNodeRules)
	}
	if m.FieldCleared(history.FieldNodeEvents) {
		fields = append(fields, history.FieldNodeEvents)
	}
	if m.FieldCleared(history.FieldTenantID) {
		fields = append(fields, history.FieldTenantID)
	}
	if m.FieldCleared(history.FieldCreatedBy) {
		fields = append(fields, history.FieldCreatedBy)
	}
	if m.FieldCleared(history.FieldUpdatedBy) {
		fields = append(fields, history.FieldUpdatedBy)
	}
	if m.FieldCleared(history.FieldCreatedAt) {
		fields = append(fields, history.FieldCreatedAt)
	}
	if m.FieldCleared(history.FieldUpdatedAt) {
		fields = append(fields, history.FieldUpdatedAt)
	}
	if m.FieldCleared(history.FieldOperatorDept) {
		fields = append(fields, history.FieldOperatorDept)
	}
	if m.FieldCleared(history.FieldTaskID) {
		fields = append(fields, history.FieldTaskID)
	}
	if m.FieldCleared(history.FieldFormData) {
		fields = append(fields, history.FieldFormData)
	}
	if m.FieldCleared(history.FieldComment) {
		fields = append(fields, history.FieldComment)
	}
	if m.FieldCleared(history.FieldDetails) {
		fields = append(fields, history.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HistoryMutation) ClearField(name string) error {
	switch name {
	case history.FieldType:
		m.ClearType()
		return nil
	case history.FieldNodeConfig:
		m.ClearNodeConfig()
		return nil
	case history.FieldNodeRules:
		m.ClearNodeRules()
		return nil
	case history.FieldNodeEvents:
		m.ClearNodeEvents()
		return nil
	case history.FieldTenantID:
		m.ClearTenantID()
		return nil
	case history.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case history.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case history.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case history.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case history.FieldOperatorDept:
		m.ClearOperatorDept()
		return nil
	case history.FieldTaskID:
		m.ClearTaskID()
		return nil
	case history.FieldFormData:
		m.ClearFormData()
		return nil
	case history.FieldComment:
		m.ClearComment()
		return nil
	case history.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown History nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HistoryMutation) ResetField(name string) error {
	switch name {
	case history.FieldType:
		m.ResetType()
		return nil
	case history.FieldProcessID:
		m.ResetProcessID()
		return nil
	case history.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case history.FieldBusinessKey:
		m.ResetBusinessKey()
		return nil
	case history.FieldNodeKey:
		m.ResetNodeKey()
		return nil
	case history.FieldNodeType:
		m.ResetNodeType()
		return nil
	case history.FieldNodeConfig:
		m.ResetNodeConfig()
		return nil
	case history.FieldNodeRules:
		m.ResetNodeRules()
		return nil
	case history.FieldNodeEvents:
		m.ResetNodeEvents()
		return nil
	case history.FieldTenantID:
		m.ResetTenantID()
		return nil
	case history.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case history.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case history.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case history.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case history.FieldNodeName:
		m.ResetNodeName()
		return nil
	case history.FieldOperator:
		m.ResetOperator()
		return nil
	case history.FieldOperatorDept:
		m.ResetOperatorDept()
		return nil
	case history.FieldTaskID:
		m.ResetTaskID()
		return nil
	case history.FieldVariables:
		m.ResetVariables()
		return nil
	case history.FieldFormData:
		m.ResetFormData()
		return nil
	case history.FieldAction:
		m.ResetAction()
		return nil
	case history.FieldComment:
		m.ResetComment()
		return nil
	case history.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown History field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown History unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown History edge %s", name)
}

// NodeMutation represents an operation that mutates the Node nodes in the graph.
type NodeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	name                 *string
	description          *string
	_type                *string
	status               *string
	node_key             *string
	node_type            *string
	node_config          *map[string]interface{}
	node_rules           *map[string]interface{}
	node_events          *map[string]interface{}
	form_code            *string
	form_version         *string
	form_config          *map[string]interface{}
	form_permissions     *map[string]interface{}
	field_permissions    *map[string]interface{}
	assignees            *[]string
	appendassignees      []string
	candidates           *[]string
	appendcandidates     []string
	delegated_from       *string
	delegated_reason     *string
	is_delegated         *bool
	is_transferred       *bool
	allow_cancel         *bool
	allow_urge           *bool
	allow_delegate       *bool
	allow_transfer       *bool
	is_draft_enabled     *bool
	is_auto_start        *bool
	strict_mode          *bool
	start_time           *int64
	addstart_time        *int64
	end_time             *int64
	addend_time          *int64
	due_time             *int64
	adddue_time          *int64
	duration             *int
	addduration          *int
	priority             *int
	addpriority          *int
	is_timeout           *bool
	reminder_count       *int
	addreminder_count    *int
	extras               *map[string]interface{}
	tenant_id            *string
	created_by           *string
	updated_by           *string
	created_at           *int64
	addcreated_at        *int64
	updated_at           *int64
	addupdated_at        *int64
	process_id           *string
	permissions          *map[string]interface{}
	prev_nodes           *[]string
	appendprev_nodes     []string
	next_nodes           *[]string
	appendnext_nodes     []string
	parallel_nodes       *[]string
	appendparallel_nodes []string
	branch_nodes         *[]string
	appendbranch_nodes   []string
	conditions           *[]string
	appendconditions     []string
	properties           *map[string]interface{}
	is_countersign       *bool
	countersign_rule     *string
	handlers             *map[string]interface{}
	listeners            *map[string]interface{}
	_hooks               *map[string]interface{}
	variables            *map[string]interface{}
	retry_times          *int
	addretry_times       *int
	retry_interval       *int
	addretry_interval    *int
	is_working_day       *bool
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Node, error)
	predicates           []predicate.Node
}

var _ ent.Mutation = (*NodeMutation)(nil)

// nodeOption allows management of the mutation configuration using functional options.
type nodeOption func(*NodeMutation)

// newNodeMutation creates new mutation for the Node entity.
func newNodeMutation(c config, op Op, opts ...nodeOption) *NodeMutation {
	m := &NodeMutation{
		config:        c,
		op:            op,
		typ:           TypeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeID sets the ID field of the mutation.
func withNodeID(id string) nodeOption {
	return func(m *NodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Node
		)
		m.oldValue = func(ctx context.Context) (*Node, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Node.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNode sets the old Node of the mutation.
func withNode(node *Node) nodeOption {
	return func(m *NodeMutation) {
		m.oldValue = func(context.Context) (*Node, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Node entities.
func (m *NodeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Node.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *NodeMutation) ClearName() {
	m.name = nil
	m.clearedFields[node.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *NodeMutation) NameCleared() bool {
	_, ok := m.clearedFields[node.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *NodeMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, node.FieldName)
}

// SetDescription sets the "description" field.
func (m *NodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NodeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[node.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NodeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[node.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NodeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, node.FieldDescription)
}

// SetType sets the "type" field.
func (m *NodeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *NodeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *NodeMutation) ClearType() {
	m._type = nil
	m.clearedFields[node.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *NodeMutation) TypeCleared() bool {
	_, ok := m.clearedFields[node.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *NodeMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, node.FieldType)
}

// SetStatus sets the "status" field.
func (m *NodeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *NodeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *NodeMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[node.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *NodeMutation) StatusCleared() bool {
	_, ok := m.clearedFields[node.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *NodeMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, node.FieldStatus)
}

// SetNodeKey sets the "node_key" field.
func (m *NodeMutation) SetNodeKey(s string) {
	m.node_key = &s
}

// NodeKey returns the value of the "node_key" field in the mutation.
func (m *NodeMutation) NodeKey() (r string, exists bool) {
	v := m.node_key
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeKey returns the old "node_key" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldNodeKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeKey: %w", err)
	}
	return oldValue.NodeKey, nil
}

// ResetNodeKey resets all changes to the "node_key" field.
func (m *NodeMutation) ResetNodeKey() {
	m.node_key = nil
}

// SetNodeType sets the "node_type" field.
func (m *NodeMutation) SetNodeType(s string) {
	m.node_type = &s
}

// NodeType returns the value of the "node_type" field in the mutation.
func (m *NodeMutation) NodeType() (r string, exists bool) {
	v := m.node_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeType returns the old "node_type" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldNodeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeType: %w", err)
	}
	return oldValue.NodeType, nil
}

// ResetNodeType resets all changes to the "node_type" field.
func (m *NodeMutation) ResetNodeType() {
	m.node_type = nil
}

// SetNodeConfig sets the "node_config" field.
func (m *NodeMutation) SetNodeConfig(value map[string]interface{}) {
	m.node_config = &value
}

// NodeConfig returns the value of the "node_config" field in the mutation.
func (m *NodeMutation) NodeConfig() (r map[string]interface{}, exists bool) {
	v := m.node_config
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeConfig returns the old "node_config" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldNodeConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeConfig: %w", err)
	}
	return oldValue.NodeConfig, nil
}

// ClearNodeConfig clears the value of the "node_config" field.
func (m *NodeMutation) ClearNodeConfig() {
	m.node_config = nil
	m.clearedFields[node.FieldNodeConfig] = struct{}{}
}

// NodeConfigCleared returns if the "node_config" field was cleared in this mutation.
func (m *NodeMutation) NodeConfigCleared() bool {
	_, ok := m.clearedFields[node.FieldNodeConfig]
	return ok
}

// ResetNodeConfig resets all changes to the "node_config" field.
func (m *NodeMutation) ResetNodeConfig() {
	m.node_config = nil
	delete(m.clearedFields, node.FieldNodeConfig)
}

// SetNodeRules sets the "node_rules" field.
func (m *NodeMutation) SetNodeRules(value map[string]interface{}) {
	m.node_rules = &value
}

// NodeRules returns the value of the "node_rules" field in the mutation.
func (m *NodeMutation) NodeRules() (r map[string]interface{}, exists bool) {
	v := m.node_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeRules returns the old "node_rules" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldNodeRules(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeRules: %w", err)
	}
	return oldValue.NodeRules, nil
}

// ClearNodeRules clears the value of the "node_rules" field.
func (m *NodeMutation) ClearNodeRules() {
	m.node_rules = nil
	m.clearedFields[node.FieldNodeRules] = struct{}{}
}

// NodeRulesCleared returns if the "node_rules" field was cleared in this mutation.
func (m *NodeMutation) NodeRulesCleared() bool {
	_, ok := m.clearedFields[node.FieldNodeRules]
	return ok
}

// ResetNodeRules resets all changes to the "node_rules" field.
func (m *NodeMutation) ResetNodeRules() {
	m.node_rules = nil
	delete(m.clearedFields, node.FieldNodeRules)
}

// SetNodeEvents sets the "node_events" field.
func (m *NodeMutation) SetNodeEvents(value map[string]interface{}) {
	m.node_events = &value
}

// NodeEvents returns the value of the "node_events" field in the mutation.
func (m *NodeMutation) NodeEvents() (r map[string]interface{}, exists bool) {
	v := m.node_events
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeEvents returns the old "node_events" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldNodeEvents(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeEvents: %w", err)
	}
	return oldValue.NodeEvents, nil
}

// ClearNodeEvents clears the value of the "node_events" field.
func (m *NodeMutation) ClearNodeEvents() {
	m.node_events = nil
	m.clearedFields[node.FieldNodeEvents] = struct{}{}
}

// NodeEventsCleared returns if the "node_events" field was cleared in this mutation.
func (m *NodeMutation) NodeEventsCleared() bool {
	_, ok := m.clearedFields[node.FieldNodeEvents]
	return ok
}

// ResetNodeEvents resets all changes to the "node_events" field.
func (m *NodeMutation) ResetNodeEvents() {
	m.node_events = nil
	delete(m.clearedFields, node.FieldNodeEvents)
}

// SetFormCode sets the "form_code" field.
func (m *NodeMutation) SetFormCode(s string) {
	m.form_code = &s
}

// FormCode returns the value of the "form_code" field in the mutation.
func (m *NodeMutation) FormCode() (r string, exists bool) {
	v := m.form_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFormCode returns the old "form_code" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldFormCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormCode: %w", err)
	}
	return oldValue.FormCode, nil
}

// ResetFormCode resets all changes to the "form_code" field.
func (m *NodeMutation) ResetFormCode() {
	m.form_code = nil
}

// SetFormVersion sets the "form_version" field.
func (m *NodeMutation) SetFormVersion(s string) {
	m.form_version = &s
}

// FormVersion returns the value of the "form_version" field in the mutation.
func (m *NodeMutation) FormVersion() (r string, exists bool) {
	v := m.form_version
	if v == nil {
		return
	}
	return *v, true
}

// OldFormVersion returns the old "form_version" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldFormVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormVersion: %w", err)
	}
	return oldValue.FormVersion, nil
}

// ClearFormVersion clears the value of the "form_version" field.
func (m *NodeMutation) ClearFormVersion() {
	m.form_version = nil
	m.clearedFields[node.FieldFormVersion] = struct{}{}
}

// FormVersionCleared returns if the "form_version" field was cleared in this mutation.
func (m *NodeMutation) FormVersionCleared() bool {
	_, ok := m.clearedFields[node.FieldFormVersion]
	return ok
}

// ResetFormVersion resets all changes to the "form_version" field.
func (m *NodeMutation) ResetFormVersion() {
	m.form_version = nil
	delete(m.clearedFields, node.FieldFormVersion)
}

// SetFormConfig sets the "form_config" field.
func (m *NodeMutation) SetFormConfig(value map[string]interface{}) {
	m.form_config = &value
}

// FormConfig returns the value of the "form_config" field in the mutation.
func (m *NodeMutation) FormConfig() (r map[string]interface{}, exists bool) {
	v := m.form_config
	if v == nil {
		return
	}
	return *v, true
}

// OldFormConfig returns the old "form_config" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldFormConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormConfig: %w", err)
	}
	return oldValue.FormConfig, nil
}

// ClearFormConfig clears the value of the "form_config" field.
func (m *NodeMutation) ClearFormConfig() {
	m.form_config = nil
	m.clearedFields[node.FieldFormConfig] = struct{}{}
}

// FormConfigCleared returns if the "form_config" field was cleared in this mutation.
func (m *NodeMutation) FormConfigCleared() bool {
	_, ok := m.clearedFields[node.FieldFormConfig]
	return ok
}

// ResetFormConfig resets all changes to the "form_config" field.
func (m *NodeMutation) ResetFormConfig() {
	m.form_config = nil
	delete(m.clearedFields, node.FieldFormConfig)
}

// SetFormPermissions sets the "form_permissions" field.
func (m *NodeMutation) SetFormPermissions(value map[string]interface{}) {
	m.form_permissions = &value
}

// FormPermissions returns the value of the "form_permissions" field in the mutation.
func (m *NodeMutation) FormPermissions() (r map[string]interface{}, exists bool) {
	v := m.form_permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldFormPermissions returns the old "form_permissions" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldFormPermissions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormPermissions: %w", err)
	}
	return oldValue.FormPermissions, nil
}

// ClearFormPermissions clears the value of the "form_permissions" field.
func (m *NodeMutation) ClearFormPermissions() {
	m.form_permissions = nil
	m.clearedFields[node.FieldFormPermissions] = struct{}{}
}

// FormPermissionsCleared returns if the "form_permissions" field was cleared in this mutation.
func (m *NodeMutation) FormPermissionsCleared() bool {
	_, ok := m.clearedFields[node.FieldFormPermissions]
	return ok
}

// ResetFormPermissions resets all changes to the "form_permissions" field.
func (m *NodeMutation) ResetFormPermissions() {
	m.form_permissions = nil
	delete(m.clearedFields, node.FieldFormPermissions)
}

// SetFieldPermissions sets the "field_permissions" field.
func (m *NodeMutation) SetFieldPermissions(value map[string]interface{}) {
	m.field_permissions = &value
}

// FieldPermissions returns the value of the "field_permissions" field in the mutation.
func (m *NodeMutation) FieldPermissions() (r map[string]interface{}, exists bool) {
	v := m.field_permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldPermissions returns the old "field_permissions" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldFieldPermissions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldPermissions: %w", err)
	}
	return oldValue.FieldPermissions, nil
}

// ClearFieldPermissions clears the value of the "field_permissions" field.
func (m *NodeMutation) ClearFieldPermissions() {
	m.field_permissions = nil
	m.clearedFields[node.FieldFieldPermissions] = struct{}{}
}

// FieldPermissionsCleared returns if the "field_permissions" field was cleared in this mutation.
func (m *NodeMutation) FieldPermissionsCleared() bool {
	_, ok := m.clearedFields[node.FieldFieldPermissions]
	return ok
}

// ResetFieldPermissions resets all changes to the "field_permissions" field.
func (m *NodeMutation) ResetFieldPermissions() {
	m.field_permissions = nil
	delete(m.clearedFields, node.FieldFieldPermissions)
}

// SetAssignees sets the "assignees" field.
func (m *NodeMutation) SetAssignees(s []string) {
	m.assignees = &s
	m.appendassignees = nil
}

// Assignees returns the value of the "assignees" field in the mutation.
func (m *NodeMutation) Assignees() (r []string, exists bool) {
	v := m.assignees
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignees returns the old "assignees" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldAssignees(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignees is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignees requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignees: %w", err)
	}
	return oldValue.Assignees, nil
}

// AppendAssignees adds s to the "assignees" field.
func (m *NodeMutation) AppendAssignees(s []string) {
	m.appendassignees = append(m.appendassignees, s...)
}

// AppendedAssignees returns the list of values that were appended to the "assignees" field in this mutation.
func (m *NodeMutation) AppendedAssignees() ([]string, bool) {
	if len(m.appendassignees) == 0 {
		return nil, false
	}
	return m.appendassignees, true
}

// ResetAssignees resets all changes to the "assignees" field.
func (m *NodeMutation) ResetAssignees() {
	m.assignees = nil
	m.appendassignees = nil
}

// SetCandidates sets the "candidates" field.
func (m *NodeMutation) SetCandidates(s []string) {
	m.candidates = &s
	m.appendcandidates = nil
}

// Candidates returns the value of the "candidates" field in the mutation.
func (m *NodeMutation) Candidates() (r []string, exists bool) {
	v := m.candidates
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidates returns the old "candidates" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCandidates(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidates: %w", err)
	}
	return oldValue.Candidates, nil
}

// AppendCandidates adds s to the "candidates" field.
func (m *NodeMutation) AppendCandidates(s []string) {
	m.appendcandidates = append(m.appendcandidates, s...)
}

// AppendedCandidates returns the list of values that were appended to the "candidates" field in this mutation.
func (m *NodeMutation) AppendedCandidates() ([]string, bool) {
	if len(m.appendcandidates) == 0 {
		return nil, false
	}
	return m.appendcandidates, true
}

// ResetCandidates resets all changes to the "candidates" field.
func (m *NodeMutation) ResetCandidates() {
	m.candidates = nil
	m.appendcandidates = nil
}

// SetDelegatedFrom sets the "delegated_from" field.
func (m *NodeMutation) SetDelegatedFrom(s string) {
	m.delegated_from = &s
}

// DelegatedFrom returns the value of the "delegated_from" field in the mutation.
func (m *NodeMutation) DelegatedFrom() (r string, exists bool) {
	v := m.delegated_from
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegatedFrom returns the old "delegated_from" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDelegatedFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegatedFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegatedFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegatedFrom: %w", err)
	}
	return oldValue.DelegatedFrom, nil
}

// ClearDelegatedFrom clears the value of the "delegated_from" field.
func (m *NodeMutation) ClearDelegatedFrom() {
	m.delegated_from = nil
	m.clearedFields[node.FieldDelegatedFrom] = struct{}{}
}

// DelegatedFromCleared returns if the "delegated_from" field was cleared in this mutation.
func (m *NodeMutation) DelegatedFromCleared() bool {
	_, ok := m.clearedFields[node.FieldDelegatedFrom]
	return ok
}

// ResetDelegatedFrom resets all changes to the "delegated_from" field.
func (m *NodeMutation) ResetDelegatedFrom() {
	m.delegated_from = nil
	delete(m.clearedFields, node.FieldDelegatedFrom)
}

// SetDelegatedReason sets the "delegated_reason" field.
func (m *NodeMutation) SetDelegatedReason(s string) {
	m.delegated_reason = &s
}

// DelegatedReason returns the value of the "delegated_reason" field in the mutation.
func (m *NodeMutation) DelegatedReason() (r string, exists bool) {
	v := m.delegated_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegatedReason returns the old "delegated_reason" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDelegatedReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegatedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegatedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegatedReason: %w", err)
	}
	return oldValue.DelegatedReason, nil
}

// ClearDelegatedReason clears the value of the "delegated_reason" field.
func (m *NodeMutation) ClearDelegatedReason() {
	m.delegated_reason = nil
	m.clearedFields[node.FieldDelegatedReason] = struct{}{}
}

// DelegatedReasonCleared returns if the "delegated_reason" field was cleared in this mutation.
func (m *NodeMutation) DelegatedReasonCleared() bool {
	_, ok := m.clearedFields[node.FieldDelegatedReason]
	return ok
}

// ResetDelegatedReason resets all changes to the "delegated_reason" field.
func (m *NodeMutation) ResetDelegatedReason() {
	m.delegated_reason = nil
	delete(m.clearedFields, node.FieldDelegatedReason)
}

// SetIsDelegated sets the "is_delegated" field.
func (m *NodeMutation) SetIsDelegated(b bool) {
	m.is_delegated = &b
}

// IsDelegated returns the value of the "is_delegated" field in the mutation.
func (m *NodeMutation) IsDelegated() (r bool, exists bool) {
	v := m.is_delegated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDelegated returns the old "is_delegated" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIsDelegated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDelegated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDelegated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDelegated: %w", err)
	}
	return oldValue.IsDelegated, nil
}

// ResetIsDelegated resets all changes to the "is_delegated" field.
func (m *NodeMutation) ResetIsDelegated() {
	m.is_delegated = nil
}

// SetIsTransferred sets the "is_transferred" field.
func (m *NodeMutation) SetIsTransferred(b bool) {
	m.is_transferred = &b
}

// IsTransferred returns the value of the "is_transferred" field in the mutation.
func (m *NodeMutation) IsTransferred() (r bool, exists bool) {
	v := m.is_transferred
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTransferred returns the old "is_transferred" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIsTransferred(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTransferred is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTransferred requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTransferred: %w", err)
	}
	return oldValue.IsTransferred, nil
}

// ResetIsTransferred resets all changes to the "is_transferred" field.
func (m *NodeMutation) ResetIsTransferred() {
	m.is_transferred = nil
}

// SetAllowCancel sets the "allow_cancel" field.
func (m *NodeMutation) SetAllowCancel(b bool) {
	m.allow_cancel = &b
}

// AllowCancel returns the value of the "allow_cancel" field in the mutation.
func (m *NodeMutation) AllowCancel() (r bool, exists bool) {
	v := m.allow_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowCancel returns the old "allow_cancel" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldAllowCancel(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowCancel: %w", err)
	}
	return oldValue.AllowCancel, nil
}

// ResetAllowCancel resets all changes to the "allow_cancel" field.
func (m *NodeMutation) ResetAllowCancel() {
	m.allow_cancel = nil
}

// SetAllowUrge sets the "allow_urge" field.
func (m *NodeMutation) SetAllowUrge(b bool) {
	m.allow_urge = &b
}

// AllowUrge returns the value of the "allow_urge" field in the mutation.
func (m *NodeMutation) AllowUrge() (r bool, exists bool) {
	v := m.allow_urge
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowUrge returns the old "allow_urge" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldAllowUrge(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowUrge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowUrge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowUrge: %w", err)
	}
	return oldValue.AllowUrge, nil
}

// ResetAllowUrge resets all changes to the "allow_urge" field.
func (m *NodeMutation) ResetAllowUrge() {
	m.allow_urge = nil
}

// SetAllowDelegate sets the "allow_delegate" field.
func (m *NodeMutation) SetAllowDelegate(b bool) {
	m.allow_delegate = &b
}

// AllowDelegate returns the value of the "allow_delegate" field in the mutation.
func (m *NodeMutation) AllowDelegate() (r bool, exists bool) {
	v := m.allow_delegate
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowDelegate returns the old "allow_delegate" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldAllowDelegate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowDelegate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowDelegate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowDelegate: %w", err)
	}
	return oldValue.AllowDelegate, nil
}

// ResetAllowDelegate resets all changes to the "allow_delegate" field.
func (m *NodeMutation) ResetAllowDelegate() {
	m.allow_delegate = nil
}

// SetAllowTransfer sets the "allow_transfer" field.
func (m *NodeMutation) SetAllowTransfer(b bool) {
	m.allow_transfer = &b
}

// AllowTransfer returns the value of the "allow_transfer" field in the mutation.
func (m *NodeMutation) AllowTransfer() (r bool, exists bool) {
	v := m.allow_transfer
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowTransfer returns the old "allow_transfer" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldAllowTransfer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowTransfer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowTransfer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowTransfer: %w", err)
	}
	return oldValue.AllowTransfer, nil
}

// ResetAllowTransfer resets all changes to the "allow_transfer" field.
func (m *NodeMutation) ResetAllowTransfer() {
	m.allow_transfer = nil
}

// SetIsDraftEnabled sets the "is_draft_enabled" field.
func (m *NodeMutation) SetIsDraftEnabled(b bool) {
	m.is_draft_enabled = &b
}

// IsDraftEnabled returns the value of the "is_draft_enabled" field in the mutation.
func (m *NodeMutation) IsDraftEnabled() (r bool, exists bool) {
	v := m.is_draft_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDraftEnabled returns the old "is_draft_enabled" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIsDraftEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDraftEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDraftEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDraftEnabled: %w", err)
	}
	return oldValue.IsDraftEnabled, nil
}

// ResetIsDraftEnabled resets all changes to the "is_draft_enabled" field.
func (m *NodeMutation) ResetIsDraftEnabled() {
	m.is_draft_enabled = nil
}

// SetIsAutoStart sets the "is_auto_start" field.
func (m *NodeMutation) SetIsAutoStart(b bool) {
	m.is_auto_start = &b
}

// IsAutoStart returns the value of the "is_auto_start" field in the mutation.
func (m *NodeMutation) IsAutoStart() (r bool, exists bool) {
	v := m.is_auto_start
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutoStart returns the old "is_auto_start" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIsAutoStart(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAutoStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAutoStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutoStart: %w", err)
	}
	return oldValue.IsAutoStart, nil
}

// ResetIsAutoStart resets all changes to the "is_auto_start" field.
func (m *NodeMutation) ResetIsAutoStart() {
	m.is_auto_start = nil
}

// SetStrictMode sets the "strict_mode" field.
func (m *NodeMutation) SetStrictMode(b bool) {
	m.strict_mode = &b
}

// StrictMode returns the value of the "strict_mode" field in the mutation.
func (m *NodeMutation) StrictMode() (r bool, exists bool) {
	v := m.strict_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldStrictMode returns the old "strict_mode" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldStrictMode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrictMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrictMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrictMode: %w", err)
	}
	return oldValue.StrictMode, nil
}

// ResetStrictMode resets all changes to the "strict_mode" field.
func (m *NodeMutation) ResetStrictMode() {
	m.strict_mode = nil
}

// SetStartTime sets the "start_time" field.
func (m *NodeMutation) SetStartTime(i int64) {
	m.start_time = &i
	m.addstart_time = nil
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *NodeMutation) StartTime() (r int64, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldStartTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// AddStartTime adds i to the "start_time" field.
func (m *NodeMutation) AddStartTime(i int64) {
	if m.addstart_time != nil {
		*m.addstart_time += i
	} else {
		m.addstart_time = &i
	}
}

// AddedStartTime returns the value that was added to the "start_time" field in this mutation.
func (m *NodeMutation) AddedStartTime() (r int64, exists bool) {
	v := m.addstart_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *NodeMutation) ResetStartTime() {
	m.start_time = nil
	m.addstart_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *NodeMutation) SetEndTime(i int64) {
	m.end_time = &i
	m.addend_time = nil
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *NodeMutation) EndTime() (r int64, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldEndTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// AddEndTime adds i to the "end_time" field.
func (m *NodeMutation) AddEndTime(i int64) {
	if m.addend_time != nil {
		*m.addend_time += i
	} else {
		m.addend_time = &i
	}
}

// AddedEndTime returns the value that was added to the "end_time" field in this mutation.
func (m *NodeMutation) AddedEndTime() (r int64, exists bool) {
	v := m.addend_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndTime clears the value of the "end_time" field.
func (m *NodeMutation) ClearEndTime() {
	m.end_time = nil
	m.addend_time = nil
	m.clearedFields[node.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *NodeMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[node.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *NodeMutation) ResetEndTime() {
	m.end_time = nil
	m.addend_time = nil
	delete(m.clearedFields, node.FieldEndTime)
}

// SetDueTime sets the "due_time" field.
func (m *NodeMutation) SetDueTime(i int64) {
	m.due_time = &i
	m.adddue_time = nil
}

// DueTime returns the value of the "due_time" field in the mutation.
func (m *NodeMutation) DueTime() (r int64, exists bool) {
	v := m.due_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDueTime returns the old "due_time" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDueTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueTime: %w", err)
	}
	return oldValue.DueTime, nil
}

// AddDueTime adds i to the "due_time" field.
func (m *NodeMutation) AddDueTime(i int64) {
	if m.adddue_time != nil {
		*m.adddue_time += i
	} else {
		m.adddue_time = &i
	}
}

// AddedDueTime returns the value that was added to the "due_time" field in this mutation.
func (m *NodeMutation) AddedDueTime() (r int64, exists bool) {
	v := m.adddue_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDueTime clears the value of the "due_time" field.
func (m *NodeMutation) ClearDueTime() {
	m.due_time = nil
	m.adddue_time = nil
	m.clearedFields[node.FieldDueTime] = struct{}{}
}

// DueTimeCleared returns if the "due_time" field was cleared in this mutation.
func (m *NodeMutation) DueTimeCleared() bool {
	_, ok := m.clearedFields[node.FieldDueTime]
	return ok
}

// ResetDueTime resets all changes to the "due_time" field.
func (m *NodeMutation) ResetDueTime() {
	m.due_time = nil
	m.adddue_time = nil
	delete(m.clearedFields, node.FieldDueTime)
}

// SetDuration sets the "duration" field.
func (m *NodeMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *NodeMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *NodeMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *NodeMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *NodeMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[node.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *NodeMutation) DurationCleared() bool {
	_, ok := m.clearedFields[node.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *NodeMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, node.FieldDuration)
}

// SetPriority sets the "priority" field.
func (m *NodeMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *NodeMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *NodeMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *NodeMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *NodeMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetIsTimeout sets the "is_timeout" field.
func (m *NodeMutation) SetIsTimeout(b bool) {
	m.is_timeout = &b
}

// IsTimeout returns the value of the "is_timeout" field in the mutation.
func (m *NodeMutation) IsTimeout() (r bool, exists bool) {
	v := m.is_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTimeout returns the old "is_timeout" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIsTimeout(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTimeout: %w", err)
	}
	return oldValue.IsTimeout, nil
}

// ResetIsTimeout resets all changes to the "is_timeout" field.
func (m *NodeMutation) ResetIsTimeout() {
	m.is_timeout = nil
}

// SetReminderCount sets the "reminder_count" field.
func (m *NodeMutation) SetReminderCount(i int) {
	m.reminder_count = &i
	m.addreminder_count = nil
}

// ReminderCount returns the value of the "reminder_count" field in the mutation.
func (m *NodeMutation) ReminderCount() (r int, exists bool) {
	v := m.reminder_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReminderCount returns the old "reminder_count" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldReminderCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReminderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReminderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReminderCount: %w", err)
	}
	return oldValue.ReminderCount, nil
}

// AddReminderCount adds i to the "reminder_count" field.
func (m *NodeMutation) AddReminderCount(i int) {
	if m.addreminder_count != nil {
		*m.addreminder_count += i
	} else {
		m.addreminder_count = &i
	}
}

// AddedReminderCount returns the value that was added to the "reminder_count" field in this mutation.
func (m *NodeMutation) AddedReminderCount() (r int, exists bool) {
	v := m.addreminder_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReminderCount resets all changes to the "reminder_count" field.
func (m *NodeMutation) ResetReminderCount() {
	m.reminder_count = nil
	m.addreminder_count = nil
}

// SetExtras sets the "extras" field.
func (m *NodeMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *NodeMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *NodeMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[node.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *NodeMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[node.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *NodeMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, node.FieldExtras)
}

// SetTenantID sets the "tenant_id" field.
func (m *NodeMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *NodeMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *NodeMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[node.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *NodeMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[node.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *NodeMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, node.FieldTenantID)
}

// SetCreatedBy sets the "created_by" field.
func (m *NodeMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *NodeMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *NodeMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[node.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *NodeMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[node.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *NodeMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, node.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *NodeMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *NodeMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *NodeMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[node.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *NodeMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[node.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *NodeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, node.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *NodeMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NodeMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *NodeMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *NodeMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *NodeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[node.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *NodeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[node.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NodeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, node.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NodeMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NodeMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *NodeMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *NodeMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *NodeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[node.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *NodeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[node.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, node.FieldUpdatedAt)
}

// SetProcessID sets the "process_id" field.
func (m *NodeMutation) SetProcessID(s string) {
	m.process_id = &s
}

// ProcessID returns the value of the "process_id" field in the mutation.
func (m *NodeMutation) ProcessID() (r string, exists bool) {
	v := m.process_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessID returns the old "process_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldProcessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessID: %w", err)
	}
	return oldValue.ProcessID, nil
}

// ResetProcessID resets all changes to the "process_id" field.
func (m *NodeMutation) ResetProcessID() {
	m.process_id = nil
}

// SetPermissions sets the "permissions" field.
func (m *NodeMutation) SetPermissions(value map[string]interface{}) {
	m.permissions = &value
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *NodeMutation) Permissions() (r map[string]interface{}, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPermissions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *NodeMutation) ResetPermissions() {
	m.permissions = nil
}

// SetPrevNodes sets the "prev_nodes" field.
func (m *NodeMutation) SetPrevNodes(s []string) {
	m.prev_nodes = &s
	m.appendprev_nodes = nil
}

// PrevNodes returns the value of the "prev_nodes" field in the mutation.
func (m *NodeMutation) PrevNodes() (r []string, exists bool) {
	v := m.prev_nodes
	if v == nil {
		return
	}
	return *v, true
}

// OldPrevNodes returns the old "prev_nodes" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPrevNodes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrevNodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrevNodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrevNodes: %w", err)
	}
	return oldValue.PrevNodes, nil
}

// AppendPrevNodes adds s to the "prev_nodes" field.
func (m *NodeMutation) AppendPrevNodes(s []string) {
	m.appendprev_nodes = append(m.appendprev_nodes, s...)
}

// AppendedPrevNodes returns the list of values that were appended to the "prev_nodes" field in this mutation.
func (m *NodeMutation) AppendedPrevNodes() ([]string, bool) {
	if len(m.appendprev_nodes) == 0 {
		return nil, false
	}
	return m.appendprev_nodes, true
}

// ClearPrevNodes clears the value of the "prev_nodes" field.
func (m *NodeMutation) ClearPrevNodes() {
	m.prev_nodes = nil
	m.appendprev_nodes = nil
	m.clearedFields[node.FieldPrevNodes] = struct{}{}
}

// PrevNodesCleared returns if the "prev_nodes" field was cleared in this mutation.
func (m *NodeMutation) PrevNodesCleared() bool {
	_, ok := m.clearedFields[node.FieldPrevNodes]
	return ok
}

// ResetPrevNodes resets all changes to the "prev_nodes" field.
func (m *NodeMutation) ResetPrevNodes() {
	m.prev_nodes = nil
	m.appendprev_nodes = nil
	delete(m.clearedFields, node.FieldPrevNodes)
}

// SetNextNodes sets the "next_nodes" field.
func (m *NodeMutation) SetNextNodes(s []string) {
	m.next_nodes = &s
	m.appendnext_nodes = nil
}

// NextNodes returns the value of the "next_nodes" field in the mutation.
func (m *NodeMutation) NextNodes() (r []string, exists bool) {
	v := m.next_nodes
	if v == nil {
		return
	}
	return *v, true
}

// OldNextNodes returns the old "next_nodes" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldNextNodes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextNodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextNodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextNodes: %w", err)
	}
	return oldValue.NextNodes, nil
}

// AppendNextNodes adds s to the "next_nodes" field.
func (m *NodeMutation) AppendNextNodes(s []string) {
	m.appendnext_nodes = append(m.appendnext_nodes, s...)
}

// AppendedNextNodes returns the list of values that were appended to the "next_nodes" field in this mutation.
func (m *NodeMutation) AppendedNextNodes() ([]string, bool) {
	if len(m.appendnext_nodes) == 0 {
		return nil, false
	}
	return m.appendnext_nodes, true
}

// ClearNextNodes clears the value of the "next_nodes" field.
func (m *NodeMutation) ClearNextNodes() {
	m.next_nodes = nil
	m.appendnext_nodes = nil
	m.clearedFields[node.FieldNextNodes] = struct{}{}
}

// NextNodesCleared returns if the "next_nodes" field was cleared in this mutation.
func (m *NodeMutation) NextNodesCleared() bool {
	_, ok := m.clearedFields[node.FieldNextNodes]
	return ok
}

// ResetNextNodes resets all changes to the "next_nodes" field.
func (m *NodeMutation) ResetNextNodes() {
	m.next_nodes = nil
	m.appendnext_nodes = nil
	delete(m.clearedFields, node.FieldNextNodes)
}

// SetParallelNodes sets the "parallel_nodes" field.
func (m *NodeMutation) SetParallelNodes(s []string) {
	m.parallel_nodes = &s
	m.appendparallel_nodes = nil
}

// ParallelNodes returns the value of the "parallel_nodes" field in the mutation.
func (m *NodeMutation) ParallelNodes() (r []string, exists bool) {
	v := m.parallel_nodes
	if v == nil {
		return
	}
	return *v, true
}

// OldParallelNodes returns the old "parallel_nodes" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldParallelNodes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParallelNodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParallelNodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParallelNodes: %w", err)
	}
	return oldValue.ParallelNodes, nil
}

// AppendParallelNodes adds s to the "parallel_nodes" field.
func (m *NodeMutation) AppendParallelNodes(s []string) {
	m.appendparallel_nodes = append(m.appendparallel_nodes, s...)
}

// AppendedParallelNodes returns the list of values that were appended to the "parallel_nodes" field in this mutation.
func (m *NodeMutation) AppendedParallelNodes() ([]string, bool) {
	if len(m.appendparallel_nodes) == 0 {
		return nil, false
	}
	return m.appendparallel_nodes, true
}

// ClearParallelNodes clears the value of the "parallel_nodes" field.
func (m *NodeMutation) ClearParallelNodes() {
	m.parallel_nodes = nil
	m.appendparallel_nodes = nil
	m.clearedFields[node.FieldParallelNodes] = struct{}{}
}

// ParallelNodesCleared returns if the "parallel_nodes" field was cleared in this mutation.
func (m *NodeMutation) ParallelNodesCleared() bool {
	_, ok := m.clearedFields[node.FieldParallelNodes]
	return ok
}

// ResetParallelNodes resets all changes to the "parallel_nodes" field.
func (m *NodeMutation) ResetParallelNodes() {
	m.parallel_nodes = nil
	m.appendparallel_nodes = nil
	delete(m.clearedFields, node.FieldParallelNodes)
}

// SetBranchNodes sets the "branch_nodes" field.
func (m *NodeMutation) SetBranchNodes(s []string) {
	m.branch_nodes = &s
	m.appendbranch_nodes = nil
}

// BranchNodes returns the value of the "branch_nodes" field in the mutation.
func (m *NodeMutation) BranchNodes() (r []string, exists bool) {
	v := m.branch_nodes
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchNodes returns the old "branch_nodes" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldBranchNodes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchNodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchNodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchNodes: %w", err)
	}
	return oldValue.BranchNodes, nil
}

// AppendBranchNodes adds s to the "branch_nodes" field.
func (m *NodeMutation) AppendBranchNodes(s []string) {
	m.appendbranch_nodes = append(m.appendbranch_nodes, s...)
}

// AppendedBranchNodes returns the list of values that were appended to the "branch_nodes" field in this mutation.
func (m *NodeMutation) AppendedBranchNodes() ([]string, bool) {
	if len(m.appendbranch_nodes) == 0 {
		return nil, false
	}
	return m.appendbranch_nodes, true
}

// ClearBranchNodes clears the value of the "branch_nodes" field.
func (m *NodeMutation) ClearBranchNodes() {
	m.branch_nodes = nil
	m.appendbranch_nodes = nil
	m.clearedFields[node.FieldBranchNodes] = struct{}{}
}

// BranchNodesCleared returns if the "branch_nodes" field was cleared in this mutation.
func (m *NodeMutation) BranchNodesCleared() bool {
	_, ok := m.clearedFields[node.FieldBranchNodes]
	return ok
}

// ResetBranchNodes resets all changes to the "branch_nodes" field.
func (m *NodeMutation) ResetBranchNodes() {
	m.branch_nodes = nil
	m.appendbranch_nodes = nil
	delete(m.clearedFields, node.FieldBranchNodes)
}

// SetConditions sets the "conditions" field.
func (m *NodeMutation) SetConditions(s []string) {
	m.conditions = &s
	m.appendconditions = nil
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *NodeMutation) Conditions() (r []string, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldConditions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// AppendConditions adds s to the "conditions" field.
func (m *NodeMutation) AppendConditions(s []string) {
	m.appendconditions = append(m.appendconditions, s...)
}

// AppendedConditions returns the list of values that were appended to the "conditions" field in this mutation.
func (m *NodeMutation) AppendedConditions() ([]string, bool) {
	if len(m.appendconditions) == 0 {
		return nil, false
	}
	return m.appendconditions, true
}

// ClearConditions clears the value of the "conditions" field.
func (m *NodeMutation) ClearConditions() {
	m.conditions = nil
	m.appendconditions = nil
	m.clearedFields[node.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *NodeMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[node.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *NodeMutation) ResetConditions() {
	m.conditions = nil
	m.appendconditions = nil
	delete(m.clearedFields, node.FieldConditions)
}

// SetProperties sets the "properties" field.
func (m *NodeMutation) SetProperties(value map[string]interface{}) {
	m.properties = &value
}

// Properties returns the value of the "properties" field in the mutation.
func (m *NodeMutation) Properties() (r map[string]interface{}, exists bool) {
	v := m.properties
	if v == nil {
		return
	}
	return *v, true
}

// OldProperties returns the old "properties" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldProperties(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProperties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProperties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProperties: %w", err)
	}
	return oldValue.Properties, nil
}

// ClearProperties clears the value of the "properties" field.
func (m *NodeMutation) ClearProperties() {
	m.properties = nil
	m.clearedFields[node.FieldProperties] = struct{}{}
}

// PropertiesCleared returns if the "properties" field was cleared in this mutation.
func (m *NodeMutation) PropertiesCleared() bool {
	_, ok := m.clearedFields[node.FieldProperties]
	return ok
}

// ResetProperties resets all changes to the "properties" field.
func (m *NodeMutation) ResetProperties() {
	m.properties = nil
	delete(m.clearedFields, node.FieldProperties)
}

// SetIsCountersign sets the "is_countersign" field.
func (m *NodeMutation) SetIsCountersign(b bool) {
	m.is_countersign = &b
}

// IsCountersign returns the value of the "is_countersign" field in the mutation.
func (m *NodeMutation) IsCountersign() (r bool, exists bool) {
	v := m.is_countersign
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCountersign returns the old "is_countersign" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIsCountersign(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCountersign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCountersign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCountersign: %w", err)
	}
	return oldValue.IsCountersign, nil
}

// ResetIsCountersign resets all changes to the "is_countersign" field.
func (m *NodeMutation) ResetIsCountersign() {
	m.is_countersign = nil
}

// SetCountersignRule sets the "countersign_rule" field.
func (m *NodeMutation) SetCountersignRule(s string) {
	m.countersign_rule = &s
}

// CountersignRule returns the value of the "countersign_rule" field in the mutation.
func (m *NodeMutation) CountersignRule() (r string, exists bool) {
	v := m.countersign_rule
	if v == nil {
		return
	}
	return *v, true
}

// OldCountersignRule returns the old "countersign_rule" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCountersignRule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountersignRule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountersignRule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountersignRule: %w", err)
	}
	return oldValue.CountersignRule, nil
}

// ClearCountersignRule clears the value of the "countersign_rule" field.
func (m *NodeMutation) ClearCountersignRule() {
	m.countersign_rule = nil
	m.clearedFields[node.FieldCountersignRule] = struct{}{}
}

// CountersignRuleCleared returns if the "countersign_rule" field was cleared in this mutation.
func (m *NodeMutation) CountersignRuleCleared() bool {
	_, ok := m.clearedFields[node.FieldCountersignRule]
	return ok
}

// ResetCountersignRule resets all changes to the "countersign_rule" field.
func (m *NodeMutation) ResetCountersignRule() {
	m.countersign_rule = nil
	delete(m.clearedFields, node.FieldCountersignRule)
}

// SetHandlers sets the "handlers" field.
func (m *NodeMutation) SetHandlers(value map[string]interface{}) {
	m.handlers = &value
}

// Handlers returns the value of the "handlers" field in the mutation.
func (m *NodeMutation) Handlers() (r map[string]interface{}, exists bool) {
	v := m.handlers
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlers returns the old "handlers" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldHandlers(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlers: %w", err)
	}
	return oldValue.Handlers, nil
}

// ClearHandlers clears the value of the "handlers" field.
func (m *NodeMutation) ClearHandlers() {
	m.handlers = nil
	m.clearedFields[node.FieldHandlers] = struct{}{}
}

// HandlersCleared returns if the "handlers" field was cleared in this mutation.
func (m *NodeMutation) HandlersCleared() bool {
	_, ok := m.clearedFields[node.FieldHandlers]
	return ok
}

// ResetHandlers resets all changes to the "handlers" field.
func (m *NodeMutation) ResetHandlers() {
	m.handlers = nil
	delete(m.clearedFields, node.FieldHandlers)
}

// SetListeners sets the "listeners" field.
func (m *NodeMutation) SetListeners(value map[string]interface{}) {
	m.listeners = &value
}

// Listeners returns the value of the "listeners" field in the mutation.
func (m *NodeMutation) Listeners() (r map[string]interface{}, exists bool) {
	v := m.listeners
	if v == nil {
		return
	}
	return *v, true
}

// OldListeners returns the old "listeners" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldListeners(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListeners is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListeners requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListeners: %w", err)
	}
	return oldValue.Listeners, nil
}

// ClearListeners clears the value of the "listeners" field.
func (m *NodeMutation) ClearListeners() {
	m.listeners = nil
	m.clearedFields[node.FieldListeners] = struct{}{}
}

// ListenersCleared returns if the "listeners" field was cleared in this mutation.
func (m *NodeMutation) ListenersCleared() bool {
	_, ok := m.clearedFields[node.FieldListeners]
	return ok
}

// ResetListeners resets all changes to the "listeners" field.
func (m *NodeMutation) ResetListeners() {
	m.listeners = nil
	delete(m.clearedFields, node.FieldListeners)
}

// SetHooks sets the "hooks" field.
func (m *NodeMutation) SetHooks(value map[string]interface{}) {
	m._hooks = &value
}

// Hooks returns the value of the "hooks" field in the mutation.
func (m *NodeMutation) Hooks() (r map[string]interface{}, exists bool) {
	v := m._hooks
	if v == nil {
		return
	}
	return *v, true
}

// OldHooks returns the old "hooks" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldHooks(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHooks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHooks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHooks: %w", err)
	}
	return oldValue.Hooks, nil
}

// ClearHooks clears the value of the "hooks" field.
func (m *NodeMutation) ClearHooks() {
	m._hooks = nil
	m.clearedFields[node.FieldHooks] = struct{}{}
}

// HooksCleared returns if the "hooks" field was cleared in this mutation.
func (m *NodeMutation) HooksCleared() bool {
	_, ok := m.clearedFields[node.FieldHooks]
	return ok
}

// ResetHooks resets all changes to the "hooks" field.
func (m *NodeMutation) ResetHooks() {
	m._hooks = nil
	delete(m.clearedFields, node.FieldHooks)
}

// SetVariables sets the "variables" field.
func (m *NodeMutation) SetVariables(value map[string]interface{}) {
	m.variables = &value
}

// Variables returns the value of the "variables" field in the mutation.
func (m *NodeMutation) Variables() (r map[string]interface{}, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ClearVariables clears the value of the "variables" field.
func (m *NodeMutation) ClearVariables() {
	m.variables = nil
	m.clearedFields[node.FieldVariables] = struct{}{}
}

// VariablesCleared returns if the "variables" field was cleared in this mutation.
func (m *NodeMutation) VariablesCleared() bool {
	_, ok := m.clearedFields[node.FieldVariables]
	return ok
}

// ResetVariables resets all changes to the "variables" field.
func (m *NodeMutation) ResetVariables() {
	m.variables = nil
	delete(m.clearedFields, node.FieldVariables)
}

// SetRetryTimes sets the "retry_times" field.
func (m *NodeMutation) SetRetryTimes(i int) {
	m.retry_times = &i
	m.addretry_times = nil
}

// RetryTimes returns the value of the "retry_times" field in the mutation.
func (m *NodeMutation) RetryTimes() (r int, exists bool) {
	v := m.retry_times
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryTimes returns the old "retry_times" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldRetryTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryTimes: %w", err)
	}
	return oldValue.RetryTimes, nil
}

// AddRetryTimes adds i to the "retry_times" field.
func (m *NodeMutation) AddRetryTimes(i int) {
	if m.addretry_times != nil {
		*m.addretry_times += i
	} else {
		m.addretry_times = &i
	}
}

// AddedRetryTimes returns the value that was added to the "retry_times" field in this mutation.
func (m *NodeMutation) AddedRetryTimes() (r int, exists bool) {
	v := m.addretry_times
	if v == nil {
		return
	}
	return *v, true
}

// ClearRetryTimes clears the value of the "retry_times" field.
func (m *NodeMutation) ClearRetryTimes() {
	m.retry_times = nil
	m.addretry_times = nil
	m.clearedFields[node.FieldRetryTimes] = struct{}{}
}

// RetryTimesCleared returns if the "retry_times" field was cleared in this mutation.
func (m *NodeMutation) RetryTimesCleared() bool {
	_, ok := m.clearedFields[node.FieldRetryTimes]
	return ok
}

// ResetRetryTimes resets all changes to the "retry_times" field.
func (m *NodeMutation) ResetRetryTimes() {
	m.retry_times = nil
	m.addretry_times = nil
	delete(m.clearedFields, node.FieldRetryTimes)
}

// SetRetryInterval sets the "retry_interval" field.
func (m *NodeMutation) SetRetryInterval(i int) {
	m.retry_interval = &i
	m.addretry_interval = nil
}

// RetryInterval returns the value of the "retry_interval" field in the mutation.
func (m *NodeMutation) RetryInterval() (r int, exists bool) {
	v := m.retry_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryInterval returns the old "retry_interval" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldRetryInterval(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryInterval: %w", err)
	}
	return oldValue.RetryInterval, nil
}

// AddRetryInterval adds i to the "retry_interval" field.
func (m *NodeMutation) AddRetryInterval(i int) {
	if m.addretry_interval != nil {
		*m.addretry_interval += i
	} else {
		m.addretry_interval = &i
	}
}

// AddedRetryInterval returns the value that was added to the "retry_interval" field in this mutation.
func (m *NodeMutation) AddedRetryInterval() (r int, exists bool) {
	v := m.addretry_interval
	if v == nil {
		return
	}
	return *v, true
}

// ClearRetryInterval clears the value of the "retry_interval" field.
func (m *NodeMutation) ClearRetryInterval() {
	m.retry_interval = nil
	m.addretry_interval = nil
	m.clearedFields[node.FieldRetryInterval] = struct{}{}
}

// RetryIntervalCleared returns if the "retry_interval" field was cleared in this mutation.
func (m *NodeMutation) RetryIntervalCleared() bool {
	_, ok := m.clearedFields[node.FieldRetryInterval]
	return ok
}

// ResetRetryInterval resets all changes to the "retry_interval" field.
func (m *NodeMutation) ResetRetryInterval() {
	m.retry_interval = nil
	m.addretry_interval = nil
	delete(m.clearedFields, node.FieldRetryInterval)
}

// SetIsWorkingDay sets the "is_working_day" field.
func (m *NodeMutation) SetIsWorkingDay(b bool) {
	m.is_working_day = &b
}

// IsWorkingDay returns the value of the "is_working_day" field in the mutation.
func (m *NodeMutation) IsWorkingDay() (r bool, exists bool) {
	v := m.is_working_day
	if v == nil {
		return
	}
	return *v, true
}

// OldIsWorkingDay returns the old "is_working_day" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIsWorkingDay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsWorkingDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsWorkingDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsWorkingDay: %w", err)
	}
	return oldValue.IsWorkingDay, nil
}

// ResetIsWorkingDay resets all changes to the "is_working_day" field.
func (m *NodeMutation) ResetIsWorkingDay() {
	m.is_working_day = nil
}

// Where appends a list predicates to the NodeMutation builder.
func (m *NodeMutation) Where(ps ...predicate.Node) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Node, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Node).
func (m *NodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeMutation) Fields() []string {
	fields := make([]string, 0, 57)
	if m.name != nil {
		fields = append(fields, node.FieldName)
	}
	if m.description != nil {
		fields = append(fields, node.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, node.FieldType)
	}
	if m.status != nil {
		fields = append(fields, node.FieldStatus)
	}
	if m.node_key != nil {
		fields = append(fields, node.FieldNodeKey)
	}
	if m.node_type != nil {
		fields = append(fields, node.FieldNodeType)
	}
	if m.node_config != nil {
		fields = append(fields, node.FieldNodeConfig)
	}
	if m.node_rules != nil {
		fields = append(fields, node.FieldNodeRules)
	}
	if m.node_events != nil {
		fields = append(fields, node.FieldNodeEvents)
	}
	if m.form_code != nil {
		fields = append(fields, node.FieldFormCode)
	}
	if m.form_version != nil {
		fields = append(fields, node.FieldFormVersion)
	}
	if m.form_config != nil {
		fields = append(fields, node.FieldFormConfig)
	}
	if m.form_permissions != nil {
		fields = append(fields, node.FieldFormPermissions)
	}
	if m.field_permissions != nil {
		fields = append(fields, node.FieldFieldPermissions)
	}
	if m.assignees != nil {
		fields = append(fields, node.FieldAssignees)
	}
	if m.candidates != nil {
		fields = append(fields, node.FieldCandidates)
	}
	if m.delegated_from != nil {
		fields = append(fields, node.FieldDelegatedFrom)
	}
	if m.delegated_reason != nil {
		fields = append(fields, node.FieldDelegatedReason)
	}
	if m.is_delegated != nil {
		fields = append(fields, node.FieldIsDelegated)
	}
	if m.is_transferred != nil {
		fields = append(fields, node.FieldIsTransferred)
	}
	if m.allow_cancel != nil {
		fields = append(fields, node.FieldAllowCancel)
	}
	if m.allow_urge != nil {
		fields = append(fields, node.FieldAllowUrge)
	}
	if m.allow_delegate != nil {
		fields = append(fields, node.FieldAllowDelegate)
	}
	if m.allow_transfer != nil {
		fields = append(fields, node.FieldAllowTransfer)
	}
	if m.is_draft_enabled != nil {
		fields = append(fields, node.FieldIsDraftEnabled)
	}
	if m.is_auto_start != nil {
		fields = append(fields, node.FieldIsAutoStart)
	}
	if m.strict_mode != nil {
		fields = append(fields, node.FieldStrictMode)
	}
	if m.start_time != nil {
		fields = append(fields, node.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, node.FieldEndTime)
	}
	if m.due_time != nil {
		fields = append(fields, node.FieldDueTime)
	}
	if m.duration != nil {
		fields = append(fields, node.FieldDuration)
	}
	if m.priority != nil {
		fields = append(fields, node.FieldPriority)
	}
	if m.is_timeout != nil {
		fields = append(fields, node.FieldIsTimeout)
	}
	if m.reminder_count != nil {
		fields = append(fields, node.FieldReminderCount)
	}
	if m.extras != nil {
		fields = append(fields, node.FieldExtras)
	}
	if m.tenant_id != nil {
		fields = append(fields, node.FieldTenantID)
	}
	if m.created_by != nil {
		fields = append(fields, node.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, node.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, node.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, node.FieldUpdatedAt)
	}
	if m.process_id != nil {
		fields = append(fields, node.FieldProcessID)
	}
	if m.permissions != nil {
		fields = append(fields, node.FieldPermissions)
	}
	if m.prev_nodes != nil {
		fields = append(fields, node.FieldPrevNodes)
	}
	if m.next_nodes != nil {
		fields = append(fields, node.FieldNextNodes)
	}
	if m.parallel_nodes != nil {
		fields = append(fields, node.FieldParallelNodes)
	}
	if m.branch_nodes != nil {
		fields = append(fields, node.FieldBranchNodes)
	}
	if m.conditions != nil {
		fields = append(fields, node.FieldConditions)
	}
	if m.properties != nil {
		fields = append(fields, node.FieldProperties)
	}
	if m.is_countersign != nil {
		fields = append(fields, node.FieldIsCountersign)
	}
	if m.countersign_rule != nil {
		fields = append(fields, node.FieldCountersignRule)
	}
	if m.handlers != nil {
		fields = append(fields, node.FieldHandlers)
	}
	if m.listeners != nil {
		fields = append(fields, node.FieldListeners)
	}
	if m._hooks != nil {
		fields = append(fields, node.FieldHooks)
	}
	if m.variables != nil {
		fields = append(fields, node.FieldVariables)
	}
	if m.retry_times != nil {
		fields = append(fields, node.FieldRetryTimes)
	}
	if m.retry_interval != nil {
		fields = append(fields, node.FieldRetryInterval)
	}
	if m.is_working_day != nil {
		fields = append(fields, node.FieldIsWorkingDay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case node.FieldName:
		return m.Name()
	case node.FieldDescription:
		return m.Description()
	case node.FieldType:
		return m.GetType()
	case node.FieldStatus:
		return m.Status()
	case node.FieldNodeKey:
		return m.NodeKey()
	case node.FieldNodeType:
		return m.NodeType()
	case node.FieldNodeConfig:
		return m.NodeConfig()
	case node.FieldNodeRules:
		return m.NodeRules()
	case node.FieldNodeEvents:
		return m.NodeEvents()
	case node.FieldFormCode:
		return m.FormCode()
	case node.FieldFormVersion:
		return m.FormVersion()
	case node.FieldFormConfig:
		return m.FormConfig()
	case node.FieldFormPermissions:
		return m.FormPermissions()
	case node.FieldFieldPermissions:
		return m.FieldPermissions()
	case node.FieldAssignees:
		return m.Assignees()
	case node.FieldCandidates:
		return m.Candidates()
	case node.FieldDelegatedFrom:
		return m.DelegatedFrom()
	case node.FieldDelegatedReason:
		return m.DelegatedReason()
	case node.FieldIsDelegated:
		return m.IsDelegated()
	case node.FieldIsTransferred:
		return m.IsTransferred()
	case node.FieldAllowCancel:
		return m.AllowCancel()
	case node.FieldAllowUrge:
		return m.AllowUrge()
	case node.FieldAllowDelegate:
		return m.AllowDelegate()
	case node.FieldAllowTransfer:
		return m.AllowTransfer()
	case node.FieldIsDraftEnabled:
		return m.IsDraftEnabled()
	case node.FieldIsAutoStart:
		return m.IsAutoStart()
	case node.FieldStrictMode:
		return m.StrictMode()
	case node.FieldStartTime:
		return m.StartTime()
	case node.FieldEndTime:
		return m.EndTime()
	case node.FieldDueTime:
		return m.DueTime()
	case node.FieldDuration:
		return m.Duration()
	case node.FieldPriority:
		return m.Priority()
	case node.FieldIsTimeout:
		return m.IsTimeout()
	case node.FieldReminderCount:
		return m.ReminderCount()
	case node.FieldExtras:
		return m.Extras()
	case node.FieldTenantID:
		return m.TenantID()
	case node.FieldCreatedBy:
		return m.CreatedBy()
	case node.FieldUpdatedBy:
		return m.UpdatedBy()
	case node.FieldCreatedAt:
		return m.CreatedAt()
	case node.FieldUpdatedAt:
		return m.UpdatedAt()
	case node.FieldProcessID:
		return m.ProcessID()
	case node.FieldPermissions:
		return m.Permissions()
	case node.FieldPrevNodes:
		return m.PrevNodes()
	case node.FieldNextNodes:
		return m.NextNodes()
	case node.FieldParallelNodes:
		return m.ParallelNodes()
	case node.FieldBranchNodes:
		return m.BranchNodes()
	case node.FieldConditions:
		return m.Conditions()
	case node.FieldProperties:
		return m.Properties()
	case node.FieldIsCountersign:
		return m.IsCountersign()
	case node.FieldCountersignRule:
		return m.CountersignRule()
	case node.FieldHandlers:
		return m.Handlers()
	case node.FieldListeners:
		return m.Listeners()
	case node.FieldHooks:
		return m.Hooks()
	case node.FieldVariables:
		return m.Variables()
	case node.FieldRetryTimes:
		return m.RetryTimes()
	case node.FieldRetryInterval:
		return m.RetryInterval()
	case node.FieldIsWorkingDay:
		return m.IsWorkingDay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case node.FieldName:
		return m.OldName(ctx)
	case node.FieldDescription:
		return m.OldDescription(ctx)
	case node.FieldType:
		return m.OldType(ctx)
	case node.FieldStatus:
		return m.OldStatus(ctx)
	case node.FieldNodeKey:
		return m.OldNodeKey(ctx)
	case node.FieldNodeType:
		return m.OldNodeType(ctx)
	case node.FieldNodeConfig:
		return m.OldNodeConfig(ctx)
	case node.FieldNodeRules:
		return m.OldNodeRules(ctx)
	case node.FieldNodeEvents:
		return m.OldNodeEvents(ctx)
	case node.FieldFormCode:
		return m.OldFormCode(ctx)
	case node.FieldFormVersion:
		return m.OldFormVersion(ctx)
	case node.FieldFormConfig:
		return m.OldFormConfig(ctx)
	case node.FieldFormPermissions:
		return m.OldFormPermissions(ctx)
	case node.FieldFieldPermissions:
		return m.OldFieldPermissions(ctx)
	case node.FieldAssignees:
		return m.OldAssignees(ctx)
	case node.FieldCandidates:
		return m.OldCandidates(ctx)
	case node.FieldDelegatedFrom:
		return m.OldDelegatedFrom(ctx)
	case node.FieldDelegatedReason:
		return m.OldDelegatedReason(ctx)
	case node.FieldIsDelegated:
		return m.OldIsDelegated(ctx)
	case node.FieldIsTransferred:
		return m.OldIsTransferred(ctx)
	case node.FieldAllowCancel:
		return m.OldAllowCancel(ctx)
	case node.FieldAllowUrge:
		return m.OldAllowUrge(ctx)
	case node.FieldAllowDelegate:
		return m.OldAllowDelegate(ctx)
	case node.FieldAllowTransfer:
		return m.OldAllowTransfer(ctx)
	case node.FieldIsDraftEnabled:
		return m.OldIsDraftEnabled(ctx)
	case node.FieldIsAutoStart:
		return m.OldIsAutoStart(ctx)
	case node.FieldStrictMode:
		return m.OldStrictMode(ctx)
	case node.FieldStartTime:
		return m.OldStartTime(ctx)
	case node.FieldEndTime:
		return m.OldEndTime(ctx)
	case node.FieldDueTime:
		return m.OldDueTime(ctx)
	case node.FieldDuration:
		return m.OldDuration(ctx)
	case node.FieldPriority:
		return m.OldPriority(ctx)
	case node.FieldIsTimeout:
		return m.OldIsTimeout(ctx)
	case node.FieldReminderCount:
		return m.OldReminderCount(ctx)
	case node.FieldExtras:
		return m.OldExtras(ctx)
	case node.FieldTenantID:
		return m.OldTenantID(ctx)
	case node.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case node.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case node.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case node.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case node.FieldProcessID:
		return m.OldProcessID(ctx)
	case node.FieldPermissions:
		return m.OldPermissions(ctx)
	case node.FieldPrevNodes:
		return m.OldPrevNodes(ctx)
	case node.FieldNextNodes:
		return m.OldNextNodes(ctx)
	case node.FieldParallelNodes:
		return m.OldParallelNodes(ctx)
	case node.FieldBranchNodes:
		return m.OldBranchNodes(ctx)
	case node.FieldConditions:
		return m.OldConditions(ctx)
	case node.FieldProperties:
		return m.OldProperties(ctx)
	case node.FieldIsCountersign:
		return m.OldIsCountersign(ctx)
	case node.FieldCountersignRule:
		return m.OldCountersignRule(ctx)
	case node.FieldHandlers:
		return m.OldHandlers(ctx)
	case node.FieldListeners:
		return m.OldListeners(ctx)
	case node.FieldHooks:
		return m.OldHooks(ctx)
	case node.FieldVariables:
		return m.OldVariables(ctx)
	case node.FieldRetryTimes:
		return m.OldRetryTimes(ctx)
	case node.FieldRetryInterval:
		return m.OldRetryInterval(ctx)
	case node.FieldIsWorkingDay:
		return m.OldIsWorkingDay(ctx)
	}
	return nil, fmt.Errorf("unknown Node field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case node.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case node.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case node.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case node.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case node.FieldNodeKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeKey(v)
		return nil
	case node.FieldNodeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeType(v)
		return nil
	case node.FieldNodeConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeConfig(v)
		return nil
	case node.FieldNodeRules:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeRules(v)
		return nil
	case node.FieldNodeEvents:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeEvents(v)
		return nil
	case node.FieldFormCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormCode(v)
		return nil
	case node.FieldFormVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormVersion(v)
		return nil
	case node.FieldFormConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormConfig(v)
		return nil
	case node.FieldFormPermissions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormPermissions(v)
		return nil
	case node.FieldFieldPermissions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldPermissions(v)
		return nil
	case node.FieldAssignees:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignees(v)
		return nil
	case node.FieldCandidates:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidates(v)
		return nil
	case node.FieldDelegatedFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegatedFrom(v)
		return nil
	case node.FieldDelegatedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegatedReason(v)
		return nil
	case node.FieldIsDelegated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDelegated(v)
		return nil
	case node.FieldIsTransferred:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTransferred(v)
		return nil
	case node.FieldAllowCancel:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowCancel(v)
		return nil
	case node.FieldAllowUrge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowUrge(v)
		return nil
	case node.FieldAllowDelegate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowDelegate(v)
		return nil
	case node.FieldAllowTransfer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowTransfer(v)
		return nil
	case node.FieldIsDraftEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDraftEnabled(v)
		return nil
	case node.FieldIsAutoStart:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutoStart(v)
		return nil
	case node.FieldStrictMode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrictMode(v)
		return nil
	case node.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case node.FieldEndTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case node.FieldDueTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueTime(v)
		return nil
	case node.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case node.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case node.FieldIsTimeout:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTimeout(v)
		return nil
	case node.FieldReminderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReminderCount(v)
		return nil
	case node.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case node.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case node.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case node.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case node.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case node.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case node.FieldProcessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessID(v)
		return nil
	case node.FieldPermissions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case node.FieldPrevNodes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrevNodes(v)
		return nil
	case node.FieldNextNodes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextNodes(v)
		return nil
	case node.FieldParallelNodes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParallelNodes(v)
		return nil
	case node.FieldBranchNodes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchNodes(v)
		return nil
	case node.FieldConditions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case node.FieldProperties:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProperties(v)
		return nil
	case node.FieldIsCountersign:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCountersign(v)
		return nil
	case node.FieldCountersignRule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountersignRule(v)
		return nil
	case node.FieldHandlers:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlers(v)
		return nil
	case node.FieldListeners:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListeners(v)
		return nil
	case node.FieldHooks:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHooks(v)
		return nil
	case node.FieldVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case node.FieldRetryTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryTimes(v)
		return nil
	case node.FieldRetryInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryInterval(v)
		return nil
	case node.FieldIsWorkingDay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsWorkingDay(v)
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeMutation) AddedFields() []string {
	var fields []string
	if m.addstart_time != nil {
		fields = append(fields, node.FieldStartTime)
	}
	if m.addend_time != nil {
		fields = append(fields, node.FieldEndTime)
	}
	if m.adddue_time != nil {
		fields = append(fields, node.FieldDueTime)
	}
	if m.addduration != nil {
		fields = append(fields, node.FieldDuration)
	}
	if m.addpriority != nil {
		fields = append(fields, node.FieldPriority)
	}
	if m.addreminder_count != nil {
		fields = append(fields, node.FieldReminderCount)
	}
	if m.addcreated_at != nil {
		fields = append(fields, node.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, node.FieldUpdatedAt)
	}
	if m.addretry_times != nil {
		fields = append(fields, node.FieldRetryTimes)
	}
	if m.addretry_interval != nil {
		fields = append(fields, node.FieldRetryInterval)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case node.FieldStartTime:
		return m.AddedStartTime()
	case node.FieldEndTime:
		return m.AddedEndTime()
	case node.FieldDueTime:
		return m.AddedDueTime()
	case node.FieldDuration:
		return m.AddedDuration()
	case node.FieldPriority:
		return m.AddedPriority()
	case node.FieldReminderCount:
		return m.AddedReminderCount()
	case node.FieldCreatedAt:
		return m.AddedCreatedAt()
	case node.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case node.FieldRetryTimes:
		return m.AddedRetryTimes()
	case node.FieldRetryInterval:
		return m.AddedRetryInterval()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case node.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTime(v)
		return nil
	case node.FieldEndTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndTime(v)
		return nil
	case node.FieldDueTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDueTime(v)
		return nil
	case node.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case node.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case node.FieldReminderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReminderCount(v)
		return nil
	case node.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case node.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case node.FieldRetryTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryTimes(v)
		return nil
	case node.FieldRetryInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryInterval(v)
		return nil
	}
	return fmt.Errorf("unknown Node numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(node.FieldName) {
		fields = append(fields, node.FieldName)
	}
	if m.FieldCleared(node.FieldDescription) {
		fields = append(fields, node.FieldDescription)
	}
	if m.FieldCleared(node.FieldType) {
		fields = append(fields, node.FieldType)
	}
	if m.FieldCleared(node.FieldStatus) {
		fields = append(fields, node.FieldStatus)
	}
	if m.FieldCleared(node.FieldNodeConfig) {
		fields = append(fields, node.FieldNodeConfig)
	}
	if m.FieldCleared(node.FieldNodeRules) {
		fields = append(fields, node.FieldNodeRules)
	}
	if m.FieldCleared(node.FieldNodeEvents) {
		fields = append(fields, node.FieldNodeEvents)
	}
	if m.FieldCleared(node.FieldFormVersion) {
		fields = append(fields, node.FieldFormVersion)
	}
	if m.FieldCleared(node.FieldFormConfig) {
		fields = append(fields, node.FieldFormConfig)
	}
	if m.FieldCleared(node.FieldFormPermissions) {
		fields = append(fields, node.FieldFormPermissions)
	}
	if m.FieldCleared(node.FieldFieldPermissions) {
		fields = append(fields, node.FieldFieldPermissions)
	}
	if m.FieldCleared(node.FieldDelegatedFrom) {
		fields = append(fields, node.FieldDelegatedFrom)
	}
	if m.FieldCleared(node.FieldDelegatedReason) {
		fields = append(fields, node.FieldDelegatedReason)
	}
	if m.FieldCleared(node.FieldEndTime) {
		fields = append(fields, node.FieldEndTime)
	}
	if m.FieldCleared(node.FieldDueTime) {
		fields = append(fields, node.FieldDueTime)
	}
	if m.FieldCleared(node.FieldDuration) {
		fields = append(fields, node.FieldDuration)
	}
	if m.FieldCleared(node.FieldExtras) {
		fields = append(fields, node.FieldExtras)
	}
	if m.FieldCleared(node.FieldTenantID) {
		fields = append(fields, node.FieldTenantID)
	}
	if m.FieldCleared(node.FieldCreatedBy) {
		fields = append(fields, node.FieldCreatedBy)
	}
	if m.FieldCleared(node.FieldUpdatedBy) {
		fields = append(fields, node.FieldUpdatedBy)
	}
	if m.FieldCleared(node.FieldCreatedAt) {
		fields = append(fields, node.FieldCreatedAt)
	}
	if m.FieldCleared(node.FieldUpdatedAt) {
		fields = append(fields, node.FieldUpdatedAt)
	}
	if m.FieldCleared(node.FieldPrevNodes) {
		fields = append(fields, node.FieldPrevNodes)
	}
	if m.FieldCleared(node.FieldNextNodes) {
		fields = append(fields, node.FieldNextNodes)
	}
	if m.FieldCleared(node.FieldParallelNodes) {
		fields = append(fields, node.FieldParallelNodes)
	}
	if m.FieldCleared(node.FieldBranchNodes) {
		fields = append(fields, node.FieldBranchNodes)
	}
	if m.FieldCleared(node.FieldConditions) {
		fields = append(fields, node.FieldConditions)
	}
	if m.FieldCleared(node.FieldProperties) {
		fields = append(fields, node.FieldProperties)
	}
	if m.FieldCleared(node.FieldCountersignRule) {
		fields = append(fields, node.FieldCountersignRule)
	}
	if m.FieldCleared(node.FieldHandlers) {
		fields = append(fields, node.FieldHandlers)
	}
	if m.FieldCleared(node.FieldListeners) {
		fields = append(fields, node.FieldListeners)
	}
	if m.FieldCleared(node.FieldHooks) {
		fields = append(fields, node.FieldHooks)
	}
	if m.FieldCleared(node.FieldVariables) {
		fields = append(fields, node.FieldVariables)
	}
	if m.FieldCleared(node.FieldRetryTimes) {
		fields = append(fields, node.FieldRetryTimes)
	}
	if m.FieldCleared(node.FieldRetryInterval) {
		fields = append(fields, node.FieldRetryInterval)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeMutation) ClearField(name string) error {
	switch name {
	case node.FieldName:
		m.ClearName()
		return nil
	case node.FieldDescription:
		m.ClearDescription()
		return nil
	case node.FieldType:
		m.ClearType()
		return nil
	case node.FieldStatus:
		m.ClearStatus()
		return nil
	case node.FieldNodeConfig:
		m.ClearNodeConfig()
		return nil
	case node.FieldNodeRules:
		m.ClearNodeRules()
		return nil
	case node.FieldNodeEvents:
		m.ClearNodeEvents()
		return nil
	case node.FieldFormVersion:
		m.ClearFormVersion()
		return nil
	case node.FieldFormConfig:
		m.ClearFormConfig()
		return nil
	case node.FieldFormPermissions:
		m.ClearFormPermissions()
		return nil
	case node.FieldFieldPermissions:
		m.ClearFieldPermissions()
		return nil
	case node.FieldDelegatedFrom:
		m.ClearDelegatedFrom()
		return nil
	case node.FieldDelegatedReason:
		m.ClearDelegatedReason()
		return nil
	case node.FieldEndTime:
		m.ClearEndTime()
		return nil
	case node.FieldDueTime:
		m.ClearDueTime()
		return nil
	case node.FieldDuration:
		m.ClearDuration()
		return nil
	case node.FieldExtras:
		m.ClearExtras()
		return nil
	case node.FieldTenantID:
		m.ClearTenantID()
		return nil
	case node.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case node.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case node.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case node.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case node.FieldPrevNodes:
		m.ClearPrevNodes()
		return nil
	case node.FieldNextNodes:
		m.ClearNextNodes()
		return nil
	case node.FieldParallelNodes:
		m.ClearParallelNodes()
		return nil
	case node.FieldBranchNodes:
		m.ClearBranchNodes()
		return nil
	case node.FieldConditions:
		m.ClearConditions()
		return nil
	case node.FieldProperties:
		m.ClearProperties()
		return nil
	case node.FieldCountersignRule:
		m.ClearCountersignRule()
		return nil
	case node.FieldHandlers:
		m.ClearHandlers()
		return nil
	case node.FieldListeners:
		m.ClearListeners()
		return nil
	case node.FieldHooks:
		m.ClearHooks()
		return nil
	case node.FieldVariables:
		m.ClearVariables()
		return nil
	case node.FieldRetryTimes:
		m.ClearRetryTimes()
		return nil
	case node.FieldRetryInterval:
		m.ClearRetryInterval()
		return nil
	}
	return fmt.Errorf("unknown Node nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeMutation) ResetField(name string) error {
	switch name {
	case node.FieldName:
		m.ResetName()
		return nil
	case node.FieldDescription:
		m.ResetDescription()
		return nil
	case node.FieldType:
		m.ResetType()
		return nil
	case node.FieldStatus:
		m.ResetStatus()
		return nil
	case node.FieldNodeKey:
		m.ResetNodeKey()
		return nil
	case node.FieldNodeType:
		m.ResetNodeType()
		return nil
	case node.FieldNodeConfig:
		m.ResetNodeConfig()
		return nil
	case node.FieldNodeRules:
		m.ResetNodeRules()
		return nil
	case node.FieldNodeEvents:
		m.ResetNodeEvents()
		return nil
	case node.FieldFormCode:
		m.ResetFormCode()
		return nil
	case node.FieldFormVersion:
		m.ResetFormVersion()
		return nil
	case node.FieldFormConfig:
		m.ResetFormConfig()
		return nil
	case node.FieldFormPermissions:
		m.ResetFormPermissions()
		return nil
	case node.FieldFieldPermissions:
		m.ResetFieldPermissions()
		return nil
	case node.FieldAssignees:
		m.ResetAssignees()
		return nil
	case node.FieldCandidates:
		m.ResetCandidates()
		return nil
	case node.FieldDelegatedFrom:
		m.ResetDelegatedFrom()
		return nil
	case node.FieldDelegatedReason:
		m.ResetDelegatedReason()
		return nil
	case node.FieldIsDelegated:
		m.ResetIsDelegated()
		return nil
	case node.FieldIsTransferred:
		m.ResetIsTransferred()
		return nil
	case node.FieldAllowCancel:
		m.ResetAllowCancel()
		return nil
	case node.FieldAllowUrge:
		m.ResetAllowUrge()
		return nil
	case node.FieldAllowDelegate:
		m.ResetAllowDelegate()
		return nil
	case node.FieldAllowTransfer:
		m.ResetAllowTransfer()
		return nil
	case node.FieldIsDraftEnabled:
		m.ResetIsDraftEnabled()
		return nil
	case node.FieldIsAutoStart:
		m.ResetIsAutoStart()
		return nil
	case node.FieldStrictMode:
		m.ResetStrictMode()
		return nil
	case node.FieldStartTime:
		m.ResetStartTime()
		return nil
	case node.FieldEndTime:
		m.ResetEndTime()
		return nil
	case node.FieldDueTime:
		m.ResetDueTime()
		return nil
	case node.FieldDuration:
		m.ResetDuration()
		return nil
	case node.FieldPriority:
		m.ResetPriority()
		return nil
	case node.FieldIsTimeout:
		m.ResetIsTimeout()
		return nil
	case node.FieldReminderCount:
		m.ResetReminderCount()
		return nil
	case node.FieldExtras:
		m.ResetExtras()
		return nil
	case node.FieldTenantID:
		m.ResetTenantID()
		return nil
	case node.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case node.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case node.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case node.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case node.FieldProcessID:
		m.ResetProcessID()
		return nil
	case node.FieldPermissions:
		m.ResetPermissions()
		return nil
	case node.FieldPrevNodes:
		m.ResetPrevNodes()
		return nil
	case node.FieldNextNodes:
		m.ResetNextNodes()
		return nil
	case node.FieldParallelNodes:
		m.ResetParallelNodes()
		return nil
	case node.FieldBranchNodes:
		m.ResetBranchNodes()
		return nil
	case node.FieldConditions:
		m.ResetConditions()
		return nil
	case node.FieldProperties:
		m.ResetProperties()
		return nil
	case node.FieldIsCountersign:
		m.ResetIsCountersign()
		return nil
	case node.FieldCountersignRule:
		m.ResetCountersignRule()
		return nil
	case node.FieldHandlers:
		m.ResetHandlers()
		return nil
	case node.FieldListeners:
		m.ResetListeners()
		return nil
	case node.FieldHooks:
		m.ResetHooks()
		return nil
	case node.FieldVariables:
		m.ResetVariables()
		return nil
	case node.FieldRetryTimes:
		m.ResetRetryTimes()
		return nil
	case node.FieldRetryInterval:
		m.ResetRetryInterval()
		return nil
	case node.FieldIsWorkingDay:
		m.ResetIsWorkingDay()
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Node unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Node edge %s", name)
}

// ProcessMutation represents an operation that mutates the Process nodes in the graph.
type ProcessMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	status              *string
	process_id          *string
	template_id         *string
	business_key        *string
	form_code           *string
	form_version        *string
	form_config         *map[string]interface{}
	form_permissions    *map[string]interface{}
	field_permissions   *map[string]interface{}
	business_tags       *[]string
	appendbusiness_tags []string
	module_code         *string
	category            *string
	flow_status         *string
	flow_variables      *map[string]interface{}
	is_draft            *bool
	is_terminated       *bool
	is_suspended        *bool
	suspend_reason      *string
	start_time          *int64
	addstart_time       *int64
	end_time            *int64
	addend_time         *int64
	due_time            *int64
	adddue_time         *int64
	duration            *int
	addduration         *int
	priority            *int
	addpriority         *int
	is_timeout          *bool
	reminder_count      *int
	addreminder_count   *int
	allow_cancel        *bool
	allow_urge          *bool
	allow_delegate      *bool
	allow_transfer      *bool
	is_draft_enabled    *bool
	is_auto_start       *bool
	strict_mode         *bool
	extras              *map[string]interface{}
	tenant_id           *string
	created_by          *string
	updated_by          *string
	created_at          *int64
	addcreated_at       *int64
	updated_at          *int64
	addupdated_at       *int64
	process_key         *string
	initiator           *string
	initiator_dept      *string
	process_code        *string
	variables           *map[string]interface{}
	current_node        *string
	active_nodes        *[]string
	appendactive_nodes  []string
	process_snapshot    *map[string]interface{}
	form_snapshot       *map[string]interface{}
	urge_count          *int
	addurge_count       *int
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Process, error)
	predicates          []predicate.Process
}

var _ ent.Mutation = (*ProcessMutation)(nil)

// processOption allows management of the mutation configuration using functional options.
type processOption func(*ProcessMutation)

// newProcessMutation creates new mutation for the Process entity.
func newProcessMutation(c config, op Op, opts ...processOption) *ProcessMutation {
	m := &ProcessMutation{
		config:        c,
		op:            op,
		typ:           TypeProcess,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessID sets the ID field of the mutation.
func withProcessID(id string) processOption {
	return func(m *ProcessMutation) {
		var (
			err   error
			once  sync.Once
			value *Process
		)
		m.oldValue = func(ctx context.Context) (*Process, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Process.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcess sets the old Process of the mutation.
func withProcess(node *Process) processOption {
	return func(m *ProcessMutation) {
		m.oldValue = func(context.Context) (*Process, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Process entities.
func (m *ProcessMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Process.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *ProcessMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcessMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ProcessMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[process.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ProcessMutation) StatusCleared() bool {
	_, ok := m.clearedFields[process.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcessMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, process.FieldStatus)
}

// SetProcessID sets the "process_id" field.
func (m *ProcessMutation) SetProcessID(s string) {
	m.process_id = &s
}

// ProcessID returns the value of the "process_id" field in the mutation.
func (m *ProcessMutation) ProcessID() (r string, exists bool) {
	v := m.process_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessID returns the old "process_id" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldProcessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessID: %w", err)
	}
	return oldValue.ProcessID, nil
}

// ResetProcessID resets all changes to the "process_id" field.
func (m *ProcessMutation) ResetProcessID() {
	m.process_id = nil
}

// SetTemplateID sets the "template_id" field.
func (m *ProcessMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *ProcessMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *ProcessMutation) ResetTemplateID() {
	m.template_id = nil
}

// SetBusinessKey sets the "business_key" field.
func (m *ProcessMutation) SetBusinessKey(s string) {
	m.business_key = &s
}

// BusinessKey returns the value of the "business_key" field in the mutation.
func (m *ProcessMutation) BusinessKey() (r string, exists bool) {
	v := m.business_key
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessKey returns the old "business_key" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldBusinessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessKey: %w", err)
	}
	return oldValue.BusinessKey, nil
}

// ResetBusinessKey resets all changes to the "business_key" field.
func (m *ProcessMutation) ResetBusinessKey() {
	m.business_key = nil
}

// SetFormCode sets the "form_code" field.
func (m *ProcessMutation) SetFormCode(s string) {
	m.form_code = &s
}

// FormCode returns the value of the "form_code" field in the mutation.
func (m *ProcessMutation) FormCode() (r string, exists bool) {
	v := m.form_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFormCode returns the old "form_code" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldFormCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormCode: %w", err)
	}
	return oldValue.FormCode, nil
}

// ResetFormCode resets all changes to the "form_code" field.
func (m *ProcessMutation) ResetFormCode() {
	m.form_code = nil
}

// SetFormVersion sets the "form_version" field.
func (m *ProcessMutation) SetFormVersion(s string) {
	m.form_version = &s
}

// FormVersion returns the value of the "form_version" field in the mutation.
func (m *ProcessMutation) FormVersion() (r string, exists bool) {
	v := m.form_version
	if v == nil {
		return
	}
	return *v, true
}

// OldFormVersion returns the old "form_version" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldFormVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormVersion: %w", err)
	}
	return oldValue.FormVersion, nil
}

// ClearFormVersion clears the value of the "form_version" field.
func (m *ProcessMutation) ClearFormVersion() {
	m.form_version = nil
	m.clearedFields[process.FieldFormVersion] = struct{}{}
}

// FormVersionCleared returns if the "form_version" field was cleared in this mutation.
func (m *ProcessMutation) FormVersionCleared() bool {
	_, ok := m.clearedFields[process.FieldFormVersion]
	return ok
}

// ResetFormVersion resets all changes to the "form_version" field.
func (m *ProcessMutation) ResetFormVersion() {
	m.form_version = nil
	delete(m.clearedFields, process.FieldFormVersion)
}

// SetFormConfig sets the "form_config" field.
func (m *ProcessMutation) SetFormConfig(value map[string]interface{}) {
	m.form_config = &value
}

// FormConfig returns the value of the "form_config" field in the mutation.
func (m *ProcessMutation) FormConfig() (r map[string]interface{}, exists bool) {
	v := m.form_config
	if v == nil {
		return
	}
	return *v, true
}

// OldFormConfig returns the old "form_config" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldFormConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormConfig: %w", err)
	}
	return oldValue.FormConfig, nil
}

// ClearFormConfig clears the value of the "form_config" field.
func (m *ProcessMutation) ClearFormConfig() {
	m.form_config = nil
	m.clearedFields[process.FieldFormConfig] = struct{}{}
}

// FormConfigCleared returns if the "form_config" field was cleared in this mutation.
func (m *ProcessMutation) FormConfigCleared() bool {
	_, ok := m.clearedFields[process.FieldFormConfig]
	return ok
}

// ResetFormConfig resets all changes to the "form_config" field.
func (m *ProcessMutation) ResetFormConfig() {
	m.form_config = nil
	delete(m.clearedFields, process.FieldFormConfig)
}

// SetFormPermissions sets the "form_permissions" field.
func (m *ProcessMutation) SetFormPermissions(value map[string]interface{}) {
	m.form_permissions = &value
}

// FormPermissions returns the value of the "form_permissions" field in the mutation.
func (m *ProcessMutation) FormPermissions() (r map[string]interface{}, exists bool) {
	v := m.form_permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldFormPermissions returns the old "form_permissions" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldFormPermissions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormPermissions: %w", err)
	}
	return oldValue.FormPermissions, nil
}

// ClearFormPermissions clears the value of the "form_permissions" field.
func (m *ProcessMutation) ClearFormPermissions() {
	m.form_permissions = nil
	m.clearedFields[process.FieldFormPermissions] = struct{}{}
}

// FormPermissionsCleared returns if the "form_permissions" field was cleared in this mutation.
func (m *ProcessMutation) FormPermissionsCleared() bool {
	_, ok := m.clearedFields[process.FieldFormPermissions]
	return ok
}

// ResetFormPermissions resets all changes to the "form_permissions" field.
func (m *ProcessMutation) ResetFormPermissions() {
	m.form_permissions = nil
	delete(m.clearedFields, process.FieldFormPermissions)
}

// SetFieldPermissions sets the "field_permissions" field.
func (m *ProcessMutation) SetFieldPermissions(value map[string]interface{}) {
	m.field_permissions = &value
}

// FieldPermissions returns the value of the "field_permissions" field in the mutation.
func (m *ProcessMutation) FieldPermissions() (r map[string]interface{}, exists bool) {
	v := m.field_permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldPermissions returns the old "field_permissions" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldFieldPermissions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldPermissions: %w", err)
	}
	return oldValue.FieldPermissions, nil
}

// ClearFieldPermissions clears the value of the "field_permissions" field.
func (m *ProcessMutation) ClearFieldPermissions() {
	m.field_permissions = nil
	m.clearedFields[process.FieldFieldPermissions] = struct{}{}
}

// FieldPermissionsCleared returns if the "field_permissions" field was cleared in this mutation.
func (m *ProcessMutation) FieldPermissionsCleared() bool {
	_, ok := m.clearedFields[process.FieldFieldPermissions]
	return ok
}

// ResetFieldPermissions resets all changes to the "field_permissions" field.
func (m *ProcessMutation) ResetFieldPermissions() {
	m.field_permissions = nil
	delete(m.clearedFields, process.FieldFieldPermissions)
}

// SetBusinessTags sets the "business_tags" field.
func (m *ProcessMutation) SetBusinessTags(s []string) {
	m.business_tags = &s
	m.appendbusiness_tags = nil
}

// BusinessTags returns the value of the "business_tags" field in the mutation.
func (m *ProcessMutation) BusinessTags() (r []string, exists bool) {
	v := m.business_tags
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessTags returns the old "business_tags" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldBusinessTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessTags: %w", err)
	}
	return oldValue.BusinessTags, nil
}

// AppendBusinessTags adds s to the "business_tags" field.
func (m *ProcessMutation) AppendBusinessTags(s []string) {
	m.appendbusiness_tags = append(m.appendbusiness_tags, s...)
}

// AppendedBusinessTags returns the list of values that were appended to the "business_tags" field in this mutation.
func (m *ProcessMutation) AppendedBusinessTags() ([]string, bool) {
	if len(m.appendbusiness_tags) == 0 {
		return nil, false
	}
	return m.appendbusiness_tags, true
}

// ClearBusinessTags clears the value of the "business_tags" field.
func (m *ProcessMutation) ClearBusinessTags() {
	m.business_tags = nil
	m.appendbusiness_tags = nil
	m.clearedFields[process.FieldBusinessTags] = struct{}{}
}

// BusinessTagsCleared returns if the "business_tags" field was cleared in this mutation.
func (m *ProcessMutation) BusinessTagsCleared() bool {
	_, ok := m.clearedFields[process.FieldBusinessTags]
	return ok
}

// ResetBusinessTags resets all changes to the "business_tags" field.
func (m *ProcessMutation) ResetBusinessTags() {
	m.business_tags = nil
	m.appendbusiness_tags = nil
	delete(m.clearedFields, process.FieldBusinessTags)
}

// SetModuleCode sets the "module_code" field.
func (m *ProcessMutation) SetModuleCode(s string) {
	m.module_code = &s
}

// ModuleCode returns the value of the "module_code" field in the mutation.
func (m *ProcessMutation) ModuleCode() (r string, exists bool) {
	v := m.module_code
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleCode returns the old "module_code" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldModuleCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleCode: %w", err)
	}
	return oldValue.ModuleCode, nil
}

// ResetModuleCode resets all changes to the "module_code" field.
func (m *ProcessMutation) ResetModuleCode() {
	m.module_code = nil
}

// SetCategory sets the "category" field.
func (m *ProcessMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProcessMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ProcessMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[process.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ProcessMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[process.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ProcessMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, process.FieldCategory)
}

// SetFlowStatus sets the "flow_status" field.
func (m *ProcessMutation) SetFlowStatus(s string) {
	m.flow_status = &s
}

// FlowStatus returns the value of the "flow_status" field in the mutation.
func (m *ProcessMutation) FlowStatus() (r string, exists bool) {
	v := m.flow_status
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowStatus returns the old "flow_status" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldFlowStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowStatus: %w", err)
	}
	return oldValue.FlowStatus, nil
}

// ClearFlowStatus clears the value of the "flow_status" field.
func (m *ProcessMutation) ClearFlowStatus() {
	m.flow_status = nil
	m.clearedFields[process.FieldFlowStatus] = struct{}{}
}

// FlowStatusCleared returns if the "flow_status" field was cleared in this mutation.
func (m *ProcessMutation) FlowStatusCleared() bool {
	_, ok := m.clearedFields[process.FieldFlowStatus]
	return ok
}

// ResetFlowStatus resets all changes to the "flow_status" field.
func (m *ProcessMutation) ResetFlowStatus() {
	m.flow_status = nil
	delete(m.clearedFields, process.FieldFlowStatus)
}

// SetFlowVariables sets the "flow_variables" field.
func (m *ProcessMutation) SetFlowVariables(value map[string]interface{}) {
	m.flow_variables = &value
}

// FlowVariables returns the value of the "flow_variables" field in the mutation.
func (m *ProcessMutation) FlowVariables() (r map[string]interface{}, exists bool) {
	v := m.flow_variables
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowVariables returns the old "flow_variables" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldFlowVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowVariables: %w", err)
	}
	return oldValue.FlowVariables, nil
}

// ClearFlowVariables clears the value of the "flow_variables" field.
func (m *ProcessMutation) ClearFlowVariables() {
	m.flow_variables = nil
	m.clearedFields[process.FieldFlowVariables] = struct{}{}
}

// FlowVariablesCleared returns if the "flow_variables" field was cleared in this mutation.
func (m *ProcessMutation) FlowVariablesCleared() bool {
	_, ok := m.clearedFields[process.FieldFlowVariables]
	return ok
}

// ResetFlowVariables resets all changes to the "flow_variables" field.
func (m *ProcessMutation) ResetFlowVariables() {
	m.flow_variables = nil
	delete(m.clearedFields, process.FieldFlowVariables)
}

// SetIsDraft sets the "is_draft" field.
func (m *ProcessMutation) SetIsDraft(b bool) {
	m.is_draft = &b
}

// IsDraft returns the value of the "is_draft" field in the mutation.
func (m *ProcessMutation) IsDraft() (r bool, exists bool) {
	v := m.is_draft
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDraft returns the old "is_draft" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldIsDraft(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDraft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDraft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDraft: %w", err)
	}
	return oldValue.IsDraft, nil
}

// ResetIsDraft resets all changes to the "is_draft" field.
func (m *ProcessMutation) ResetIsDraft() {
	m.is_draft = nil
}

// SetIsTerminated sets the "is_terminated" field.
func (m *ProcessMutation) SetIsTerminated(b bool) {
	m.is_terminated = &b
}

// IsTerminated returns the value of the "is_terminated" field in the mutation.
func (m *ProcessMutation) IsTerminated() (r bool, exists bool) {
	v := m.is_terminated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTerminated returns the old "is_terminated" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldIsTerminated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTerminated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTerminated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTerminated: %w", err)
	}
	return oldValue.IsTerminated, nil
}

// ResetIsTerminated resets all changes to the "is_terminated" field.
func (m *ProcessMutation) ResetIsTerminated() {
	m.is_terminated = nil
}

// SetIsSuspended sets the "is_suspended" field.
func (m *ProcessMutation) SetIsSuspended(b bool) {
	m.is_suspended = &b
}

// IsSuspended returns the value of the "is_suspended" field in the mutation.
func (m *ProcessMutation) IsSuspended() (r bool, exists bool) {
	v := m.is_suspended
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuspended returns the old "is_suspended" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldIsSuspended(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuspended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuspended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuspended: %w", err)
	}
	return oldValue.IsSuspended, nil
}

// ResetIsSuspended resets all changes to the "is_suspended" field.
func (m *ProcessMutation) ResetIsSuspended() {
	m.is_suspended = nil
}

// SetSuspendReason sets the "suspend_reason" field.
func (m *ProcessMutation) SetSuspendReason(s string) {
	m.suspend_reason = &s
}

// SuspendReason returns the value of the "suspend_reason" field in the mutation.
func (m *ProcessMutation) SuspendReason() (r string, exists bool) {
	v := m.suspend_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendReason returns the old "suspend_reason" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldSuspendReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendReason: %w", err)
	}
	return oldValue.SuspendReason, nil
}

// ClearSuspendReason clears the value of the "suspend_reason" field.
func (m *ProcessMutation) ClearSuspendReason() {
	m.suspend_reason = nil
	m.clearedFields[process.FieldSuspendReason] = struct{}{}
}

// SuspendReasonCleared returns if the "suspend_reason" field was cleared in this mutation.
func (m *ProcessMutation) SuspendReasonCleared() bool {
	_, ok := m.clearedFields[process.FieldSuspendReason]
	return ok
}

// ResetSuspendReason resets all changes to the "suspend_reason" field.
func (m *ProcessMutation) ResetSuspendReason() {
	m.suspend_reason = nil
	delete(m.clearedFields, process.FieldSuspendReason)
}

// SetStartTime sets the "start_time" field.
func (m *ProcessMutation) SetStartTime(i int64) {
	m.start_time = &i
	m.addstart_time = nil
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ProcessMutation) StartTime() (r int64, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldStartTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// AddStartTime adds i to the "start_time" field.
func (m *ProcessMutation) AddStartTime(i int64) {
	if m.addstart_time != nil {
		*m.addstart_time += i
	} else {
		m.addstart_time = &i
	}
}

// AddedStartTime returns the value that was added to the "start_time" field in this mutation.
func (m *ProcessMutation) AddedStartTime() (r int64, exists bool) {
	v := m.addstart_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ProcessMutation) ResetStartTime() {
	m.start_time = nil
	m.addstart_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ProcessMutation) SetEndTime(i int64) {
	m.end_time = &i
	m.addend_time = nil
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ProcessMutation) EndTime() (r int64, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldEndTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// AddEndTime adds i to the "end_time" field.
func (m *ProcessMutation) AddEndTime(i int64) {
	if m.addend_time != nil {
		*m.addend_time += i
	} else {
		m.addend_time = &i
	}
}

// AddedEndTime returns the value that was added to the "end_time" field in this mutation.
func (m *ProcessMutation) AddedEndTime() (r int64, exists bool) {
	v := m.addend_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ProcessMutation) ClearEndTime() {
	m.end_time = nil
	m.addend_time = nil
	m.clearedFields[process.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ProcessMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[process.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ProcessMutation) ResetEndTime() {
	m.end_time = nil
	m.addend_time = nil
	delete(m.clearedFields, process.FieldEndTime)
}

// SetDueTime sets the "due_time" field.
func (m *ProcessMutation) SetDueTime(i int64) {
	m.due_time = &i
	m.adddue_time = nil
}

// DueTime returns the value of the "due_time" field in the mutation.
func (m *ProcessMutation) DueTime() (r int64, exists bool) {
	v := m.due_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDueTime returns the old "due_time" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldDueTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueTime: %w", err)
	}
	return oldValue.DueTime, nil
}

// AddDueTime adds i to the "due_time" field.
func (m *ProcessMutation) AddDueTime(i int64) {
	if m.adddue_time != nil {
		*m.adddue_time += i
	} else {
		m.adddue_time = &i
	}
}

// AddedDueTime returns the value that was added to the "due_time" field in this mutation.
func (m *ProcessMutation) AddedDueTime() (r int64, exists bool) {
	v := m.adddue_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDueTime clears the value of the "due_time" field.
func (m *ProcessMutation) ClearDueTime() {
	m.due_time = nil
	m.adddue_time = nil
	m.clearedFields[process.FieldDueTime] = struct{}{}
}

// DueTimeCleared returns if the "due_time" field was cleared in this mutation.
func (m *ProcessMutation) DueTimeCleared() bool {
	_, ok := m.clearedFields[process.FieldDueTime]
	return ok
}

// ResetDueTime resets all changes to the "due_time" field.
func (m *ProcessMutation) ResetDueTime() {
	m.due_time = nil
	m.adddue_time = nil
	delete(m.clearedFields, process.FieldDueTime)
}

// SetDuration sets the "duration" field.
func (m *ProcessMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ProcessMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ProcessMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ProcessMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *ProcessMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[process.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *ProcessMutation) DurationCleared() bool {
	_, ok := m.clearedFields[process.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *ProcessMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, process.FieldDuration)
}

// SetPriority sets the "priority" field.
func (m *ProcessMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ProcessMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *ProcessMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *ProcessMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *ProcessMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetIsTimeout sets the "is_timeout" field.
func (m *ProcessMutation) SetIsTimeout(b bool) {
	m.is_timeout = &b
}

// IsTimeout returns the value of the "is_timeout" field in the mutation.
func (m *ProcessMutation) IsTimeout() (r bool, exists bool) {
	v := m.is_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTimeout returns the old "is_timeout" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldIsTimeout(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTimeout: %w", err)
	}
	return oldValue.IsTimeout, nil
}

// ResetIsTimeout resets all changes to the "is_timeout" field.
func (m *ProcessMutation) ResetIsTimeout() {
	m.is_timeout = nil
}

// SetReminderCount sets the "reminder_count" field.
func (m *ProcessMutation) SetReminderCount(i int) {
	m.reminder_count = &i
	m.addreminder_count = nil
}

// ReminderCount returns the value of the "reminder_count" field in the mutation.
func (m *ProcessMutation) ReminderCount() (r int, exists bool) {
	v := m.reminder_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReminderCount returns the old "reminder_count" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldReminderCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReminderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReminderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReminderCount: %w", err)
	}
	return oldValue.ReminderCount, nil
}

// AddReminderCount adds i to the "reminder_count" field.
func (m *ProcessMutation) AddReminderCount(i int) {
	if m.addreminder_count != nil {
		*m.addreminder_count += i
	} else {
		m.addreminder_count = &i
	}
}

// AddedReminderCount returns the value that was added to the "reminder_count" field in this mutation.
func (m *ProcessMutation) AddedReminderCount() (r int, exists bool) {
	v := m.addreminder_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReminderCount resets all changes to the "reminder_count" field.
func (m *ProcessMutation) ResetReminderCount() {
	m.reminder_count = nil
	m.addreminder_count = nil
}

// SetAllowCancel sets the "allow_cancel" field.
func (m *ProcessMutation) SetAllowCancel(b bool) {
	m.allow_cancel = &b
}

// AllowCancel returns the value of the "allow_cancel" field in the mutation.
func (m *ProcessMutation) AllowCancel() (r bool, exists bool) {
	v := m.allow_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowCancel returns the old "allow_cancel" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldAllowCancel(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowCancel: %w", err)
	}
	return oldValue.AllowCancel, nil
}

// ResetAllowCancel resets all changes to the "allow_cancel" field.
func (m *ProcessMutation) ResetAllowCancel() {
	m.allow_cancel = nil
}

// SetAllowUrge sets the "allow_urge" field.
func (m *ProcessMutation) SetAllowUrge(b bool) {
	m.allow_urge = &b
}

// AllowUrge returns the value of the "allow_urge" field in the mutation.
func (m *ProcessMutation) AllowUrge() (r bool, exists bool) {
	v := m.allow_urge
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowUrge returns the old "allow_urge" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldAllowUrge(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowUrge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowUrge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowUrge: %w", err)
	}
	return oldValue.AllowUrge, nil
}

// ResetAllowUrge resets all changes to the "allow_urge" field.
func (m *ProcessMutation) ResetAllowUrge() {
	m.allow_urge = nil
}

// SetAllowDelegate sets the "allow_delegate" field.
func (m *ProcessMutation) SetAllowDelegate(b bool) {
	m.allow_delegate = &b
}

// AllowDelegate returns the value of the "allow_delegate" field in the mutation.
func (m *ProcessMutation) AllowDelegate() (r bool, exists bool) {
	v := m.allow_delegate
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowDelegate returns the old "allow_delegate" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldAllowDelegate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowDelegate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowDelegate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowDelegate: %w", err)
	}
	return oldValue.AllowDelegate, nil
}

// ResetAllowDelegate resets all changes to the "allow_delegate" field.
func (m *ProcessMutation) ResetAllowDelegate() {
	m.allow_delegate = nil
}

// SetAllowTransfer sets the "allow_transfer" field.
func (m *ProcessMutation) SetAllowTransfer(b bool) {
	m.allow_transfer = &b
}

// AllowTransfer returns the value of the "allow_transfer" field in the mutation.
func (m *ProcessMutation) AllowTransfer() (r bool, exists bool) {
	v := m.allow_transfer
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowTransfer returns the old "allow_transfer" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldAllowTransfer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowTransfer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowTransfer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowTransfer: %w", err)
	}
	return oldValue.AllowTransfer, nil
}

// ResetAllowTransfer resets all changes to the "allow_transfer" field.
func (m *ProcessMutation) ResetAllowTransfer() {
	m.allow_transfer = nil
}

// SetIsDraftEnabled sets the "is_draft_enabled" field.
func (m *ProcessMutation) SetIsDraftEnabled(b bool) {
	m.is_draft_enabled = &b
}

// IsDraftEnabled returns the value of the "is_draft_enabled" field in the mutation.
func (m *ProcessMutation) IsDraftEnabled() (r bool, exists bool) {
	v := m.is_draft_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDraftEnabled returns the old "is_draft_enabled" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldIsDraftEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDraftEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDraftEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDraftEnabled: %w", err)
	}
	return oldValue.IsDraftEnabled, nil
}

// ResetIsDraftEnabled resets all changes to the "is_draft_enabled" field.
func (m *ProcessMutation) ResetIsDraftEnabled() {
	m.is_draft_enabled = nil
}

// SetIsAutoStart sets the "is_auto_start" field.
func (m *ProcessMutation) SetIsAutoStart(b bool) {
	m.is_auto_start = &b
}

// IsAutoStart returns the value of the "is_auto_start" field in the mutation.
func (m *ProcessMutation) IsAutoStart() (r bool, exists bool) {
	v := m.is_auto_start
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutoStart returns the old "is_auto_start" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldIsAutoStart(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAutoStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAutoStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutoStart: %w", err)
	}
	return oldValue.IsAutoStart, nil
}

// ResetIsAutoStart resets all changes to the "is_auto_start" field.
func (m *ProcessMutation) ResetIsAutoStart() {
	m.is_auto_start = nil
}

// SetStrictMode sets the "strict_mode" field.
func (m *ProcessMutation) SetStrictMode(b bool) {
	m.strict_mode = &b
}

// StrictMode returns the value of the "strict_mode" field in the mutation.
func (m *ProcessMutation) StrictMode() (r bool, exists bool) {
	v := m.strict_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldStrictMode returns the old "strict_mode" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldStrictMode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrictMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrictMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrictMode: %w", err)
	}
	return oldValue.StrictMode, nil
}

// ResetStrictMode resets all changes to the "strict_mode" field.
func (m *ProcessMutation) ResetStrictMode() {
	m.strict_mode = nil
}

// SetExtras sets the "extras" field.
func (m *ProcessMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *ProcessMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *ProcessMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[process.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *ProcessMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[process.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *ProcessMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, process.FieldExtras)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ProcessMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[process.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ProcessMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[process.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, process.FieldTenantID)
}

// SetCreatedBy sets the "created_by" field.
func (m *ProcessMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProcessMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProcessMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[process.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProcessMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[process.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProcessMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, process.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProcessMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProcessMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProcessMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[process.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProcessMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[process.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProcessMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, process.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *ProcessMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ProcessMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProcessMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[process.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProcessMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[process.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, process.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *ProcessMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ProcessMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProcessMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[process.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProcessMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[process.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, process.FieldUpdatedAt)
}

// SetProcessKey sets the "process_key" field.
func (m *ProcessMutation) SetProcessKey(s string) {
	m.process_key = &s
}

// ProcessKey returns the value of the "process_key" field in the mutation.
func (m *ProcessMutation) ProcessKey() (r string, exists bool) {
	v := m.process_key
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessKey returns the old "process_key" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldProcessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessKey: %w", err)
	}
	return oldValue.ProcessKey, nil
}

// ResetProcessKey resets all changes to the "process_key" field.
func (m *ProcessMutation) ResetProcessKey() {
	m.process_key = nil
}

// SetInitiator sets the "initiator" field.
func (m *ProcessMutation) SetInitiator(s string) {
	m.initiator = &s
}

// Initiator returns the value of the "initiator" field in the mutation.
func (m *ProcessMutation) Initiator() (r string, exists bool) {
	v := m.initiator
	if v == nil {
		return
	}
	return *v, true
}

// OldInitiator returns the old "initiator" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldInitiator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitiator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitiator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitiator: %w", err)
	}
	return oldValue.Initiator, nil
}

// ResetInitiator resets all changes to the "initiator" field.
func (m *ProcessMutation) ResetInitiator() {
	m.initiator = nil
}

// SetInitiatorDept sets the "initiator_dept" field.
func (m *ProcessMutation) SetInitiatorDept(s string) {
	m.initiator_dept = &s
}

// InitiatorDept returns the value of the "initiator_dept" field in the mutation.
func (m *ProcessMutation) InitiatorDept() (r string, exists bool) {
	v := m.initiator_dept
	if v == nil {
		return
	}
	return *v, true
}

// OldInitiatorDept returns the old "initiator_dept" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldInitiatorDept(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitiatorDept is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitiatorDept requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitiatorDept: %w", err)
	}
	return oldValue.InitiatorDept, nil
}

// ClearInitiatorDept clears the value of the "initiator_dept" field.
func (m *ProcessMutation) ClearInitiatorDept() {
	m.initiator_dept = nil
	m.clearedFields[process.FieldInitiatorDept] = struct{}{}
}

// InitiatorDeptCleared returns if the "initiator_dept" field was cleared in this mutation.
func (m *ProcessMutation) InitiatorDeptCleared() bool {
	_, ok := m.clearedFields[process.FieldInitiatorDept]
	return ok
}

// ResetInitiatorDept resets all changes to the "initiator_dept" field.
func (m *ProcessMutation) ResetInitiatorDept() {
	m.initiator_dept = nil
	delete(m.clearedFields, process.FieldInitiatorDept)
}

// SetProcessCode sets the "process_code" field.
func (m *ProcessMutation) SetProcessCode(s string) {
	m.process_code = &s
}

// ProcessCode returns the value of the "process_code" field in the mutation.
func (m *ProcessMutation) ProcessCode() (r string, exists bool) {
	v := m.process_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessCode returns the old "process_code" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldProcessCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessCode: %w", err)
	}
	return oldValue.ProcessCode, nil
}

// ResetProcessCode resets all changes to the "process_code" field.
func (m *ProcessMutation) ResetProcessCode() {
	m.process_code = nil
}

// SetVariables sets the "variables" field.
func (m *ProcessMutation) SetVariables(value map[string]interface{}) {
	m.variables = &value
}

// Variables returns the value of the "variables" field in the mutation.
func (m *ProcessMutation) Variables() (r map[string]interface{}, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ResetVariables resets all changes to the "variables" field.
func (m *ProcessMutation) ResetVariables() {
	m.variables = nil
}

// SetCurrentNode sets the "current_node" field.
func (m *ProcessMutation) SetCurrentNode(s string) {
	m.current_node = &s
}

// CurrentNode returns the value of the "current_node" field in the mutation.
func (m *ProcessMutation) CurrentNode() (r string, exists bool) {
	v := m.current_node
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentNode returns the old "current_node" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldCurrentNode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentNode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentNode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentNode: %w", err)
	}
	return oldValue.CurrentNode, nil
}

// ClearCurrentNode clears the value of the "current_node" field.
func (m *ProcessMutation) ClearCurrentNode() {
	m.current_node = nil
	m.clearedFields[process.FieldCurrentNode] = struct{}{}
}

// CurrentNodeCleared returns if the "current_node" field was cleared in this mutation.
func (m *ProcessMutation) CurrentNodeCleared() bool {
	_, ok := m.clearedFields[process.FieldCurrentNode]
	return ok
}

// ResetCurrentNode resets all changes to the "current_node" field.
func (m *ProcessMutation) ResetCurrentNode() {
	m.current_node = nil
	delete(m.clearedFields, process.FieldCurrentNode)
}

// SetActiveNodes sets the "active_nodes" field.
func (m *ProcessMutation) SetActiveNodes(s []string) {
	m.active_nodes = &s
	m.appendactive_nodes = nil
}

// ActiveNodes returns the value of the "active_nodes" field in the mutation.
func (m *ProcessMutation) ActiveNodes() (r []string, exists bool) {
	v := m.active_nodes
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveNodes returns the old "active_nodes" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldActiveNodes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveNodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveNodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveNodes: %w", err)
	}
	return oldValue.ActiveNodes, nil
}

// AppendActiveNodes adds s to the "active_nodes" field.
func (m *ProcessMutation) AppendActiveNodes(s []string) {
	m.appendactive_nodes = append(m.appendactive_nodes, s...)
}

// AppendedActiveNodes returns the list of values that were appended to the "active_nodes" field in this mutation.
func (m *ProcessMutation) AppendedActiveNodes() ([]string, bool) {
	if len(m.appendactive_nodes) == 0 {
		return nil, false
	}
	return m.appendactive_nodes, true
}

// ClearActiveNodes clears the value of the "active_nodes" field.
func (m *ProcessMutation) ClearActiveNodes() {
	m.active_nodes = nil
	m.appendactive_nodes = nil
	m.clearedFields[process.FieldActiveNodes] = struct{}{}
}

// ActiveNodesCleared returns if the "active_nodes" field was cleared in this mutation.
func (m *ProcessMutation) ActiveNodesCleared() bool {
	_, ok := m.clearedFields[process.FieldActiveNodes]
	return ok
}

// ResetActiveNodes resets all changes to the "active_nodes" field.
func (m *ProcessMutation) ResetActiveNodes() {
	m.active_nodes = nil
	m.appendactive_nodes = nil
	delete(m.clearedFields, process.FieldActiveNodes)
}

// SetProcessSnapshot sets the "process_snapshot" field.
func (m *ProcessMutation) SetProcessSnapshot(value map[string]interface{}) {
	m.process_snapshot = &value
}

// ProcessSnapshot returns the value of the "process_snapshot" field in the mutation.
func (m *ProcessMutation) ProcessSnapshot() (r map[string]interface{}, exists bool) {
	v := m.process_snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessSnapshot returns the old "process_snapshot" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldProcessSnapshot(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessSnapshot: %w", err)
	}
	return oldValue.ProcessSnapshot, nil
}

// ClearProcessSnapshot clears the value of the "process_snapshot" field.
func (m *ProcessMutation) ClearProcessSnapshot() {
	m.process_snapshot = nil
	m.clearedFields[process.FieldProcessSnapshot] = struct{}{}
}

// ProcessSnapshotCleared returns if the "process_snapshot" field was cleared in this mutation.
func (m *ProcessMutation) ProcessSnapshotCleared() bool {
	_, ok := m.clearedFields[process.FieldProcessSnapshot]
	return ok
}

// ResetProcessSnapshot resets all changes to the "process_snapshot" field.
func (m *ProcessMutation) ResetProcessSnapshot() {
	m.process_snapshot = nil
	delete(m.clearedFields, process.FieldProcessSnapshot)
}

// SetFormSnapshot sets the "form_snapshot" field.
func (m *ProcessMutation) SetFormSnapshot(value map[string]interface{}) {
	m.form_snapshot = &value
}

// FormSnapshot returns the value of the "form_snapshot" field in the mutation.
func (m *ProcessMutation) FormSnapshot() (r map[string]interface{}, exists bool) {
	v := m.form_snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldFormSnapshot returns the old "form_snapshot" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldFormSnapshot(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormSnapshot: %w", err)
	}
	return oldValue.FormSnapshot, nil
}

// ClearFormSnapshot clears the value of the "form_snapshot" field.
func (m *ProcessMutation) ClearFormSnapshot() {
	m.form_snapshot = nil
	m.clearedFields[process.FieldFormSnapshot] = struct{}{}
}

// FormSnapshotCleared returns if the "form_snapshot" field was cleared in this mutation.
func (m *ProcessMutation) FormSnapshotCleared() bool {
	_, ok := m.clearedFields[process.FieldFormSnapshot]
	return ok
}

// ResetFormSnapshot resets all changes to the "form_snapshot" field.
func (m *ProcessMutation) ResetFormSnapshot() {
	m.form_snapshot = nil
	delete(m.clearedFields, process.FieldFormSnapshot)
}

// SetUrgeCount sets the "urge_count" field.
func (m *ProcessMutation) SetUrgeCount(i int) {
	m.urge_count = &i
	m.addurge_count = nil
}

// UrgeCount returns the value of the "urge_count" field in the mutation.
func (m *ProcessMutation) UrgeCount() (r int, exists bool) {
	v := m.urge_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUrgeCount returns the old "urge_count" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldUrgeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUrgeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUrgeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrgeCount: %w", err)
	}
	return oldValue.UrgeCount, nil
}

// AddUrgeCount adds i to the "urge_count" field.
func (m *ProcessMutation) AddUrgeCount(i int) {
	if m.addurge_count != nil {
		*m.addurge_count += i
	} else {
		m.addurge_count = &i
	}
}

// AddedUrgeCount returns the value that was added to the "urge_count" field in this mutation.
func (m *ProcessMutation) AddedUrgeCount() (r int, exists bool) {
	v := m.addurge_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUrgeCount resets all changes to the "urge_count" field.
func (m *ProcessMutation) ResetUrgeCount() {
	m.urge_count = nil
	m.addurge_count = nil
}

// Where appends a list predicates to the ProcessMutation builder.
func (m *ProcessMutation) Where(ps ...predicate.Process) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Process, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Process).
func (m *ProcessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessMutation) Fields() []string {
	fields := make([]string, 0, 48)
	if m.status != nil {
		fields = append(fields, process.FieldStatus)
	}
	if m.process_id != nil {
		fields = append(fields, process.FieldProcessID)
	}
	if m.template_id != nil {
		fields = append(fields, process.FieldTemplateID)
	}
	if m.business_key != nil {
		fields = append(fields, process.FieldBusinessKey)
	}
	if m.form_code != nil {
		fields = append(fields, process.FieldFormCode)
	}
	if m.form_version != nil {
		fields = append(fields, process.FieldFormVersion)
	}
	if m.form_config != nil {
		fields = append(fields, process.FieldFormConfig)
	}
	if m.form_permissions != nil {
		fields = append(fields, process.FieldFormPermissions)
	}
	if m.field_permissions != nil {
		fields = append(fields, process.FieldFieldPermissions)
	}
	if m.business_tags != nil {
		fields = append(fields, process.FieldBusinessTags)
	}
	if m.module_code != nil {
		fields = append(fields, process.FieldModuleCode)
	}
	if m.category != nil {
		fields = append(fields, process.FieldCategory)
	}
	if m.flow_status != nil {
		fields = append(fields, process.FieldFlowStatus)
	}
	if m.flow_variables != nil {
		fields = append(fields, process.FieldFlowVariables)
	}
	if m.is_draft != nil {
		fields = append(fields, process.FieldIsDraft)
	}
	if m.is_terminated != nil {
		fields = append(fields, process.FieldIsTerminated)
	}
	if m.is_suspended != nil {
		fields = append(fields, process.FieldIsSuspended)
	}
	if m.suspend_reason != nil {
		fields = append(fields, process.FieldSuspendReason)
	}
	if m.start_time != nil {
		fields = append(fields, process.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, process.FieldEndTime)
	}
	if m.due_time != nil {
		fields = append(fields, process.FieldDueTime)
	}
	if m.duration != nil {
		fields = append(fields, process.FieldDuration)
	}
	if m.priority != nil {
		fields = append(fields, process.FieldPriority)
	}
	if m.is_timeout != nil {
		fields = append(fields, process.FieldIsTimeout)
	}
	if m.reminder_count != nil {
		fields = append(fields, process.FieldReminderCount)
	}
	if m.allow_cancel != nil {
		fields = append(fields, process.FieldAllowCancel)
	}
	if m.allow_urge != nil {
		fields = append(fields, process.FieldAllowUrge)
	}
	if m.allow_delegate != nil {
		fields = append(fields, process.FieldAllowDelegate)
	}
	if m.allow_transfer != nil {
		fields = append(fields, process.FieldAllowTransfer)
	}
	if m.is_draft_enabled != nil {
		fields = append(fields, process.FieldIsDraftEnabled)
	}
	if m.is_auto_start != nil {
		fields = append(fields, process.FieldIsAutoStart)
	}
	if m.strict_mode != nil {
		fields = append(fields, process.FieldStrictMode)
	}
	if m.extras != nil {
		fields = append(fields, process.FieldExtras)
	}
	if m.tenant_id != nil {
		fields = append(fields, process.FieldTenantID)
	}
	if m.created_by != nil {
		fields = append(fields, process.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, process.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, process.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, process.FieldUpdatedAt)
	}
	if m.process_key != nil {
		fields = append(fields, process.FieldProcessKey)
	}
	if m.initiator != nil {
		fields = append(fields, process.FieldInitiator)
	}
	if m.initiator_dept != nil {
		fields = append(fields, process.FieldInitiatorDept)
	}
	if m.process_code != nil {
		fields = append(fields, process.FieldProcessCode)
	}
	if m.variables != nil {
		fields = append(fields, process.FieldVariables)
	}
	if m.current_node != nil {
		fields = append(fields, process.FieldCurrentNode)
	}
	if m.active_nodes != nil {
		fields = append(fields, process.FieldActiveNodes)
	}
	if m.process_snapshot != nil {
		fields = append(fields, process.FieldProcessSnapshot)
	}
	if m.form_snapshot != nil {
		fields = append(fields, process.FieldFormSnapshot)
	}
	if m.urge_count != nil {
		fields = append(fields, process.FieldUrgeCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case process.FieldStatus:
		return m.Status()
	case process.FieldProcessID:
		return m.ProcessID()
	case process.FieldTemplateID:
		return m.TemplateID()
	case process.FieldBusinessKey:
		return m.BusinessKey()
	case process.FieldFormCode:
		return m.FormCode()
	case process.FieldFormVersion:
		return m.FormVersion()
	case process.FieldFormConfig:
		return m.FormConfig()
	case process.FieldFormPermissions:
		return m.FormPermissions()
	case process.FieldFieldPermissions:
		return m.FieldPermissions()
	case process.FieldBusinessTags:
		return m.BusinessTags()
	case process.FieldModuleCode:
		return m.ModuleCode()
	case process.FieldCategory:
		return m.Category()
	case process.FieldFlowStatus:
		return m.FlowStatus()
	case process.FieldFlowVariables:
		return m.FlowVariables()
	case process.FieldIsDraft:
		return m.IsDraft()
	case process.FieldIsTerminated:
		return m.IsTerminated()
	case process.FieldIsSuspended:
		return m.IsSuspended()
	case process.FieldSuspendReason:
		return m.SuspendReason()
	case process.FieldStartTime:
		return m.StartTime()
	case process.FieldEndTime:
		return m.EndTime()
	case process.FieldDueTime:
		return m.DueTime()
	case process.FieldDuration:
		return m.Duration()
	case process.FieldPriority:
		return m.Priority()
	case process.FieldIsTimeout:
		return m.IsTimeout()
	case process.FieldReminderCount:
		return m.ReminderCount()
	case process.FieldAllowCancel:
		return m.AllowCancel()
	case process.FieldAllowUrge:
		return m.AllowUrge()
	case process.FieldAllowDelegate:
		return m.AllowDelegate()
	case process.FieldAllowTransfer:
		return m.AllowTransfer()
	case process.FieldIsDraftEnabled:
		return m.IsDraftEnabled()
	case process.FieldIsAutoStart:
		return m.IsAutoStart()
	case process.FieldStrictMode:
		return m.StrictMode()
	case process.FieldExtras:
		return m.Extras()
	case process.FieldTenantID:
		return m.TenantID()
	case process.FieldCreatedBy:
		return m.CreatedBy()
	case process.FieldUpdatedBy:
		return m.UpdatedBy()
	case process.FieldCreatedAt:
		return m.CreatedAt()
	case process.FieldUpdatedAt:
		return m.UpdatedAt()
	case process.FieldProcessKey:
		return m.ProcessKey()
	case process.FieldInitiator:
		return m.Initiator()
	case process.FieldInitiatorDept:
		return m.InitiatorDept()
	case process.FieldProcessCode:
		return m.ProcessCode()
	case process.FieldVariables:
		return m.Variables()
	case process.FieldCurrentNode:
		return m.CurrentNode()
	case process.FieldActiveNodes:
		return m.ActiveNodes()
	case process.FieldProcessSnapshot:
		return m.ProcessSnapshot()
	case process.FieldFormSnapshot:
		return m.FormSnapshot()
	case process.FieldUrgeCount:
		return m.UrgeCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case process.FieldStatus:
		return m.OldStatus(ctx)
	case process.FieldProcessID:
		return m.OldProcessID(ctx)
	case process.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case process.FieldBusinessKey:
		return m.OldBusinessKey(ctx)
	case process.FieldFormCode:
		return m.OldFormCode(ctx)
	case process.FieldFormVersion:
		return m.OldFormVersion(ctx)
	case process.FieldFormConfig:
		return m.OldFormConfig(ctx)
	case process.FieldFormPermissions:
		return m.OldFormPermissions(ctx)
	case process.FieldFieldPermissions:
		return m.OldFieldPermissions(ctx)
	case process.FieldBusinessTags:
		return m.OldBusinessTags(ctx)
	case process.FieldModuleCode:
		return m.OldModuleCode(ctx)
	case process.FieldCategory:
		return m.OldCategory(ctx)
	case process.FieldFlowStatus:
		return m.OldFlowStatus(ctx)
	case process.FieldFlowVariables:
		return m.OldFlowVariables(ctx)
	case process.FieldIsDraft:
		return m.OldIsDraft(ctx)
	case process.FieldIsTerminated:
		return m.OldIsTerminated(ctx)
	case process.FieldIsSuspended:
		return m.OldIsSuspended(ctx)
	case process.FieldSuspendReason:
		return m.OldSuspendReason(ctx)
	case process.FieldStartTime:
		return m.OldStartTime(ctx)
	case process.FieldEndTime:
		return m.OldEndTime(ctx)
	case process.FieldDueTime:
		return m.OldDueTime(ctx)
	case process.FieldDuration:
		return m.OldDuration(ctx)
	case process.FieldPriority:
		return m.OldPriority(ctx)
	case process.FieldIsTimeout:
		return m.OldIsTimeout(ctx)
	case process.FieldReminderCount:
		return m.OldReminderCount(ctx)
	case process.FieldAllowCancel:
		return m.OldAllowCancel(ctx)
	case process.FieldAllowUrge:
		return m.OldAllowUrge(ctx)
	case process.FieldAllowDelegate:
		return m.OldAllowDelegate(ctx)
	case process.FieldAllowTransfer:
		return m.OldAllowTransfer(ctx)
	case process.FieldIsDraftEnabled:
		return m.OldIsDraftEnabled(ctx)
	case process.FieldIsAutoStart:
		return m.OldIsAutoStart(ctx)
	case process.FieldStrictMode:
		return m.OldStrictMode(ctx)
	case process.FieldExtras:
		return m.OldExtras(ctx)
	case process.FieldTenantID:
		return m.OldTenantID(ctx)
	case process.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case process.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case process.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case process.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case process.FieldProcessKey:
		return m.OldProcessKey(ctx)
	case process.FieldInitiator:
		return m.OldInitiator(ctx)
	case process.FieldInitiatorDept:
		return m.OldInitiatorDept(ctx)
	case process.FieldProcessCode:
		return m.OldProcessCode(ctx)
	case process.FieldVariables:
		return m.OldVariables(ctx)
	case process.FieldCurrentNode:
		return m.OldCurrentNode(ctx)
	case process.FieldActiveNodes:
		return m.OldActiveNodes(ctx)
	case process.FieldProcessSnapshot:
		return m.OldProcessSnapshot(ctx)
	case process.FieldFormSnapshot:
		return m.OldFormSnapshot(ctx)
	case process.FieldUrgeCount:
		return m.OldUrgeCount(ctx)
	}
	return nil, fmt.Errorf("unknown Process field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case process.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case process.FieldProcessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessID(v)
		return nil
	case process.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case process.FieldBusinessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessKey(v)
		return nil
	case process.FieldFormCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormCode(v)
		return nil
	case process.FieldFormVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormVersion(v)
		return nil
	case process.FieldFormConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormConfig(v)
		return nil
	case process.FieldFormPermissions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormPermissions(v)
		return nil
	case process.FieldFieldPermissions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldPermissions(v)
		return nil
	case process.FieldBusinessTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessTags(v)
		return nil
	case process.FieldModuleCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleCode(v)
		return nil
	case process.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case process.FieldFlowStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowStatus(v)
		return nil
	case process.FieldFlowVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowVariables(v)
		return nil
	case process.FieldIsDraft:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDraft(v)
		return nil
	case process.FieldIsTerminated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTerminated(v)
		return nil
	case process.FieldIsSuspended:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuspended(v)
		return nil
	case process.FieldSuspendReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendReason(v)
		return nil
	case process.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case process.FieldEndTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case process.FieldDueTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueTime(v)
		return nil
	case process.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case process.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case process.FieldIsTimeout:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTimeout(v)
		return nil
	case process.FieldReminderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReminderCount(v)
		return nil
	case process.FieldAllowCancel:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowCancel(v)
		return nil
	case process.FieldAllowUrge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowUrge(v)
		return nil
	case process.FieldAllowDelegate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowDelegate(v)
		return nil
	case process.FieldAllowTransfer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowTransfer(v)
		return nil
	case process.FieldIsDraftEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDraftEnabled(v)
		return nil
	case process.FieldIsAutoStart:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutoStart(v)
		return nil
	case process.FieldStrictMode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrictMode(v)
		return nil
	case process.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case process.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case process.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case process.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case process.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case process.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case process.FieldProcessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessKey(v)
		return nil
	case process.FieldInitiator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitiator(v)
		return nil
	case process.FieldInitiatorDept:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitiatorDept(v)
		return nil
	case process.FieldProcessCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessCode(v)
		return nil
	case process.FieldVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case process.FieldCurrentNode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentNode(v)
		return nil
	case process.FieldActiveNodes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveNodes(v)
		return nil
	case process.FieldProcessSnapshot:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessSnapshot(v)
		return nil
	case process.FieldFormSnapshot:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormSnapshot(v)
		return nil
	case process.FieldUrgeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrgeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Process field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessMutation) AddedFields() []string {
	var fields []string
	if m.addstart_time != nil {
		fields = append(fields, process.FieldStartTime)
	}
	if m.addend_time != nil {
		fields = append(fields, process.FieldEndTime)
	}
	if m.adddue_time != nil {
		fields = append(fields, process.FieldDueTime)
	}
	if m.addduration != nil {
		fields = append(fields, process.FieldDuration)
	}
	if m.addpriority != nil {
		fields = append(fields, process.FieldPriority)
	}
	if m.addreminder_count != nil {
		fields = append(fields, process.FieldReminderCount)
	}
	if m.addcreated_at != nil {
		fields = append(fields, process.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, process.FieldUpdatedAt)
	}
	if m.addurge_count != nil {
		fields = append(fields, process.FieldUrgeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case process.FieldStartTime:
		return m.AddedStartTime()
	case process.FieldEndTime:
		return m.AddedEndTime()
	case process.FieldDueTime:
		return m.AddedDueTime()
	case process.FieldDuration:
		return m.AddedDuration()
	case process.FieldPriority:
		return m.AddedPriority()
	case process.FieldReminderCount:
		return m.AddedReminderCount()
	case process.FieldCreatedAt:
		return m.AddedCreatedAt()
	case process.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case process.FieldUrgeCount:
		return m.AddedUrgeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessMutation) AddField(name string, value ent.Value) error {
	switch name {
	case process.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTime(v)
		return nil
	case process.FieldEndTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndTime(v)
		return nil
	case process.FieldDueTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDueTime(v)
		return nil
	case process.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case process.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case process.FieldReminderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReminderCount(v)
		return nil
	case process.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case process.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case process.FieldUrgeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUrgeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Process numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(process.FieldStatus) {
		fields = append(fields, process.FieldStatus)
	}
	if m.FieldCleared(process.FieldFormVersion) {
		fields = append(fields, process.FieldFormVersion)
	}
	if m.FieldCleared(process.FieldFormConfig) {
		fields = append(fields, process.FieldFormConfig)
	}
	if m.FieldCleared(process.FieldFormPermissions) {
		fields = append(fields, process.FieldFormPermissions)
	}
	if m.FieldCleared(process.FieldFieldPermissions) {
		fields = append(fields, process.FieldFieldPermissions)
	}
	if m.FieldCleared(process.FieldBusinessTags) {
		fields = append(fields, process.FieldBusinessTags)
	}
	if m.FieldCleared(process.FieldCategory) {
		fields = append(fields, process.FieldCategory)
	}
	if m.FieldCleared(process.FieldFlowStatus) {
		fields = append(fields, process.FieldFlowStatus)
	}
	if m.FieldCleared(process.FieldFlowVariables) {
		fields = append(fields, process.FieldFlowVariables)
	}
	if m.FieldCleared(process.FieldSuspendReason) {
		fields = append(fields, process.FieldSuspendReason)
	}
	if m.FieldCleared(process.FieldEndTime) {
		fields = append(fields, process.FieldEndTime)
	}
	if m.FieldCleared(process.FieldDueTime) {
		fields = append(fields, process.FieldDueTime)
	}
	if m.FieldCleared(process.FieldDuration) {
		fields = append(fields, process.FieldDuration)
	}
	if m.FieldCleared(process.FieldExtras) {
		fields = append(fields, process.FieldExtras)
	}
	if m.FieldCleared(process.FieldTenantID) {
		fields = append(fields, process.FieldTenantID)
	}
	if m.FieldCleared(process.FieldCreatedBy) {
		fields = append(fields, process.FieldCreatedBy)
	}
	if m.FieldCleared(process.FieldUpdatedBy) {
		fields = append(fields, process.FieldUpdatedBy)
	}
	if m.FieldCleared(process.FieldCreatedAt) {
		fields = append(fields, process.FieldCreatedAt)
	}
	if m.FieldCleared(process.FieldUpdatedAt) {
		fields = append(fields, process.FieldUpdatedAt)
	}
	if m.FieldCleared(process.FieldInitiatorDept) {
		fields = append(fields, process.FieldInitiatorDept)
	}
	if m.FieldCleared(process.FieldCurrentNode) {
		fields = append(fields, process.FieldCurrentNode)
	}
	if m.FieldCleared(process.FieldActiveNodes) {
		fields = append(fields, process.FieldActiveNodes)
	}
	if m.FieldCleared(process.FieldProcessSnapshot) {
		fields = append(fields, process.FieldProcessSnapshot)
	}
	if m.FieldCleared(process.FieldFormSnapshot) {
		fields = append(fields, process.FieldFormSnapshot)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessMutation) ClearField(name string) error {
	switch name {
	case process.FieldStatus:
		m.ClearStatus()
		return nil
	case process.FieldFormVersion:
		m.ClearFormVersion()
		return nil
	case process.FieldFormConfig:
		m.ClearFormConfig()
		return nil
	case process.FieldFormPermissions:
		m.ClearFormPermissions()
		return nil
	case process.FieldFieldPermissions:
		m.ClearFieldPermissions()
		return nil
	case process.FieldBusinessTags:
		m.ClearBusinessTags()
		return nil
	case process.FieldCategory:
		m.ClearCategory()
		return nil
	case process.FieldFlowStatus:
		m.ClearFlowStatus()
		return nil
	case process.FieldFlowVariables:
		m.ClearFlowVariables()
		return nil
	case process.FieldSuspendReason:
		m.ClearSuspendReason()
		return nil
	case process.FieldEndTime:
		m.ClearEndTime()
		return nil
	case process.FieldDueTime:
		m.ClearDueTime()
		return nil
	case process.FieldDuration:
		m.ClearDuration()
		return nil
	case process.FieldExtras:
		m.ClearExtras()
		return nil
	case process.FieldTenantID:
		m.ClearTenantID()
		return nil
	case process.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case process.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case process.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case process.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case process.FieldInitiatorDept:
		m.ClearInitiatorDept()
		return nil
	case process.FieldCurrentNode:
		m.ClearCurrentNode()
		return nil
	case process.FieldActiveNodes:
		m.ClearActiveNodes()
		return nil
	case process.FieldProcessSnapshot:
		m.ClearProcessSnapshot()
		return nil
	case process.FieldFormSnapshot:
		m.ClearFormSnapshot()
		return nil
	}
	return fmt.Errorf("unknown Process nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessMutation) ResetField(name string) error {
	switch name {
	case process.FieldStatus:
		m.ResetStatus()
		return nil
	case process.FieldProcessID:
		m.ResetProcessID()
		return nil
	case process.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case process.FieldBusinessKey:
		m.ResetBusinessKey()
		return nil
	case process.FieldFormCode:
		m.ResetFormCode()
		return nil
	case process.FieldFormVersion:
		m.ResetFormVersion()
		return nil
	case process.FieldFormConfig:
		m.ResetFormConfig()
		return nil
	case process.FieldFormPermissions:
		m.ResetFormPermissions()
		return nil
	case process.FieldFieldPermissions:
		m.ResetFieldPermissions()
		return nil
	case process.FieldBusinessTags:
		m.ResetBusinessTags()
		return nil
	case process.FieldModuleCode:
		m.ResetModuleCode()
		return nil
	case process.FieldCategory:
		m.ResetCategory()
		return nil
	case process.FieldFlowStatus:
		m.ResetFlowStatus()
		return nil
	case process.FieldFlowVariables:
		m.ResetFlowVariables()
		return nil
	case process.FieldIsDraft:
		m.ResetIsDraft()
		return nil
	case process.FieldIsTerminated:
		m.ResetIsTerminated()
		return nil
	case process.FieldIsSuspended:
		m.ResetIsSuspended()
		return nil
	case process.FieldSuspendReason:
		m.ResetSuspendReason()
		return nil
	case process.FieldStartTime:
		m.ResetStartTime()
		return nil
	case process.FieldEndTime:
		m.ResetEndTime()
		return nil
	case process.FieldDueTime:
		m.ResetDueTime()
		return nil
	case process.FieldDuration:
		m.ResetDuration()
		return nil
	case process.FieldPriority:
		m.ResetPriority()
		return nil
	case process.FieldIsTimeout:
		m.ResetIsTimeout()
		return nil
	case process.FieldReminderCount:
		m.ResetReminderCount()
		return nil
	case process.FieldAllowCancel:
		m.ResetAllowCancel()
		return nil
	case process.FieldAllowUrge:
		m.ResetAllowUrge()
		return nil
	case process.FieldAllowDelegate:
		m.ResetAllowDelegate()
		return nil
	case process.FieldAllowTransfer:
		m.ResetAllowTransfer()
		return nil
	case process.FieldIsDraftEnabled:
		m.ResetIsDraftEnabled()
		return nil
	case process.FieldIsAutoStart:
		m.ResetIsAutoStart()
		return nil
	case process.FieldStrictMode:
		m.ResetStrictMode()
		return nil
	case process.FieldExtras:
		m.ResetExtras()
		return nil
	case process.FieldTenantID:
		m.ResetTenantID()
		return nil
	case process.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case process.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case process.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case process.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case process.FieldProcessKey:
		m.ResetProcessKey()
		return nil
	case process.FieldInitiator:
		m.ResetInitiator()
		return nil
	case process.FieldInitiatorDept:
		m.ResetInitiatorDept()
		return nil
	case process.FieldProcessCode:
		m.ResetProcessCode()
		return nil
	case process.FieldVariables:
		m.ResetVariables()
		return nil
	case process.FieldCurrentNode:
		m.ResetCurrentNode()
		return nil
	case process.FieldActiveNodes:
		m.ResetActiveNodes()
		return nil
	case process.FieldProcessSnapshot:
		m.ResetProcessSnapshot()
		return nil
	case process.FieldFormSnapshot:
		m.ResetFormSnapshot()
		return nil
	case process.FieldUrgeCount:
		m.ResetUrgeCount()
		return nil
	}
	return fmt.Errorf("unknown Process field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Process unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Process edge %s", name)
}

// ProcessDesignMutation represents an operation that mutates the ProcessDesign nodes in the graph.
type ProcessDesignMutation struct {
	config
	op               Op
	typ              string
	id               *string
	version          *string
	disabled         *bool
	extras           *map[string]interface{}
	tenant_id        *string
	created_by       *string
	updated_by       *string
	created_at       *int64
	addcreated_at    *int64
	updated_at       *int64
	addupdated_at    *int64
	template_id      *string
	graph_data       *map[string]interface{}
	node_layouts     *map[string]interface{}
	properties       *map[string]interface{}
	validation_rules *map[string]interface{}
	is_draft         *bool
	source_version   *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ProcessDesign, error)
	predicates       []predicate.ProcessDesign
}

var _ ent.Mutation = (*ProcessDesignMutation)(nil)

// processdesignOption allows management of the mutation configuration using functional options.
type processdesignOption func(*ProcessDesignMutation)

// newProcessDesignMutation creates new mutation for the ProcessDesign entity.
func newProcessDesignMutation(c config, op Op, opts ...processdesignOption) *ProcessDesignMutation {
	m := &ProcessDesignMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessDesign,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessDesignID sets the ID field of the mutation.
func withProcessDesignID(id string) processdesignOption {
	return func(m *ProcessDesignMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessDesign
		)
		m.oldValue = func(ctx context.Context) (*ProcessDesign, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessDesign.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessDesign sets the old ProcessDesign of the mutation.
func withProcessDesign(node *ProcessDesign) processdesignOption {
	return func(m *ProcessDesignMutation) {
		m.oldValue = func(context.Context) (*ProcessDesign, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessDesignMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessDesignMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProcessDesign entities.
func (m *ProcessDesignMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessDesignMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessDesignMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessDesign.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *ProcessDesignMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ProcessDesignMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ProcessDesignMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[processdesign.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ProcessDesignMutation) VersionCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ProcessDesignMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, processdesign.FieldVersion)
}

// SetDisabled sets the "disabled" field.
func (m *ProcessDesignMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *ProcessDesignMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *ProcessDesignMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[processdesign.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *ProcessDesignMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *ProcessDesignMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, processdesign.FieldDisabled)
}

// SetExtras sets the "extras" field.
func (m *ProcessDesignMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *ProcessDesignMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *ProcessDesignMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[processdesign.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *ProcessDesignMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *ProcessDesignMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, processdesign.FieldExtras)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessDesignMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessDesignMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ProcessDesignMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[processdesign.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ProcessDesignMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessDesignMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, processdesign.FieldTenantID)
}

// SetCreatedBy sets the "created_by" field.
func (m *ProcessDesignMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProcessDesignMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProcessDesignMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[processdesign.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProcessDesignMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProcessDesignMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, processdesign.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProcessDesignMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProcessDesignMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProcessDesignMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[processdesign.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProcessDesignMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProcessDesignMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, processdesign.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessDesignMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessDesignMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *ProcessDesignMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ProcessDesignMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProcessDesignMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[processdesign.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProcessDesignMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessDesignMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, processdesign.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessDesignMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessDesignMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *ProcessDesignMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ProcessDesignMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProcessDesignMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[processdesign.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProcessDesignMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessDesignMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, processdesign.FieldUpdatedAt)
}

// SetTemplateID sets the "template_id" field.
func (m *ProcessDesignMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *ProcessDesignMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *ProcessDesignMutation) ResetTemplateID() {
	m.template_id = nil
}

// SetGraphData sets the "graph_data" field.
func (m *ProcessDesignMutation) SetGraphData(value map[string]interface{}) {
	m.graph_data = &value
}

// GraphData returns the value of the "graph_data" field in the mutation.
func (m *ProcessDesignMutation) GraphData() (r map[string]interface{}, exists bool) {
	v := m.graph_data
	if v == nil {
		return
	}
	return *v, true
}

// OldGraphData returns the old "graph_data" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldGraphData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGraphData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGraphData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGraphData: %w", err)
	}
	return oldValue.GraphData, nil
}

// ClearGraphData clears the value of the "graph_data" field.
func (m *ProcessDesignMutation) ClearGraphData() {
	m.graph_data = nil
	m.clearedFields[processdesign.FieldGraphData] = struct{}{}
}

// GraphDataCleared returns if the "graph_data" field was cleared in this mutation.
func (m *ProcessDesignMutation) GraphDataCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldGraphData]
	return ok
}

// ResetGraphData resets all changes to the "graph_data" field.
func (m *ProcessDesignMutation) ResetGraphData() {
	m.graph_data = nil
	delete(m.clearedFields, processdesign.FieldGraphData)
}

// SetNodeLayouts sets the "node_layouts" field.
func (m *ProcessDesignMutation) SetNodeLayouts(value map[string]interface{}) {
	m.node_layouts = &value
}

// NodeLayouts returns the value of the "node_layouts" field in the mutation.
func (m *ProcessDesignMutation) NodeLayouts() (r map[string]interface{}, exists bool) {
	v := m.node_layouts
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeLayouts returns the old "node_layouts" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldNodeLayouts(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeLayouts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeLayouts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeLayouts: %w", err)
	}
	return oldValue.NodeLayouts, nil
}

// ClearNodeLayouts clears the value of the "node_layouts" field.
func (m *ProcessDesignMutation) ClearNodeLayouts() {
	m.node_layouts = nil
	m.clearedFields[processdesign.FieldNodeLayouts] = struct{}{}
}

// NodeLayoutsCleared returns if the "node_layouts" field was cleared in this mutation.
func (m *ProcessDesignMutation) NodeLayoutsCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldNodeLayouts]
	return ok
}

// ResetNodeLayouts resets all changes to the "node_layouts" field.
func (m *ProcessDesignMutation) ResetNodeLayouts() {
	m.node_layouts = nil
	delete(m.clearedFields, processdesign.FieldNodeLayouts)
}

// SetProperties sets the "properties" field.
func (m *ProcessDesignMutation) SetProperties(value map[string]interface{}) {
	m.properties = &value
}

// Properties returns the value of the "properties" field in the mutation.
func (m *ProcessDesignMutation) Properties() (r map[string]interface{}, exists bool) {
	v := m.properties
	if v == nil {
		return
	}
	return *v, true
}

// OldProperties returns the old "properties" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldProperties(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProperties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProperties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProperties: %w", err)
	}
	return oldValue.Properties, nil
}

// ClearProperties clears the value of the "properties" field.
func (m *ProcessDesignMutation) ClearProperties() {
	m.properties = nil
	m.clearedFields[processdesign.FieldProperties] = struct{}{}
}

// PropertiesCleared returns if the "properties" field was cleared in this mutation.
func (m *ProcessDesignMutation) PropertiesCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldProperties]
	return ok
}

// ResetProperties resets all changes to the "properties" field.
func (m *ProcessDesignMutation) ResetProperties() {
	m.properties = nil
	delete(m.clearedFields, processdesign.FieldProperties)
}

// SetValidationRules sets the "validation_rules" field.
func (m *ProcessDesignMutation) SetValidationRules(value map[string]interface{}) {
	m.validation_rules = &value
}

// ValidationRules returns the value of the "validation_rules" field in the mutation.
func (m *ProcessDesignMutation) ValidationRules() (r map[string]interface{}, exists bool) {
	v := m.validation_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationRules returns the old "validation_rules" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldValidationRules(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationRules: %w", err)
	}
	return oldValue.ValidationRules, nil
}

// ClearValidationRules clears the value of the "validation_rules" field.
func (m *ProcessDesignMutation) ClearValidationRules() {
	m.validation_rules = nil
	m.clearedFields[processdesign.FieldValidationRules] = struct{}{}
}

// ValidationRulesCleared returns if the "validation_rules" field was cleared in this mutation.
func (m *ProcessDesignMutation) ValidationRulesCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldValidationRules]
	return ok
}

// ResetValidationRules resets all changes to the "validation_rules" field.
func (m *ProcessDesignMutation) ResetValidationRules() {
	m.validation_rules = nil
	delete(m.clearedFields, processdesign.FieldValidationRules)
}

// SetIsDraft sets the "is_draft" field.
func (m *ProcessDesignMutation) SetIsDraft(b bool) {
	m.is_draft = &b
}

// IsDraft returns the value of the "is_draft" field in the mutation.
func (m *ProcessDesignMutation) IsDraft() (r bool, exists bool) {
	v := m.is_draft
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDraft returns the old "is_draft" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldIsDraft(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDraft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDraft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDraft: %w", err)
	}
	return oldValue.IsDraft, nil
}

// ResetIsDraft resets all changes to the "is_draft" field.
func (m *ProcessDesignMutation) ResetIsDraft() {
	m.is_draft = nil
}

// SetSourceVersion sets the "source_version" field.
func (m *ProcessDesignMutation) SetSourceVersion(s string) {
	m.source_version = &s
}

// SourceVersion returns the value of the "source_version" field in the mutation.
func (m *ProcessDesignMutation) SourceVersion() (r string, exists bool) {
	v := m.source_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceVersion returns the old "source_version" field's value of the ProcessDesign entity.
// If the ProcessDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessDesignMutation) OldSourceVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceVersion: %w", err)
	}
	return oldValue.SourceVersion, nil
}

// ClearSourceVersion clears the value of the "source_version" field.
func (m *ProcessDesignMutation) ClearSourceVersion() {
	m.source_version = nil
	m.clearedFields[processdesign.FieldSourceVersion] = struct{}{}
}

// SourceVersionCleared returns if the "source_version" field was cleared in this mutation.
func (m *ProcessDesignMutation) SourceVersionCleared() bool {
	_, ok := m.clearedFields[processdesign.FieldSourceVersion]
	return ok
}

// ResetSourceVersion resets all changes to the "source_version" field.
func (m *ProcessDesignMutation) ResetSourceVersion() {
	m.source_version = nil
	delete(m.clearedFields, processdesign.FieldSourceVersion)
}

// Where appends a list predicates to the ProcessDesignMutation builder.
func (m *ProcessDesignMutation) Where(ps ...predicate.ProcessDesign) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcessDesignMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcessDesignMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcessDesign, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcessDesignMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcessDesignMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcessDesign).
func (m *ProcessDesignMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessDesignMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.version != nil {
		fields = append(fields, processdesign.FieldVersion)
	}
	if m.disabled != nil {
		fields = append(fields, processdesign.FieldDisabled)
	}
	if m.extras != nil {
		fields = append(fields, processdesign.FieldExtras)
	}
	if m.tenant_id != nil {
		fields = append(fields, processdesign.FieldTenantID)
	}
	if m.created_by != nil {
		fields = append(fields, processdesign.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, processdesign.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, processdesign.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processdesign.FieldUpdatedAt)
	}
	if m.template_id != nil {
		fields = append(fields, processdesign.FieldTemplateID)
	}
	if m.graph_data != nil {
		fields = append(fields, processdesign.FieldGraphData)
	}
	if m.node_layouts != nil {
		fields = append(fields, processdesign.FieldNodeLayouts)
	}
	if m.properties != nil {
		fields = append(fields, processdesign.FieldProperties)
	}
	if m.validation_rules != nil {
		fields = append(fields, processdesign.FieldValidationRules)
	}
	if m.is_draft != nil {
		fields = append(fields, processdesign.FieldIsDraft)
	}
	if m.source_version != nil {
		fields = append(fields, processdesign.FieldSourceVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessDesignMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processdesign.FieldVersion:
		return m.Version()
	case processdesign.FieldDisabled:
		return m.Disabled()
	case processdesign.FieldExtras:
		return m.Extras()
	case processdesign.FieldTenantID:
		return m.TenantID()
	case processdesign.FieldCreatedBy:
		return m.CreatedBy()
	case processdesign.FieldUpdatedBy:
		return m.UpdatedBy()
	case processdesign.FieldCreatedAt:
		return m.CreatedAt()
	case processdesign.FieldUpdatedAt:
		return m.UpdatedAt()
	case processdesign.FieldTemplateID:
		return m.TemplateID()
	case processdesign.FieldGraphData:
		return m.GraphData()
	case processdesign.FieldNodeLayouts:
		return m.NodeLayouts()
	case processdesign.FieldProperties:
		return m.Properties()
	case processdesign.FieldValidationRules:
		return m.ValidationRules()
	case processdesign.FieldIsDraft:
		return m.IsDraft()
	case processdesign.FieldSourceVersion:
		return m.SourceVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessDesignMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processdesign.FieldVersion:
		return m.OldVersion(ctx)
	case processdesign.FieldDisabled:
		return m.OldDisabled(ctx)
	case processdesign.FieldExtras:
		return m.OldExtras(ctx)
	case processdesign.FieldTenantID:
		return m.OldTenantID(ctx)
	case processdesign.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case processdesign.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case processdesign.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processdesign.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case processdesign.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case processdesign.FieldGraphData:
		return m.OldGraphData(ctx)
	case processdesign.FieldNodeLayouts:
		return m.OldNodeLayouts(ctx)
	case processdesign.FieldProperties:
		return m.OldProperties(ctx)
	case processdesign.FieldValidationRules:
		return m.OldValidationRules(ctx)
	case processdesign.FieldIsDraft:
		return m.OldIsDraft(ctx)
	case processdesign.FieldSourceVersion:
		return m.OldSourceVersion(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessDesign field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessDesignMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processdesign.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case processdesign.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case processdesign.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case processdesign.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processdesign.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case processdesign.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case processdesign.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processdesign.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case processdesign.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case processdesign.FieldGraphData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGraphData(v)
		return nil
	case processdesign.FieldNodeLayouts:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeLayouts(v)
		return nil
	case processdesign.FieldProperties:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProperties(v)
		return nil
	case processdesign.FieldValidationRules:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationRules(v)
		return nil
	case processdesign.FieldIsDraft:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDraft(v)
		return nil
	case processdesign.FieldSourceVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessDesign field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessDesignMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, processdesign.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, processdesign.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessDesignMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processdesign.FieldCreatedAt:
		return m.AddedCreatedAt()
	case processdesign.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessDesignMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processdesign.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case processdesign.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessDesign numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessDesignMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processdesign.FieldVersion) {
		fields = append(fields, processdesign.FieldVersion)
	}
	if m.FieldCleared(processdesign.FieldDisabled) {
		fields = append(fields, processdesign.FieldDisabled)
	}
	if m.FieldCleared(processdesign.FieldExtras) {
		fields = append(fields, processdesign.FieldExtras)
	}
	if m.FieldCleared(processdesign.FieldTenantID) {
		fields = append(fields, processdesign.FieldTenantID)
	}
	if m.FieldCleared(processdesign.FieldCreatedBy) {
		fields = append(fields, processdesign.FieldCreatedBy)
	}
	if m.FieldCleared(processdesign.FieldUpdatedBy) {
		fields = append(fields, processdesign.FieldUpdatedBy)
	}
	if m.FieldCleared(processdesign.FieldCreatedAt) {
		fields = append(fields, processdesign.FieldCreatedAt)
	}
	if m.FieldCleared(processdesign.FieldUpdatedAt) {
		fields = append(fields, processdesign.FieldUpdatedAt)
	}
	if m.FieldCleared(processdesign.FieldGraphData) {
		fields = append(fields, processdesign.FieldGraphData)
	}
	if m.FieldCleared(processdesign.FieldNodeLayouts) {
		fields = append(fields, processdesign.FieldNodeLayouts)
	}
	if m.FieldCleared(processdesign.FieldProperties) {
		fields = append(fields, processdesign.FieldProperties)
	}
	if m.FieldCleared(processdesign.FieldValidationRules) {
		fields = append(fields, processdesign.FieldValidationRules)
	}
	if m.FieldCleared(processdesign.FieldSourceVersion) {
		fields = append(fields, processdesign.FieldSourceVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessDesignMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessDesignMutation) ClearField(name string) error {
	switch name {
	case processdesign.FieldVersion:
		m.ClearVersion()
		return nil
	case processdesign.FieldDisabled:
		m.ClearDisabled()
		return nil
	case processdesign.FieldExtras:
		m.ClearExtras()
		return nil
	case processdesign.FieldTenantID:
		m.ClearTenantID()
		return nil
	case processdesign.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case processdesign.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case processdesign.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case processdesign.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case processdesign.FieldGraphData:
		m.ClearGraphData()
		return nil
	case processdesign.FieldNodeLayouts:
		m.ClearNodeLayouts()
		return nil
	case processdesign.FieldProperties:
		m.ClearProperties()
		return nil
	case processdesign.FieldValidationRules:
		m.ClearValidationRules()
		return nil
	case processdesign.FieldSourceVersion:
		m.ClearSourceVersion()
		return nil
	}
	return fmt.Errorf("unknown ProcessDesign nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessDesignMutation) ResetField(name string) error {
	switch name {
	case processdesign.FieldVersion:
		m.ResetVersion()
		return nil
	case processdesign.FieldDisabled:
		m.ResetDisabled()
		return nil
	case processdesign.FieldExtras:
		m.ResetExtras()
		return nil
	case processdesign.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processdesign.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case processdesign.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case processdesign.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processdesign.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case processdesign.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case processdesign.FieldGraphData:
		m.ResetGraphData()
		return nil
	case processdesign.FieldNodeLayouts:
		m.ResetNodeLayouts()
		return nil
	case processdesign.FieldProperties:
		m.ResetProperties()
		return nil
	case processdesign.FieldValidationRules:
		m.ResetValidationRules()
		return nil
	case processdesign.FieldIsDraft:
		m.ResetIsDraft()
		return nil
	case processdesign.FieldSourceVersion:
		m.ResetSourceVersion()
		return nil
	}
	return fmt.Errorf("unknown ProcessDesign field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessDesignMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessDesignMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessDesignMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessDesignMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessDesignMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessDesignMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessDesignMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessDesign unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessDesignMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessDesign edge %s", name)
}

// RuleMutation represents an operation that mutates the Rule nodes in the graph.
type RuleMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	code              *string
	description       *string
	_type             *string
	status            *string
	extras            *map[string]interface{}
	tenant_id         *string
	created_by        *string
	updated_by        *string
	created_at        *int64
	addcreated_at     *int64
	updated_at        *int64
	addupdated_at     *int64
	rule_key          *string
	template_id       *string
	node_key          *string
	conditions        *[]string
	appendconditions  []string
	actions           *map[string]interface{}
	priority          *int
	addpriority       *int
	is_enabled        *bool
	effective_time    *int64
	addeffective_time *int64
	expire_time       *int64
	addexpire_time    *int64
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Rule, error)
	predicates        []predicate.Rule
}

var _ ent.Mutation = (*RuleMutation)(nil)

// ruleOption allows management of the mutation configuration using functional options.
type ruleOption func(*RuleMutation)

// newRuleMutation creates new mutation for the Rule entity.
func newRuleMutation(c config, op Op, opts ...ruleOption) *RuleMutation {
	m := &RuleMutation{
		config:        c,
		op:            op,
		typ:           TypeRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRuleID sets the ID field of the mutation.
func withRuleID(id string) ruleOption {
	return func(m *RuleMutation) {
		var (
			err   error
			once  sync.Once
			value *Rule
		)
		m.oldValue = func(ctx context.Context) (*Rule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRule sets the old Rule of the mutation.
func withRule(node *Rule) ruleOption {
	return func(m *RuleMutation) {
		m.oldValue = func(context.Context) (*Rule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Rule entities.
func (m *RuleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RuleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RuleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *RuleMutation) ClearName() {
	m.name = nil
	m.clearedFields[rule.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *RuleMutation) NameCleared() bool {
	_, ok := m.clearedFields[rule.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *RuleMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, rule.FieldName)
}

// SetCode sets the "code" field.
func (m *RuleMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RuleMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *RuleMutation) ClearCode() {
	m.code = nil
	m.clearedFields[rule.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *RuleMutation) CodeCleared() bool {
	_, ok := m.clearedFields[rule.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *RuleMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, rule.FieldCode)
}

// SetDescription sets the "description" field.
func (m *RuleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RuleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RuleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[rule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RuleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[rule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RuleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, rule.FieldDescription)
}

// SetType sets the "type" field.
func (m *RuleMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RuleMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *RuleMutation) ClearType() {
	m._type = nil
	m.clearedFields[rule.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *RuleMutation) TypeCleared() bool {
	_, ok := m.clearedFields[rule.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *RuleMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, rule.FieldType)
}

// SetStatus sets the "status" field.
func (m *RuleMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *RuleMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *RuleMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[rule.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RuleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[rule.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RuleMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, rule.FieldStatus)
}

// SetExtras sets the "extras" field.
func (m *RuleMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *RuleMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *RuleMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[rule.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *RuleMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[rule.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *RuleMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, rule.FieldExtras)
}

// SetTenantID sets the "tenant_id" field.
func (m *RuleMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RuleMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *RuleMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[rule.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *RuleMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[rule.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RuleMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, rule.FieldTenantID)
}

// SetCreatedBy sets the "created_by" field.
func (m *RuleMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RuleMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RuleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[rule.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RuleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[rule.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RuleMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, rule.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RuleMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RuleMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RuleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[rule.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RuleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[rule.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RuleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, rule.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *RuleMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RuleMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *RuleMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RuleMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RuleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[rule.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RuleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[rule.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RuleMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, rule.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RuleMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RuleMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *RuleMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RuleMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RuleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[rule.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RuleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[rule.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, rule.FieldUpdatedAt)
}

// SetRuleKey sets the "rule_key" field.
func (m *RuleMutation) SetRuleKey(s string) {
	m.rule_key = &s
}

// RuleKey returns the value of the "rule_key" field in the mutation.
func (m *RuleMutation) RuleKey() (r string, exists bool) {
	v := m.rule_key
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleKey returns the old "rule_key" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldRuleKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleKey: %w", err)
	}
	return oldValue.RuleKey, nil
}

// ResetRuleKey resets all changes to the "rule_key" field.
func (m *RuleMutation) ResetRuleKey() {
	m.rule_key = nil
}

// SetTemplateID sets the "template_id" field.
func (m *RuleMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *RuleMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ClearTemplateID clears the value of the "template_id" field.
func (m *RuleMutation) ClearTemplateID() {
	m.template_id = nil
	m.clearedFields[rule.FieldTemplateID] = struct{}{}
}

// TemplateIDCleared returns if the "template_id" field was cleared in this mutation.
func (m *RuleMutation) TemplateIDCleared() bool {
	_, ok := m.clearedFields[rule.FieldTemplateID]
	return ok
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *RuleMutation) ResetTemplateID() {
	m.template_id = nil
	delete(m.clearedFields, rule.FieldTemplateID)
}

// SetNodeKey sets the "node_key" field.
func (m *RuleMutation) SetNodeKey(s string) {
	m.node_key = &s
}

// NodeKey returns the value of the "node_key" field in the mutation.
func (m *RuleMutation) NodeKey() (r string, exists bool) {
	v := m.node_key
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeKey returns the old "node_key" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldNodeKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeKey: %w", err)
	}
	return oldValue.NodeKey, nil
}

// ClearNodeKey clears the value of the "node_key" field.
func (m *RuleMutation) ClearNodeKey() {
	m.node_key = nil
	m.clearedFields[rule.FieldNodeKey] = struct{}{}
}

// NodeKeyCleared returns if the "node_key" field was cleared in this mutation.
func (m *RuleMutation) NodeKeyCleared() bool {
	_, ok := m.clearedFields[rule.FieldNodeKey]
	return ok
}

// ResetNodeKey resets all changes to the "node_key" field.
func (m *RuleMutation) ResetNodeKey() {
	m.node_key = nil
	delete(m.clearedFields, rule.FieldNodeKey)
}

// SetConditions sets the "conditions" field.
func (m *RuleMutation) SetConditions(s []string) {
	m.conditions = &s
	m.appendconditions = nil
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *RuleMutation) Conditions() (r []string, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldConditions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// AppendConditions adds s to the "conditions" field.
func (m *RuleMutation) AppendConditions(s []string) {
	m.appendconditions = append(m.appendconditions, s...)
}

// AppendedConditions returns the list of values that were appended to the "conditions" field in this mutation.
func (m *RuleMutation) AppendedConditions() ([]string, bool) {
	if len(m.appendconditions) == 0 {
		return nil, false
	}
	return m.appendconditions, true
}

// ResetConditions resets all changes to the "conditions" field.
func (m *RuleMutation) ResetConditions() {
	m.conditions = nil
	m.appendconditions = nil
}

// SetActions sets the "actions" field.
func (m *RuleMutation) SetActions(value map[string]interface{}) {
	m.actions = &value
}

// Actions returns the value of the "actions" field in the mutation.
func (m *RuleMutation) Actions() (r map[string]interface{}, exists bool) {
	v := m.actions
	if v == nil {
		return
	}
	return *v, true
}

// OldActions returns the old "actions" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldActions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActions: %w", err)
	}
	return oldValue.Actions, nil
}

// ResetActions resets all changes to the "actions" field.
func (m *RuleMutation) ResetActions() {
	m.actions = nil
}

// SetPriority sets the "priority" field.
func (m *RuleMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *RuleMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *RuleMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *RuleMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *RuleMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetIsEnabled sets the "is_enabled" field.
func (m *RuleMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *RuleMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldIsEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *RuleMutation) ResetIsEnabled() {
	m.is_enabled = nil
}

// SetEffectiveTime sets the "effective_time" field.
func (m *RuleMutation) SetEffectiveTime(i int64) {
	m.effective_time = &i
	m.addeffective_time = nil
}

// EffectiveTime returns the value of the "effective_time" field in the mutation.
func (m *RuleMutation) EffectiveTime() (r int64, exists bool) {
	v := m.effective_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveTime returns the old "effective_time" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldEffectiveTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveTime: %w", err)
	}
	return oldValue.EffectiveTime, nil
}

// AddEffectiveTime adds i to the "effective_time" field.
func (m *RuleMutation) AddEffectiveTime(i int64) {
	if m.addeffective_time != nil {
		*m.addeffective_time += i
	} else {
		m.addeffective_time = &i
	}
}

// AddedEffectiveTime returns the value that was added to the "effective_time" field in this mutation.
func (m *RuleMutation) AddedEffectiveTime() (r int64, exists bool) {
	v := m.addeffective_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearEffectiveTime clears the value of the "effective_time" field.
func (m *RuleMutation) ClearEffectiveTime() {
	m.effective_time = nil
	m.addeffective_time = nil
	m.clearedFields[rule.FieldEffectiveTime] = struct{}{}
}

// EffectiveTimeCleared returns if the "effective_time" field was cleared in this mutation.
func (m *RuleMutation) EffectiveTimeCleared() bool {
	_, ok := m.clearedFields[rule.FieldEffectiveTime]
	return ok
}

// ResetEffectiveTime resets all changes to the "effective_time" field.
func (m *RuleMutation) ResetEffectiveTime() {
	m.effective_time = nil
	m.addeffective_time = nil
	delete(m.clearedFields, rule.FieldEffectiveTime)
}

// SetExpireTime sets the "expire_time" field.
func (m *RuleMutation) SetExpireTime(i int64) {
	m.expire_time = &i
	m.addexpire_time = nil
}

// ExpireTime returns the value of the "expire_time" field in the mutation.
func (m *RuleMutation) ExpireTime() (r int64, exists bool) {
	v := m.expire_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireTime returns the old "expire_time" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldExpireTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireTime: %w", err)
	}
	return oldValue.ExpireTime, nil
}

// AddExpireTime adds i to the "expire_time" field.
func (m *RuleMutation) AddExpireTime(i int64) {
	if m.addexpire_time != nil {
		*m.addexpire_time += i
	} else {
		m.addexpire_time = &i
	}
}

// AddedExpireTime returns the value that was added to the "expire_time" field in this mutation.
func (m *RuleMutation) AddedExpireTime() (r int64, exists bool) {
	v := m.addexpire_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearExpireTime clears the value of the "expire_time" field.
func (m *RuleMutation) ClearExpireTime() {
	m.expire_time = nil
	m.addexpire_time = nil
	m.clearedFields[rule.FieldExpireTime] = struct{}{}
}

// ExpireTimeCleared returns if the "expire_time" field was cleared in this mutation.
func (m *RuleMutation) ExpireTimeCleared() bool {
	_, ok := m.clearedFields[rule.FieldExpireTime]
	return ok
}

// ResetExpireTime resets all changes to the "expire_time" field.
func (m *RuleMutation) ResetExpireTime() {
	m.expire_time = nil
	m.addexpire_time = nil
	delete(m.clearedFields, rule.FieldExpireTime)
}

// Where appends a list predicates to the RuleMutation builder.
func (m *RuleMutation) Where(ps ...predicate.Rule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Rule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Rule).
func (m *RuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RuleMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.name != nil {
		fields = append(fields, rule.FieldName)
	}
	if m.code != nil {
		fields = append(fields, rule.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, rule.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, rule.FieldType)
	}
	if m.status != nil {
		fields = append(fields, rule.FieldStatus)
	}
	if m.extras != nil {
		fields = append(fields, rule.FieldExtras)
	}
	if m.tenant_id != nil {
		fields = append(fields, rule.FieldTenantID)
	}
	if m.created_by != nil {
		fields = append(fields, rule.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, rule.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, rule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rule.FieldUpdatedAt)
	}
	if m.rule_key != nil {
		fields = append(fields, rule.FieldRuleKey)
	}
	if m.template_id != nil {
		fields = append(fields, rule.FieldTemplateID)
	}
	if m.node_key != nil {
		fields = append(fields, rule.FieldNodeKey)
	}
	if m.conditions != nil {
		fields = append(fields, rule.FieldConditions)
	}
	if m.actions != nil {
		fields = append(fields, rule.FieldActions)
	}
	if m.priority != nil {
		fields = append(fields, rule.FieldPriority)
	}
	if m.is_enabled != nil {
		fields = append(fields, rule.FieldIsEnabled)
	}
	if m.effective_time != nil {
		fields = append(fields, rule.FieldEffectiveTime)
	}
	if m.expire_time != nil {
		fields = append(fields, rule.FieldExpireTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rule.FieldName:
		return m.Name()
	case rule.FieldCode:
		return m.Code()
	case rule.FieldDescription:
		return m.Description()
	case rule.FieldType:
		return m.GetType()
	case rule.FieldStatus:
		return m.Status()
	case rule.FieldExtras:
		return m.Extras()
	case rule.FieldTenantID:
		return m.TenantID()
	case rule.FieldCreatedBy:
		return m.CreatedBy()
	case rule.FieldUpdatedBy:
		return m.UpdatedBy()
	case rule.FieldCreatedAt:
		return m.CreatedAt()
	case rule.FieldUpdatedAt:
		return m.UpdatedAt()
	case rule.FieldRuleKey:
		return m.RuleKey()
	case rule.FieldTemplateID:
		return m.TemplateID()
	case rule.FieldNodeKey:
		return m.NodeKey()
	case rule.FieldConditions:
		return m.Conditions()
	case rule.FieldActions:
		return m.Actions()
	case rule.FieldPriority:
		return m.Priority()
	case rule.FieldIsEnabled:
		return m.IsEnabled()
	case rule.FieldEffectiveTime:
		return m.EffectiveTime()
	case rule.FieldExpireTime:
		return m.ExpireTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rule.FieldName:
		return m.OldName(ctx)
	case rule.FieldCode:
		return m.OldCode(ctx)
	case rule.FieldDescription:
		return m.OldDescription(ctx)
	case rule.FieldType:
		return m.OldType(ctx)
	case rule.FieldStatus:
		return m.OldStatus(ctx)
	case rule.FieldExtras:
		return m.OldExtras(ctx)
	case rule.FieldTenantID:
		return m.OldTenantID(ctx)
	case rule.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rule.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rule.FieldRuleKey:
		return m.OldRuleKey(ctx)
	case rule.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case rule.FieldNodeKey:
		return m.OldNodeKey(ctx)
	case rule.FieldConditions:
		return m.OldConditions(ctx)
	case rule.FieldActions:
		return m.OldActions(ctx)
	case rule.FieldPriority:
		return m.OldPriority(ctx)
	case rule.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	case rule.FieldEffectiveTime:
		return m.OldEffectiveTime(ctx)
	case rule.FieldExpireTime:
		return m.OldExpireTime(ctx)
	}
	return nil, fmt.Errorf("unknown Rule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rule.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case rule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case rule.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case rule.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rule.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case rule.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case rule.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rule.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rule.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rule.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rule.FieldRuleKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleKey(v)
		return nil
	case rule.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case rule.FieldNodeKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeKey(v)
		return nil
	case rule.FieldConditions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case rule.FieldActions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActions(v)
		return nil
	case rule.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case rule.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	case rule.FieldEffectiveTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveTime(v)
		return nil
	case rule.FieldExpireTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireTime(v)
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RuleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, rule.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, rule.FieldUpdatedAt)
	}
	if m.addpriority != nil {
		fields = append(fields, rule.FieldPriority)
	}
	if m.addeffective_time != nil {
		fields = append(fields, rule.FieldEffectiveTime)
	}
	if m.addexpire_time != nil {
		fields = append(fields, rule.FieldExpireTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rule.FieldCreatedAt:
		return m.AddedCreatedAt()
	case rule.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case rule.FieldPriority:
		return m.AddedPriority()
	case rule.FieldEffectiveTime:
		return m.AddedEffectiveTime()
	case rule.FieldExpireTime:
		return m.AddedExpireTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rule.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case rule.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case rule.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case rule.FieldEffectiveTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEffectiveTime(v)
		return nil
	case rule.FieldExpireTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpireTime(v)
		return nil
	}
	return fmt.Errorf("unknown Rule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rule.FieldName) {
		fields = append(fields, rule.FieldName)
	}
	if m.FieldCleared(rule.FieldCode) {
		fields = append(fields, rule.FieldCode)
	}
	if m.FieldCleared(rule.FieldDescription) {
		fields = append(fields, rule.FieldDescription)
	}
	if m.FieldCleared(rule.FieldType) {
		fields = append(fields, rule.FieldType)
	}
	if m.FieldCleared(rule.FieldStatus) {
		fields = append(fields, rule.FieldStatus)
	}
	if m.FieldCleared(rule.FieldExtras) {
		fields = append(fields, rule.FieldExtras)
	}
	if m.FieldCleared(rule.FieldTenantID) {
		fields = append(fields, rule.FieldTenantID)
	}
	if m.FieldCleared(rule.FieldCreatedBy) {
		fields = append(fields, rule.FieldCreatedBy)
	}
	if m.FieldCleared(rule.FieldUpdatedBy) {
		fields = append(fields, rule.FieldUpdatedBy)
	}
	if m.FieldCleared(rule.FieldCreatedAt) {
		fields = append(fields, rule.FieldCreatedAt)
	}
	if m.FieldCleared(rule.FieldUpdatedAt) {
		fields = append(fields, rule.FieldUpdatedAt)
	}
	if m.FieldCleared(rule.FieldTemplateID) {
		fields = append(fields, rule.FieldTemplateID)
	}
	if m.FieldCleared(rule.FieldNodeKey) {
		fields = append(fields, rule.FieldNodeKey)
	}
	if m.FieldCleared(rule.FieldEffectiveTime) {
		fields = append(fields, rule.FieldEffectiveTime)
	}
	if m.FieldCleared(rule.FieldExpireTime) {
		fields = append(fields, rule.FieldExpireTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RuleMutation) ClearField(name string) error {
	switch name {
	case rule.FieldName:
		m.ClearName()
		return nil
	case rule.FieldCode:
		m.ClearCode()
		return nil
	case rule.FieldDescription:
		m.ClearDescription()
		return nil
	case rule.FieldType:
		m.ClearType()
		return nil
	case rule.FieldStatus:
		m.ClearStatus()
		return nil
	case rule.FieldExtras:
		m.ClearExtras()
		return nil
	case rule.FieldTenantID:
		m.ClearTenantID()
		return nil
	case rule.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case rule.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case rule.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case rule.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case rule.FieldTemplateID:
		m.ClearTemplateID()
		return nil
	case rule.FieldNodeKey:
		m.ClearNodeKey()
		return nil
	case rule.FieldEffectiveTime:
		m.ClearEffectiveTime()
		return nil
	case rule.FieldExpireTime:
		m.ClearExpireTime()
		return nil
	}
	return fmt.Errorf("unknown Rule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RuleMutation) ResetField(name string) error {
	switch name {
	case rule.FieldName:
		m.ResetName()
		return nil
	case rule.FieldCode:
		m.ResetCode()
		return nil
	case rule.FieldDescription:
		m.ResetDescription()
		return nil
	case rule.FieldType:
		m.ResetType()
		return nil
	case rule.FieldStatus:
		m.ResetStatus()
		return nil
	case rule.FieldExtras:
		m.ResetExtras()
		return nil
	case rule.FieldTenantID:
		m.ResetTenantID()
		return nil
	case rule.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rule.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rule.FieldRuleKey:
		m.ResetRuleKey()
		return nil
	case rule.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case rule.FieldNodeKey:
		m.ResetNodeKey()
		return nil
	case rule.FieldConditions:
		m.ResetConditions()
		return nil
	case rule.FieldActions:
		m.ResetActions()
		return nil
	case rule.FieldPriority:
		m.ResetPriority()
		return nil
	case rule.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	case rule.FieldEffectiveTime:
		m.ResetEffectiveTime()
		return nil
	case rule.FieldExpireTime:
		m.ResetExpireTime()
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Rule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Rule edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	description       *string
	status            *string
	process_id        *string
	template_id       *string
	business_key      *string
	node_key          *string
	node_type         *string
	node_config       *map[string]interface{}
	node_rules        *map[string]interface{}
	node_events       *map[string]interface{}
	assignees         *[]string
	appendassignees   []string
	candidates        *[]string
	appendcandidates  []string
	delegated_from    *string
	delegated_reason  *string
	is_delegated      *bool
	is_transferred    *bool
	start_time        *int64
	addstart_time     *int64
	end_time          *int64
	addend_time       *int64
	due_time          *int64
	adddue_time       *int64
	duration          *int
	addduration       *int
	priority          *int
	addpriority       *int
	is_timeout        *bool
	reminder_count    *int
	addreminder_count *int
	allow_cancel      *bool
	allow_urge        *bool
	allow_delegate    *bool
	allow_transfer    *bool
	is_draft_enabled  *bool
	is_auto_start     *bool
	strict_mode       *bool
	extras            *map[string]interface{}
	tenant_id         *string
	created_by        *string
	updated_by        *string
	created_at        *int64
	addcreated_at     *int64
	updated_at        *int64
	addupdated_at     *int64
	task_key          *string
	parent_id         *string
	child_ids         *[]string
	appendchild_ids   []string
	action            *string
	comment           *string
	attachments       *map[string]interface{}
	form_data         *map[string]interface{}
	variables         *map[string]interface{}
	is_resubmit       *bool
	claim_time        *int64
	addclaim_time     *int64
	is_urged          *bool
	urge_count        *int
	addurge_count     *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Task, error)
	predicates        []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id string) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TaskMutation) ClearName() {
	m.name = nil
	m.clearedFields[task.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TaskMutation) NameCleared() bool {
	_, ok := m.clearedFields[task.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TaskMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, task.FieldName)
}

// SetDescription sets the "description" field.
func (m *TaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[task.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[task.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, task.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TaskMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[task.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TaskMutation) StatusCleared() bool {
	_, ok := m.clearedFields[task.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, task.FieldStatus)
}

// SetProcessID sets the "process_id" field.
func (m *TaskMutation) SetProcessID(s string) {
	m.process_id = &s
}

// ProcessID returns the value of the "process_id" field in the mutation.
func (m *TaskMutation) ProcessID() (r string, exists bool) {
	v := m.process_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessID returns the old "process_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldProcessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessID: %w", err)
	}
	return oldValue.ProcessID, nil
}

// ResetProcessID resets all changes to the "process_id" field.
func (m *TaskMutation) ResetProcessID() {
	m.process_id = nil
}

// SetTemplateID sets the "template_id" field.
func (m *TaskMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *TaskMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *TaskMutation) ResetTemplateID() {
	m.template_id = nil
}

// SetBusinessKey sets the "business_key" field.
func (m *TaskMutation) SetBusinessKey(s string) {
	m.business_key = &s
}

// BusinessKey returns the value of the "business_key" field in the mutation.
func (m *TaskMutation) BusinessKey() (r string, exists bool) {
	v := m.business_key
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessKey returns the old "business_key" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldBusinessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessKey: %w", err)
	}
	return oldValue.BusinessKey, nil
}

// ResetBusinessKey resets all changes to the "business_key" field.
func (m *TaskMutation) ResetBusinessKey() {
	m.business_key = nil
}

// SetNodeKey sets the "node_key" field.
func (m *TaskMutation) SetNodeKey(s string) {
	m.node_key = &s
}

// NodeKey returns the value of the "node_key" field in the mutation.
func (m *TaskMutation) NodeKey() (r string, exists bool) {
	v := m.node_key
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeKey returns the old "node_key" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldNodeKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeKey: %w", err)
	}
	return oldValue.NodeKey, nil
}

// ResetNodeKey resets all changes to the "node_key" field.
func (m *TaskMutation) ResetNodeKey() {
	m.node_key = nil
}

// SetNodeType sets the "node_type" field.
func (m *TaskMutation) SetNodeType(s string) {
	m.node_type = &s
}

// NodeType returns the value of the "node_type" field in the mutation.
func (m *TaskMutation) NodeType() (r string, exists bool) {
	v := m.node_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeType returns the old "node_type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldNodeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeType: %w", err)
	}
	return oldValue.NodeType, nil
}

// ResetNodeType resets all changes to the "node_type" field.
func (m *TaskMutation) ResetNodeType() {
	m.node_type = nil
}

// SetNodeConfig sets the "node_config" field.
func (m *TaskMutation) SetNodeConfig(value map[string]interface{}) {
	m.node_config = &value
}

// NodeConfig returns the value of the "node_config" field in the mutation.
func (m *TaskMutation) NodeConfig() (r map[string]interface{}, exists bool) {
	v := m.node_config
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeConfig returns the old "node_config" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldNodeConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeConfig: %w", err)
	}
	return oldValue.NodeConfig, nil
}

// ClearNodeConfig clears the value of the "node_config" field.
func (m *TaskMutation) ClearNodeConfig() {
	m.node_config = nil
	m.clearedFields[task.FieldNodeConfig] = struct{}{}
}

// NodeConfigCleared returns if the "node_config" field was cleared in this mutation.
func (m *TaskMutation) NodeConfigCleared() bool {
	_, ok := m.clearedFields[task.FieldNodeConfig]
	return ok
}

// ResetNodeConfig resets all changes to the "node_config" field.
func (m *TaskMutation) ResetNodeConfig() {
	m.node_config = nil
	delete(m.clearedFields, task.FieldNodeConfig)
}

// SetNodeRules sets the "node_rules" field.
func (m *TaskMutation) SetNodeRules(value map[string]interface{}) {
	m.node_rules = &value
}

// NodeRules returns the value of the "node_rules" field in the mutation.
func (m *TaskMutation) NodeRules() (r map[string]interface{}, exists bool) {
	v := m.node_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeRules returns the old "node_rules" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldNodeRules(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeRules: %w", err)
	}
	return oldValue.NodeRules, nil
}

// ClearNodeRules clears the value of the "node_rules" field.
func (m *TaskMutation) ClearNodeRules() {
	m.node_rules = nil
	m.clearedFields[task.FieldNodeRules] = struct{}{}
}

// NodeRulesCleared returns if the "node_rules" field was cleared in this mutation.
func (m *TaskMutation) NodeRulesCleared() bool {
	_, ok := m.clearedFields[task.FieldNodeRules]
	return ok
}

// ResetNodeRules resets all changes to the "node_rules" field.
func (m *TaskMutation) ResetNodeRules() {
	m.node_rules = nil
	delete(m.clearedFields, task.FieldNodeRules)
}

// SetNodeEvents sets the "node_events" field.
func (m *TaskMutation) SetNodeEvents(value map[string]interface{}) {
	m.node_events = &value
}

// NodeEvents returns the value of the "node_events" field in the mutation.
func (m *TaskMutation) NodeEvents() (r map[string]interface{}, exists bool) {
	v := m.node_events
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeEvents returns the old "node_events" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldNodeEvents(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeEvents: %w", err)
	}
	return oldValue.NodeEvents, nil
}

// ClearNodeEvents clears the value of the "node_events" field.
func (m *TaskMutation) ClearNodeEvents() {
	m.node_events = nil
	m.clearedFields[task.FieldNodeEvents] = struct{}{}
}

// NodeEventsCleared returns if the "node_events" field was cleared in this mutation.
func (m *TaskMutation) NodeEventsCleared() bool {
	_, ok := m.clearedFields[task.FieldNodeEvents]
	return ok
}

// ResetNodeEvents resets all changes to the "node_events" field.
func (m *TaskMutation) ResetNodeEvents() {
	m.node_events = nil
	delete(m.clearedFields, task.FieldNodeEvents)
}

// SetAssignees sets the "assignees" field.
func (m *TaskMutation) SetAssignees(s []string) {
	m.assignees = &s
	m.appendassignees = nil
}

// Assignees returns the value of the "assignees" field in the mutation.
func (m *TaskMutation) Assignees() (r []string, exists bool) {
	v := m.assignees
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignees returns the old "assignees" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAssignees(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignees is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignees requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignees: %w", err)
	}
	return oldValue.Assignees, nil
}

// AppendAssignees adds s to the "assignees" field.
func (m *TaskMutation) AppendAssignees(s []string) {
	m.appendassignees = append(m.appendassignees, s...)
}

// AppendedAssignees returns the list of values that were appended to the "assignees" field in this mutation.
func (m *TaskMutation) AppendedAssignees() ([]string, bool) {
	if len(m.appendassignees) == 0 {
		return nil, false
	}
	return m.appendassignees, true
}

// ResetAssignees resets all changes to the "assignees" field.
func (m *TaskMutation) ResetAssignees() {
	m.assignees = nil
	m.appendassignees = nil
}

// SetCandidates sets the "candidates" field.
func (m *TaskMutation) SetCandidates(s []string) {
	m.candidates = &s
	m.appendcandidates = nil
}

// Candidates returns the value of the "candidates" field in the mutation.
func (m *TaskMutation) Candidates() (r []string, exists bool) {
	v := m.candidates
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidates returns the old "candidates" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCandidates(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidates: %w", err)
	}
	return oldValue.Candidates, nil
}

// AppendCandidates adds s to the "candidates" field.
func (m *TaskMutation) AppendCandidates(s []string) {
	m.appendcandidates = append(m.appendcandidates, s...)
}

// AppendedCandidates returns the list of values that were appended to the "candidates" field in this mutation.
func (m *TaskMutation) AppendedCandidates() ([]string, bool) {
	if len(m.appendcandidates) == 0 {
		return nil, false
	}
	return m.appendcandidates, true
}

// ResetCandidates resets all changes to the "candidates" field.
func (m *TaskMutation) ResetCandidates() {
	m.candidates = nil
	m.appendcandidates = nil
}

// SetDelegatedFrom sets the "delegated_from" field.
func (m *TaskMutation) SetDelegatedFrom(s string) {
	m.delegated_from = &s
}

// DelegatedFrom returns the value of the "delegated_from" field in the mutation.
func (m *TaskMutation) DelegatedFrom() (r string, exists bool) {
	v := m.delegated_from
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegatedFrom returns the old "delegated_from" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDelegatedFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegatedFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegatedFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegatedFrom: %w", err)
	}
	return oldValue.DelegatedFrom, nil
}

// ClearDelegatedFrom clears the value of the "delegated_from" field.
func (m *TaskMutation) ClearDelegatedFrom() {
	m.delegated_from = nil
	m.clearedFields[task.FieldDelegatedFrom] = struct{}{}
}

// DelegatedFromCleared returns if the "delegated_from" field was cleared in this mutation.
func (m *TaskMutation) DelegatedFromCleared() bool {
	_, ok := m.clearedFields[task.FieldDelegatedFrom]
	return ok
}

// ResetDelegatedFrom resets all changes to the "delegated_from" field.
func (m *TaskMutation) ResetDelegatedFrom() {
	m.delegated_from = nil
	delete(m.clearedFields, task.FieldDelegatedFrom)
}

// SetDelegatedReason sets the "delegated_reason" field.
func (m *TaskMutation) SetDelegatedReason(s string) {
	m.delegated_reason = &s
}

// DelegatedReason returns the value of the "delegated_reason" field in the mutation.
func (m *TaskMutation) DelegatedReason() (r string, exists bool) {
	v := m.delegated_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegatedReason returns the old "delegated_reason" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDelegatedReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegatedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegatedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegatedReason: %w", err)
	}
	return oldValue.DelegatedReason, nil
}

// ClearDelegatedReason clears the value of the "delegated_reason" field.
func (m *TaskMutation) ClearDelegatedReason() {
	m.delegated_reason = nil
	m.clearedFields[task.FieldDelegatedReason] = struct{}{}
}

// DelegatedReasonCleared returns if the "delegated_reason" field was cleared in this mutation.
func (m *TaskMutation) DelegatedReasonCleared() bool {
	_, ok := m.clearedFields[task.FieldDelegatedReason]
	return ok
}

// ResetDelegatedReason resets all changes to the "delegated_reason" field.
func (m *TaskMutation) ResetDelegatedReason() {
	m.delegated_reason = nil
	delete(m.clearedFields, task.FieldDelegatedReason)
}

// SetIsDelegated sets the "is_delegated" field.
func (m *TaskMutation) SetIsDelegated(b bool) {
	m.is_delegated = &b
}

// IsDelegated returns the value of the "is_delegated" field in the mutation.
func (m *TaskMutation) IsDelegated() (r bool, exists bool) {
	v := m.is_delegated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDelegated returns the old "is_delegated" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsDelegated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDelegated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDelegated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDelegated: %w", err)
	}
	return oldValue.IsDelegated, nil
}

// ResetIsDelegated resets all changes to the "is_delegated" field.
func (m *TaskMutation) ResetIsDelegated() {
	m.is_delegated = nil
}

// SetIsTransferred sets the "is_transferred" field.
func (m *TaskMutation) SetIsTransferred(b bool) {
	m.is_transferred = &b
}

// IsTransferred returns the value of the "is_transferred" field in the mutation.
func (m *TaskMutation) IsTransferred() (r bool, exists bool) {
	v := m.is_transferred
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTransferred returns the old "is_transferred" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsTransferred(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTransferred is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTransferred requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTransferred: %w", err)
	}
	return oldValue.IsTransferred, nil
}

// ResetIsTransferred resets all changes to the "is_transferred" field.
func (m *TaskMutation) ResetIsTransferred() {
	m.is_transferred = nil
}

// SetStartTime sets the "start_time" field.
func (m *TaskMutation) SetStartTime(i int64) {
	m.start_time = &i
	m.addstart_time = nil
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *TaskMutation) StartTime() (r int64, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStartTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// AddStartTime adds i to the "start_time" field.
func (m *TaskMutation) AddStartTime(i int64) {
	if m.addstart_time != nil {
		*m.addstart_time += i
	} else {
		m.addstart_time = &i
	}
}

// AddedStartTime returns the value that was added to the "start_time" field in this mutation.
func (m *TaskMutation) AddedStartTime() (r int64, exists bool) {
	v := m.addstart_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *TaskMutation) ResetStartTime() {
	m.start_time = nil
	m.addstart_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *TaskMutation) SetEndTime(i int64) {
	m.end_time = &i
	m.addend_time = nil
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *TaskMutation) EndTime() (r int64, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldEndTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// AddEndTime adds i to the "end_time" field.
func (m *TaskMutation) AddEndTime(i int64) {
	if m.addend_time != nil {
		*m.addend_time += i
	} else {
		m.addend_time = &i
	}
}

// AddedEndTime returns the value that was added to the "end_time" field in this mutation.
func (m *TaskMutation) AddedEndTime() (r int64, exists bool) {
	v := m.addend_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndTime clears the value of the "end_time" field.
func (m *TaskMutation) ClearEndTime() {
	m.end_time = nil
	m.addend_time = nil
	m.clearedFields[task.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *TaskMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *TaskMutation) ResetEndTime() {
	m.end_time = nil
	m.addend_time = nil
	delete(m.clearedFields, task.FieldEndTime)
}

// SetDueTime sets the "due_time" field.
func (m *TaskMutation) SetDueTime(i int64) {
	m.due_time = &i
	m.adddue_time = nil
}

// DueTime returns the value of the "due_time" field in the mutation.
func (m *TaskMutation) DueTime() (r int64, exists bool) {
	v := m.due_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDueTime returns the old "due_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDueTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueTime: %w", err)
	}
	return oldValue.DueTime, nil
}

// AddDueTime adds i to the "due_time" field.
func (m *TaskMutation) AddDueTime(i int64) {
	if m.adddue_time != nil {
		*m.adddue_time += i
	} else {
		m.adddue_time = &i
	}
}

// AddedDueTime returns the value that was added to the "due_time" field in this mutation.
func (m *TaskMutation) AddedDueTime() (r int64, exists bool) {
	v := m.adddue_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearDueTime clears the value of the "due_time" field.
func (m *TaskMutation) ClearDueTime() {
	m.due_time = nil
	m.adddue_time = nil
	m.clearedFields[task.FieldDueTime] = struct{}{}
}

// DueTimeCleared returns if the "due_time" field was cleared in this mutation.
func (m *TaskMutation) DueTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldDueTime]
	return ok
}

// ResetDueTime resets all changes to the "due_time" field.
func (m *TaskMutation) ResetDueTime() {
	m.due_time = nil
	m.adddue_time = nil
	delete(m.clearedFields, task.FieldDueTime)
}

// SetDuration sets the "duration" field.
func (m *TaskMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *TaskMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *TaskMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *TaskMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *TaskMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[task.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *TaskMutation) DurationCleared() bool {
	_, ok := m.clearedFields[task.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *TaskMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, task.FieldDuration)
}

// SetPriority sets the "priority" field.
func (m *TaskMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TaskMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *TaskMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *TaskMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *TaskMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetIsTimeout sets the "is_timeout" field.
func (m *TaskMutation) SetIsTimeout(b bool) {
	m.is_timeout = &b
}

// IsTimeout returns the value of the "is_timeout" field in the mutation.
func (m *TaskMutation) IsTimeout() (r bool, exists bool) {
	v := m.is_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTimeout returns the old "is_timeout" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsTimeout(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTimeout: %w", err)
	}
	return oldValue.IsTimeout, nil
}

// ResetIsTimeout resets all changes to the "is_timeout" field.
func (m *TaskMutation) ResetIsTimeout() {
	m.is_timeout = nil
}

// SetReminderCount sets the "reminder_count" field.
func (m *TaskMutation) SetReminderCount(i int) {
	m.reminder_count = &i
	m.addreminder_count = nil
}

// ReminderCount returns the value of the "reminder_count" field in the mutation.
func (m *TaskMutation) ReminderCount() (r int, exists bool) {
	v := m.reminder_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReminderCount returns the old "reminder_count" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldReminderCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReminderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReminderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReminderCount: %w", err)
	}
	return oldValue.ReminderCount, nil
}

// AddReminderCount adds i to the "reminder_count" field.
func (m *TaskMutation) AddReminderCount(i int) {
	if m.addreminder_count != nil {
		*m.addreminder_count += i
	} else {
		m.addreminder_count = &i
	}
}

// AddedReminderCount returns the value that was added to the "reminder_count" field in this mutation.
func (m *TaskMutation) AddedReminderCount() (r int, exists bool) {
	v := m.addreminder_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReminderCount resets all changes to the "reminder_count" field.
func (m *TaskMutation) ResetReminderCount() {
	m.reminder_count = nil
	m.addreminder_count = nil
}

// SetAllowCancel sets the "allow_cancel" field.
func (m *TaskMutation) SetAllowCancel(b bool) {
	m.allow_cancel = &b
}

// AllowCancel returns the value of the "allow_cancel" field in the mutation.
func (m *TaskMutation) AllowCancel() (r bool, exists bool) {
	v := m.allow_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowCancel returns the old "allow_cancel" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAllowCancel(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowCancel: %w", err)
	}
	return oldValue.AllowCancel, nil
}

// ResetAllowCancel resets all changes to the "allow_cancel" field.
func (m *TaskMutation) ResetAllowCancel() {
	m.allow_cancel = nil
}

// SetAllowUrge sets the "allow_urge" field.
func (m *TaskMutation) SetAllowUrge(b bool) {
	m.allow_urge = &b
}

// AllowUrge returns the value of the "allow_urge" field in the mutation.
func (m *TaskMutation) AllowUrge() (r bool, exists bool) {
	v := m.allow_urge
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowUrge returns the old "allow_urge" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAllowUrge(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowUrge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowUrge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowUrge: %w", err)
	}
	return oldValue.AllowUrge, nil
}

// ResetAllowUrge resets all changes to the "allow_urge" field.
func (m *TaskMutation) ResetAllowUrge() {
	m.allow_urge = nil
}

// SetAllowDelegate sets the "allow_delegate" field.
func (m *TaskMutation) SetAllowDelegate(b bool) {
	m.allow_delegate = &b
}

// AllowDelegate returns the value of the "allow_delegate" field in the mutation.
func (m *TaskMutation) AllowDelegate() (r bool, exists bool) {
	v := m.allow_delegate
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowDelegate returns the old "allow_delegate" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAllowDelegate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowDelegate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowDelegate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowDelegate: %w", err)
	}
	return oldValue.AllowDelegate, nil
}

// ResetAllowDelegate resets all changes to the "allow_delegate" field.
func (m *TaskMutation) ResetAllowDelegate() {
	m.allow_delegate = nil
}

// SetAllowTransfer sets the "allow_transfer" field.
func (m *TaskMutation) SetAllowTransfer(b bool) {
	m.allow_transfer = &b
}

// AllowTransfer returns the value of the "allow_transfer" field in the mutation.
func (m *TaskMutation) AllowTransfer() (r bool, exists bool) {
	v := m.allow_transfer
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowTransfer returns the old "allow_transfer" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAllowTransfer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowTransfer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowTransfer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowTransfer: %w", err)
	}
	return oldValue.AllowTransfer, nil
}

// ResetAllowTransfer resets all changes to the "allow_transfer" field.
func (m *TaskMutation) ResetAllowTransfer() {
	m.allow_transfer = nil
}

// SetIsDraftEnabled sets the "is_draft_enabled" field.
func (m *TaskMutation) SetIsDraftEnabled(b bool) {
	m.is_draft_enabled = &b
}

// IsDraftEnabled returns the value of the "is_draft_enabled" field in the mutation.
func (m *TaskMutation) IsDraftEnabled() (r bool, exists bool) {
	v := m.is_draft_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDraftEnabled returns the old "is_draft_enabled" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsDraftEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDraftEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDraftEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDraftEnabled: %w", err)
	}
	return oldValue.IsDraftEnabled, nil
}

// ResetIsDraftEnabled resets all changes to the "is_draft_enabled" field.
func (m *TaskMutation) ResetIsDraftEnabled() {
	m.is_draft_enabled = nil
}

// SetIsAutoStart sets the "is_auto_start" field.
func (m *TaskMutation) SetIsAutoStart(b bool) {
	m.is_auto_start = &b
}

// IsAutoStart returns the value of the "is_auto_start" field in the mutation.
func (m *TaskMutation) IsAutoStart() (r bool, exists bool) {
	v := m.is_auto_start
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutoStart returns the old "is_auto_start" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsAutoStart(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAutoStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAutoStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutoStart: %w", err)
	}
	return oldValue.IsAutoStart, nil
}

// ResetIsAutoStart resets all changes to the "is_auto_start" field.
func (m *TaskMutation) ResetIsAutoStart() {
	m.is_auto_start = nil
}

// SetStrictMode sets the "strict_mode" field.
func (m *TaskMutation) SetStrictMode(b bool) {
	m.strict_mode = &b
}

// StrictMode returns the value of the "strict_mode" field in the mutation.
func (m *TaskMutation) StrictMode() (r bool, exists bool) {
	v := m.strict_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldStrictMode returns the old "strict_mode" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStrictMode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrictMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrictMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrictMode: %w", err)
	}
	return oldValue.StrictMode, nil
}

// ResetStrictMode resets all changes to the "strict_mode" field.
func (m *TaskMutation) ResetStrictMode() {
	m.strict_mode = nil
}

// SetExtras sets the "extras" field.
func (m *TaskMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *TaskMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *TaskMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[task.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *TaskMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[task.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *TaskMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, task.FieldExtras)
}

// SetTenantID sets the "tenant_id" field.
func (m *TaskMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TaskMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *TaskMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[task.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *TaskMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[task.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TaskMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, task.FieldTenantID)
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TaskMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[task.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TaskMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[task.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, task.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TaskMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TaskMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TaskMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[task.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TaskMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[task.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TaskMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, task.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TaskMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TaskMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TaskMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[task.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TaskMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, task.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TaskMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TaskMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TaskMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[task.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TaskMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, task.FieldUpdatedAt)
}

// SetTaskKey sets the "task_key" field.
func (m *TaskMutation) SetTaskKey(s string) {
	m.task_key = &s
}

// TaskKey returns the value of the "task_key" field in the mutation.
func (m *TaskMutation) TaskKey() (r string, exists bool) {
	v := m.task_key
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskKey returns the old "task_key" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTaskKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskKey: %w", err)
	}
	return oldValue.TaskKey, nil
}

// ResetTaskKey resets all changes to the "task_key" field.
func (m *TaskMutation) ResetTaskKey() {
	m.task_key = nil
}

// SetParentID sets the "parent_id" field.
func (m *TaskMutation) SetParentID(s string) {
	m.parent_id = &s
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *TaskMutation) ParentID() (r string, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldParentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *TaskMutation) ClearParentID() {
	m.parent_id = nil
	m.clearedFields[task.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *TaskMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[task.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *TaskMutation) ResetParentID() {
	m.parent_id = nil
	delete(m.clearedFields, task.FieldParentID)
}

// SetChildIds sets the "child_ids" field.
func (m *TaskMutation) SetChildIds(s []string) {
	m.child_ids = &s
	m.appendchild_ids = nil
}

// ChildIds returns the value of the "child_ids" field in the mutation.
func (m *TaskMutation) ChildIds() (r []string, exists bool) {
	v := m.child_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldChildIds returns the old "child_ids" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldChildIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildIds: %w", err)
	}
	return oldValue.ChildIds, nil
}

// AppendChildIds adds s to the "child_ids" field.
func (m *TaskMutation) AppendChildIds(s []string) {
	m.appendchild_ids = append(m.appendchild_ids, s...)
}

// AppendedChildIds returns the list of values that were appended to the "child_ids" field in this mutation.
func (m *TaskMutation) AppendedChildIds() ([]string, bool) {
	if len(m.appendchild_ids) == 0 {
		return nil, false
	}
	return m.appendchild_ids, true
}

// ResetChildIds resets all changes to the "child_ids" field.
func (m *TaskMutation) ResetChildIds() {
	m.child_ids = nil
	m.appendchild_ids = nil
}

// SetAction sets the "action" field.
func (m *TaskMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *TaskMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ClearAction clears the value of the "action" field.
func (m *TaskMutation) ClearAction() {
	m.action = nil
	m.clearedFields[task.FieldAction] = struct{}{}
}

// ActionCleared returns if the "action" field was cleared in this mutation.
func (m *TaskMutation) ActionCleared() bool {
	_, ok := m.clearedFields[task.FieldAction]
	return ok
}

// ResetAction resets all changes to the "action" field.
func (m *TaskMutation) ResetAction() {
	m.action = nil
	delete(m.clearedFields, task.FieldAction)
}

// SetComment sets the "comment" field.
func (m *TaskMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *TaskMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *TaskMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[task.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *TaskMutation) CommentCleared() bool {
	_, ok := m.clearedFields[task.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *TaskMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, task.FieldComment)
}

// SetAttachments sets the "attachments" field.
func (m *TaskMutation) SetAttachments(value map[string]interface{}) {
	m.attachments = &value
}

// Attachments returns the value of the "attachments" field in the mutation.
func (m *TaskMutation) Attachments() (r map[string]interface{}, exists bool) {
	v := m.attachments
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachments returns the old "attachments" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAttachments(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachments: %w", err)
	}
	return oldValue.Attachments, nil
}

// ClearAttachments clears the value of the "attachments" field.
func (m *TaskMutation) ClearAttachments() {
	m.attachments = nil
	m.clearedFields[task.FieldAttachments] = struct{}{}
}

// AttachmentsCleared returns if the "attachments" field was cleared in this mutation.
func (m *TaskMutation) AttachmentsCleared() bool {
	_, ok := m.clearedFields[task.FieldAttachments]
	return ok
}

// ResetAttachments resets all changes to the "attachments" field.
func (m *TaskMutation) ResetAttachments() {
	m.attachments = nil
	delete(m.clearedFields, task.FieldAttachments)
}

// SetFormData sets the "form_data" field.
func (m *TaskMutation) SetFormData(value map[string]interface{}) {
	m.form_data = &value
}

// FormData returns the value of the "form_data" field in the mutation.
func (m *TaskMutation) FormData() (r map[string]interface{}, exists bool) {
	v := m.form_data
	if v == nil {
		return
	}
	return *v, true
}

// OldFormData returns the old "form_data" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldFormData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormData: %w", err)
	}
	return oldValue.FormData, nil
}

// ClearFormData clears the value of the "form_data" field.
func (m *TaskMutation) ClearFormData() {
	m.form_data = nil
	m.clearedFields[task.FieldFormData] = struct{}{}
}

// FormDataCleared returns if the "form_data" field was cleared in this mutation.
func (m *TaskMutation) FormDataCleared() bool {
	_, ok := m.clearedFields[task.FieldFormData]
	return ok
}

// ResetFormData resets all changes to the "form_data" field.
func (m *TaskMutation) ResetFormData() {
	m.form_data = nil
	delete(m.clearedFields, task.FieldFormData)
}

// SetVariables sets the "variables" field.
func (m *TaskMutation) SetVariables(value map[string]interface{}) {
	m.variables = &value
}

// Variables returns the value of the "variables" field in the mutation.
func (m *TaskMutation) Variables() (r map[string]interface{}, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old "variables" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldVariables(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ClearVariables clears the value of the "variables" field.
func (m *TaskMutation) ClearVariables() {
	m.variables = nil
	m.clearedFields[task.FieldVariables] = struct{}{}
}

// VariablesCleared returns if the "variables" field was cleared in this mutation.
func (m *TaskMutation) VariablesCleared() bool {
	_, ok := m.clearedFields[task.FieldVariables]
	return ok
}

// ResetVariables resets all changes to the "variables" field.
func (m *TaskMutation) ResetVariables() {
	m.variables = nil
	delete(m.clearedFields, task.FieldVariables)
}

// SetIsResubmit sets the "is_resubmit" field.
func (m *TaskMutation) SetIsResubmit(b bool) {
	m.is_resubmit = &b
}

// IsResubmit returns the value of the "is_resubmit" field in the mutation.
func (m *TaskMutation) IsResubmit() (r bool, exists bool) {
	v := m.is_resubmit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsResubmit returns the old "is_resubmit" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsResubmit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsResubmit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsResubmit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsResubmit: %w", err)
	}
	return oldValue.IsResubmit, nil
}

// ResetIsResubmit resets all changes to the "is_resubmit" field.
func (m *TaskMutation) ResetIsResubmit() {
	m.is_resubmit = nil
}

// SetClaimTime sets the "claim_time" field.
func (m *TaskMutation) SetClaimTime(i int64) {
	m.claim_time = &i
	m.addclaim_time = nil
}

// ClaimTime returns the value of the "claim_time" field in the mutation.
func (m *TaskMutation) ClaimTime() (r int64, exists bool) {
	v := m.claim_time
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimTime returns the old "claim_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldClaimTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimTime: %w", err)
	}
	return oldValue.ClaimTime, nil
}

// AddClaimTime adds i to the "claim_time" field.
func (m *TaskMutation) AddClaimTime(i int64) {
	if m.addclaim_time != nil {
		*m.addclaim_time += i
	} else {
		m.addclaim_time = &i
	}
}

// AddedClaimTime returns the value that was added to the "claim_time" field in this mutation.
func (m *TaskMutation) AddedClaimTime() (r int64, exists bool) {
	v := m.addclaim_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearClaimTime clears the value of the "claim_time" field.
func (m *TaskMutation) ClearClaimTime() {
	m.claim_time = nil
	m.addclaim_time = nil
	m.clearedFields[task.FieldClaimTime] = struct{}{}
}

// ClaimTimeCleared returns if the "claim_time" field was cleared in this mutation.
func (m *TaskMutation) ClaimTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldClaimTime]
	return ok
}

// ResetClaimTime resets all changes to the "claim_time" field.
func (m *TaskMutation) ResetClaimTime() {
	m.claim_time = nil
	m.addclaim_time = nil
	delete(m.clearedFields, task.FieldClaimTime)
}

// SetIsUrged sets the "is_urged" field.
func (m *TaskMutation) SetIsUrged(b bool) {
	m.is_urged = &b
}

// IsUrged returns the value of the "is_urged" field in the mutation.
func (m *TaskMutation) IsUrged() (r bool, exists bool) {
	v := m.is_urged
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUrged returns the old "is_urged" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsUrged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUrged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUrged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUrged: %w", err)
	}
	return oldValue.IsUrged, nil
}

// ResetIsUrged resets all changes to the "is_urged" field.
func (m *TaskMutation) ResetIsUrged() {
	m.is_urged = nil
}

// SetUrgeCount sets the "urge_count" field.
func (m *TaskMutation) SetUrgeCount(i int) {
	m.urge_count = &i
	m.addurge_count = nil
}

// UrgeCount returns the value of the "urge_count" field in the mutation.
func (m *TaskMutation) UrgeCount() (r int, exists bool) {
	v := m.urge_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUrgeCount returns the old "urge_count" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUrgeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUrgeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUrgeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrgeCount: %w", err)
	}
	return oldValue.UrgeCount, nil
}

// AddUrgeCount adds i to the "urge_count" field.
func (m *TaskMutation) AddUrgeCount(i int) {
	if m.addurge_count != nil {
		*m.addurge_count += i
	} else {
		m.addurge_count = &i
	}
}

// AddedUrgeCount returns the value that was added to the "urge_count" field in this mutation.
func (m *TaskMutation) AddedUrgeCount() (r int, exists bool) {
	v := m.addurge_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUrgeCount resets all changes to the "urge_count" field.
func (m *TaskMutation) ResetUrgeCount() {
	m.urge_count = nil
	m.addurge_count = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 49)
	if m.name != nil {
		fields = append(fields, task.FieldName)
	}
	if m.description != nil {
		fields = append(fields, task.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.process_id != nil {
		fields = append(fields, task.FieldProcessID)
	}
	if m.template_id != nil {
		fields = append(fields, task.FieldTemplateID)
	}
	if m.business_key != nil {
		fields = append(fields, task.FieldBusinessKey)
	}
	if m.node_key != nil {
		fields = append(fields, task.FieldNodeKey)
	}
	if m.node_type != nil {
		fields = append(fields, task.FieldNodeType)
	}
	if m.node_config != nil {
		fields = append(fields, task.FieldNodeConfig)
	}
	if m.node_rules != nil {
		fields = append(fields, task.FieldNodeRules)
	}
	if m.node_events != nil {
		fields = append(fields, task.FieldNodeEvents)
	}
	if m.assignees != nil {
		fields = append(fields, task.FieldAssignees)
	}
	if m.candidates != nil {
		fields = append(fields, task.FieldCandidates)
	}
	if m.delegated_from != nil {
		fields = append(fields, task.FieldDelegatedFrom)
	}
	if m.delegated_reason != nil {
		fields = append(fields, task.FieldDelegatedReason)
	}
	if m.is_delegated != nil {
		fields = append(fields, task.FieldIsDelegated)
	}
	if m.is_transferred != nil {
		fields = append(fields, task.FieldIsTransferred)
	}
	if m.start_time != nil {
		fields = append(fields, task.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, task.FieldEndTime)
	}
	if m.due_time != nil {
		fields = append(fields, task.FieldDueTime)
	}
	if m.duration != nil {
		fields = append(fields, task.FieldDuration)
	}
	if m.priority != nil {
		fields = append(fields, task.FieldPriority)
	}
	if m.is_timeout != nil {
		fields = append(fields, task.FieldIsTimeout)
	}
	if m.reminder_count != nil {
		fields = append(fields, task.FieldReminderCount)
	}
	if m.allow_cancel != nil {
		fields = append(fields, task.FieldAllowCancel)
	}
	if m.allow_urge != nil {
		fields = append(fields, task.FieldAllowUrge)
	}
	if m.allow_delegate != nil {
		fields = append(fields, task.FieldAllowDelegate)
	}
	if m.allow_transfer != nil {
		fields = append(fields, task.FieldAllowTransfer)
	}
	if m.is_draft_enabled != nil {
		fields = append(fields, task.FieldIsDraftEnabled)
	}
	if m.is_auto_start != nil {
		fields = append(fields, task.FieldIsAutoStart)
	}
	if m.strict_mode != nil {
		fields = append(fields, task.FieldStrictMode)
	}
	if m.extras != nil {
		fields = append(fields, task.FieldExtras)
	}
	if m.tenant_id != nil {
		fields = append(fields, task.FieldTenantID)
	}
	if m.created_by != nil {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.task_key != nil {
		fields = append(fields, task.FieldTaskKey)
	}
	if m.parent_id != nil {
		fields = append(fields, task.FieldParentID)
	}
	if m.child_ids != nil {
		fields = append(fields, task.FieldChildIds)
	}
	if m.action != nil {
		fields = append(fields, task.FieldAction)
	}
	if m.comment != nil {
		fields = append(fields, task.FieldComment)
	}
	if m.attachments != nil {
		fields = append(fields, task.FieldAttachments)
	}
	if m.form_data != nil {
		fields = append(fields, task.FieldFormData)
	}
	if m.variables != nil {
		fields = append(fields, task.FieldVariables)
	}
	if m.is_resubmit != nil {
		fields = append(fields, task.FieldIsResubmit)
	}
	if m.claim_time != nil {
		fields = append(fields, task.FieldClaimTime)
	}
	if m.is_urged != nil {
		fields = append(fields, task.FieldIsUrged)
	}
	if m.urge_count != nil {
		fields = append(fields, task.FieldUrgeCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldName:
		return m.Name()
	case task.FieldDescription:
		return m.Description()
	case task.FieldStatus:
		return m.Status()
	case task.FieldProcessID:
		return m.ProcessID()
	case task.FieldTemplateID:
		return m.TemplateID()
	case task.FieldBusinessKey:
		return m.BusinessKey()
	case task.FieldNodeKey:
		return m.NodeKey()
	case task.FieldNodeType:
		return m.NodeType()
	case task.FieldNodeConfig:
		return m.NodeConfig()
	case task.FieldNodeRules:
		return m.NodeRules()
	case task.FieldNodeEvents:
		return m.NodeEvents()
	case task.FieldAssignees:
		return m.Assignees()
	case task.FieldCandidates:
		return m.Candidates()
	case task.FieldDelegatedFrom:
		return m.DelegatedFrom()
	case task.FieldDelegatedReason:
		return m.DelegatedReason()
	case task.FieldIsDelegated:
		return m.IsDelegated()
	case task.FieldIsTransferred:
		return m.IsTransferred()
	case task.FieldStartTime:
		return m.StartTime()
	case task.FieldEndTime:
		return m.EndTime()
	case task.FieldDueTime:
		return m.DueTime()
	case task.FieldDuration:
		return m.Duration()
	case task.FieldPriority:
		return m.Priority()
	case task.FieldIsTimeout:
		return m.IsTimeout()
	case task.FieldReminderCount:
		return m.ReminderCount()
	case task.FieldAllowCancel:
		return m.AllowCancel()
	case task.FieldAllowUrge:
		return m.AllowUrge()
	case task.FieldAllowDelegate:
		return m.AllowDelegate()
	case task.FieldAllowTransfer:
		return m.AllowTransfer()
	case task.FieldIsDraftEnabled:
		return m.IsDraftEnabled()
	case task.FieldIsAutoStart:
		return m.IsAutoStart()
	case task.FieldStrictMode:
		return m.StrictMode()
	case task.FieldExtras:
		return m.Extras()
	case task.FieldTenantID:
		return m.TenantID()
	case task.FieldCreatedBy:
		return m.CreatedBy()
	case task.FieldUpdatedBy:
		return m.UpdatedBy()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldTaskKey:
		return m.TaskKey()
	case task.FieldParentID:
		return m.ParentID()
	case task.FieldChildIds:
		return m.ChildIds()
	case task.FieldAction:
		return m.Action()
	case task.FieldComment:
		return m.Comment()
	case task.FieldAttachments:
		return m.Attachments()
	case task.FieldFormData:
		return m.FormData()
	case task.FieldVariables:
		return m.Variables()
	case task.FieldIsResubmit:
		return m.IsResubmit()
	case task.FieldClaimTime:
		return m.ClaimTime()
	case task.FieldIsUrged:
		return m.IsUrged()
	case task.FieldUrgeCount:
		return m.UrgeCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldName:
		return m.OldName(ctx)
	case task.FieldDescription:
		return m.OldDescription(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldProcessID:
		return m.OldProcessID(ctx)
	case task.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case task.FieldBusinessKey:
		return m.OldBusinessKey(ctx)
	case task.FieldNodeKey:
		return m.OldNodeKey(ctx)
	case task.FieldNodeType:
		return m.OldNodeType(ctx)
	case task.FieldNodeConfig:
		return m.OldNodeConfig(ctx)
	case task.FieldNodeRules:
		return m.OldNodeRules(ctx)
	case task.FieldNodeEvents:
		return m.OldNodeEvents(ctx)
	case task.FieldAssignees:
		return m.OldAssignees(ctx)
	case task.FieldCandidates:
		return m.OldCandidates(ctx)
	case task.FieldDelegatedFrom:
		return m.OldDelegatedFrom(ctx)
	case task.FieldDelegatedReason:
		return m.OldDelegatedReason(ctx)
	case task.FieldIsDelegated:
		return m.OldIsDelegated(ctx)
	case task.FieldIsTransferred:
		return m.OldIsTransferred(ctx)
	case task.FieldStartTime:
		return m.OldStartTime(ctx)
	case task.FieldEndTime:
		return m.OldEndTime(ctx)
	case task.FieldDueTime:
		return m.OldDueTime(ctx)
	case task.FieldDuration:
		return m.OldDuration(ctx)
	case task.FieldPriority:
		return m.OldPriority(ctx)
	case task.FieldIsTimeout:
		return m.OldIsTimeout(ctx)
	case task.FieldReminderCount:
		return m.OldReminderCount(ctx)
	case task.FieldAllowCancel:
		return m.OldAllowCancel(ctx)
	case task.FieldAllowUrge:
		return m.OldAllowUrge(ctx)
	case task.FieldAllowDelegate:
		return m.OldAllowDelegate(ctx)
	case task.FieldAllowTransfer:
		return m.OldAllowTransfer(ctx)
	case task.FieldIsDraftEnabled:
		return m.OldIsDraftEnabled(ctx)
	case task.FieldIsAutoStart:
		return m.OldIsAutoStart(ctx)
	case task.FieldStrictMode:
		return m.OldStrictMode(ctx)
	case task.FieldExtras:
		return m.OldExtras(ctx)
	case task.FieldTenantID:
		return m.OldTenantID(ctx)
	case task.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case task.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldTaskKey:
		return m.OldTaskKey(ctx)
	case task.FieldParentID:
		return m.OldParentID(ctx)
	case task.FieldChildIds:
		return m.OldChildIds(ctx)
	case task.FieldAction:
		return m.OldAction(ctx)
	case task.FieldComment:
		return m.OldComment(ctx)
	case task.FieldAttachments:
		return m.OldAttachments(ctx)
	case task.FieldFormData:
		return m.OldFormData(ctx)
	case task.FieldVariables:
		return m.OldVariables(ctx)
	case task.FieldIsResubmit:
		return m.OldIsResubmit(ctx)
	case task.FieldClaimTime:
		return m.OldClaimTime(ctx)
	case task.FieldIsUrged:
		return m.OldIsUrged(ctx)
	case task.FieldUrgeCount:
		return m.OldUrgeCount(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case task.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldProcessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessID(v)
		return nil
	case task.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case task.FieldBusinessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessKey(v)
		return nil
	case task.FieldNodeKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeKey(v)
		return nil
	case task.FieldNodeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeType(v)
		return nil
	case task.FieldNodeConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeConfig(v)
		return nil
	case task.FieldNodeRules:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeRules(v)
		return nil
	case task.FieldNodeEvents:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeEvents(v)
		return nil
	case task.FieldAssignees:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignees(v)
		return nil
	case task.FieldCandidates:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidates(v)
		return nil
	case task.FieldDelegatedFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegatedFrom(v)
		return nil
	case task.FieldDelegatedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegatedReason(v)
		return nil
	case task.FieldIsDelegated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDelegated(v)
		return nil
	case task.FieldIsTransferred:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTransferred(v)
		return nil
	case task.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case task.FieldEndTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case task.FieldDueTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueTime(v)
		return nil
	case task.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case task.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case task.FieldIsTimeout:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTimeout(v)
		return nil
	case task.FieldReminderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReminderCount(v)
		return nil
	case task.FieldAllowCancel:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowCancel(v)
		return nil
	case task.FieldAllowUrge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowUrge(v)
		return nil
	case task.FieldAllowDelegate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowDelegate(v)
		return nil
	case task.FieldAllowTransfer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowTransfer(v)
		return nil
	case task.FieldIsDraftEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDraftEnabled(v)
		return nil
	case task.FieldIsAutoStart:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutoStart(v)
		return nil
	case task.FieldStrictMode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrictMode(v)
		return nil
	case task.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case task.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case task.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case task.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldTaskKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskKey(v)
		return nil
	case task.FieldParentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case task.FieldChildIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildIds(v)
		return nil
	case task.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case task.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case task.FieldAttachments:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachments(v)
		return nil
	case task.FieldFormData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormData(v)
		return nil
	case task.FieldVariables:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case task.FieldIsResubmit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsResubmit(v)
		return nil
	case task.FieldClaimTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimTime(v)
		return nil
	case task.FieldIsUrged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUrged(v)
		return nil
	case task.FieldUrgeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrgeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addstart_time != nil {
		fields = append(fields, task.FieldStartTime)
	}
	if m.addend_time != nil {
		fields = append(fields, task.FieldEndTime)
	}
	if m.adddue_time != nil {
		fields = append(fields, task.FieldDueTime)
	}
	if m.addduration != nil {
		fields = append(fields, task.FieldDuration)
	}
	if m.addpriority != nil {
		fields = append(fields, task.FieldPriority)
	}
	if m.addreminder_count != nil {
		fields = append(fields, task.FieldReminderCount)
	}
	if m.addcreated_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.addclaim_time != nil {
		fields = append(fields, task.FieldClaimTime)
	}
	if m.addurge_count != nil {
		fields = append(fields, task.FieldUrgeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldStartTime:
		return m.AddedStartTime()
	case task.FieldEndTime:
		return m.AddedEndTime()
	case task.FieldDueTime:
		return m.AddedDueTime()
	case task.FieldDuration:
		return m.AddedDuration()
	case task.FieldPriority:
		return m.AddedPriority()
	case task.FieldReminderCount:
		return m.AddedReminderCount()
	case task.FieldCreatedAt:
		return m.AddedCreatedAt()
	case task.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case task.FieldClaimTime:
		return m.AddedClaimTime()
	case task.FieldUrgeCount:
		return m.AddedUrgeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTime(v)
		return nil
	case task.FieldEndTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndTime(v)
		return nil
	case task.FieldDueTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDueTime(v)
		return nil
	case task.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case task.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case task.FieldReminderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReminderCount(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case task.FieldClaimTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClaimTime(v)
		return nil
	case task.FieldUrgeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUrgeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldName) {
		fields = append(fields, task.FieldName)
	}
	if m.FieldCleared(task.FieldDescription) {
		fields = append(fields, task.FieldDescription)
	}
	if m.FieldCleared(task.FieldStatus) {
		fields = append(fields, task.FieldStatus)
	}
	if m.FieldCleared(task.FieldNodeConfig) {
		fields = append(fields, task.FieldNodeConfig)
	}
	if m.FieldCleared(task.FieldNodeRules) {
		fields = append(fields, task.FieldNodeRules)
	}
	if m.FieldCleared(task.FieldNodeEvents) {
		fields = append(fields, task.FieldNodeEvents)
	}
	if m.FieldCleared(task.FieldDelegatedFrom) {
		fields = append(fields, task.FieldDelegatedFrom)
	}
	if m.FieldCleared(task.FieldDelegatedReason) {
		fields = append(fields, task.FieldDelegatedReason)
	}
	if m.FieldCleared(task.FieldEndTime) {
		fields = append(fields, task.FieldEndTime)
	}
	if m.FieldCleared(task.FieldDueTime) {
		fields = append(fields, task.FieldDueTime)
	}
	if m.FieldCleared(task.FieldDuration) {
		fields = append(fields, task.FieldDuration)
	}
	if m.FieldCleared(task.FieldExtras) {
		fields = append(fields, task.FieldExtras)
	}
	if m.FieldCleared(task.FieldTenantID) {
		fields = append(fields, task.FieldTenantID)
	}
	if m.FieldCleared(task.FieldCreatedBy) {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.FieldCleared(task.FieldUpdatedBy) {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.FieldCleared(task.FieldCreatedAt) {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.FieldCleared(task.FieldUpdatedAt) {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.FieldCleared(task.FieldParentID) {
		fields = append(fields, task.FieldParentID)
	}
	if m.FieldCleared(task.FieldAction) {
		fields = append(fields, task.FieldAction)
	}
	if m.FieldCleared(task.FieldComment) {
		fields = append(fields, task.FieldComment)
	}
	if m.FieldCleared(task.FieldAttachments) {
		fields = append(fields, task.FieldAttachments)
	}
	if m.FieldCleared(task.FieldFormData) {
		fields = append(fields, task.FieldFormData)
	}
	if m.FieldCleared(task.FieldVariables) {
		fields = append(fields, task.FieldVariables)
	}
	if m.FieldCleared(task.FieldClaimTime) {
		fields = append(fields, task.FieldClaimTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldName:
		m.ClearName()
		return nil
	case task.FieldDescription:
		m.ClearDescription()
		return nil
	case task.FieldStatus:
		m.ClearStatus()
		return nil
	case task.FieldNodeConfig:
		m.ClearNodeConfig()
		return nil
	case task.FieldNodeRules:
		m.ClearNodeRules()
		return nil
	case task.FieldNodeEvents:
		m.ClearNodeEvents()
		return nil
	case task.FieldDelegatedFrom:
		m.ClearDelegatedFrom()
		return nil
	case task.FieldDelegatedReason:
		m.ClearDelegatedReason()
		return nil
	case task.FieldEndTime:
		m.ClearEndTime()
		return nil
	case task.FieldDueTime:
		m.ClearDueTime()
		return nil
	case task.FieldDuration:
		m.ClearDuration()
		return nil
	case task.FieldExtras:
		m.ClearExtras()
		return nil
	case task.FieldTenantID:
		m.ClearTenantID()
		return nil
	case task.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case task.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case task.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case task.FieldParentID:
		m.ClearParentID()
		return nil
	case task.FieldAction:
		m.ClearAction()
		return nil
	case task.FieldComment:
		m.ClearComment()
		return nil
	case task.FieldAttachments:
		m.ClearAttachments()
		return nil
	case task.FieldFormData:
		m.ClearFormData()
		return nil
	case task.FieldVariables:
		m.ClearVariables()
		return nil
	case task.FieldClaimTime:
		m.ClearClaimTime()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldName:
		m.ResetName()
		return nil
	case task.FieldDescription:
		m.ResetDescription()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldProcessID:
		m.ResetProcessID()
		return nil
	case task.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case task.FieldBusinessKey:
		m.ResetBusinessKey()
		return nil
	case task.FieldNodeKey:
		m.ResetNodeKey()
		return nil
	case task.FieldNodeType:
		m.ResetNodeType()
		return nil
	case task.FieldNodeConfig:
		m.ResetNodeConfig()
		return nil
	case task.FieldNodeRules:
		m.ResetNodeRules()
		return nil
	case task.FieldNodeEvents:
		m.ResetNodeEvents()
		return nil
	case task.FieldAssignees:
		m.ResetAssignees()
		return nil
	case task.FieldCandidates:
		m.ResetCandidates()
		return nil
	case task.FieldDelegatedFrom:
		m.ResetDelegatedFrom()
		return nil
	case task.FieldDelegatedReason:
		m.ResetDelegatedReason()
		return nil
	case task.FieldIsDelegated:
		m.ResetIsDelegated()
		return nil
	case task.FieldIsTransferred:
		m.ResetIsTransferred()
		return nil
	case task.FieldStartTime:
		m.ResetStartTime()
		return nil
	case task.FieldEndTime:
		m.ResetEndTime()
		return nil
	case task.FieldDueTime:
		m.ResetDueTime()
		return nil
	case task.FieldDuration:
		m.ResetDuration()
		return nil
	case task.FieldPriority:
		m.ResetPriority()
		return nil
	case task.FieldIsTimeout:
		m.ResetIsTimeout()
		return nil
	case task.FieldReminderCount:
		m.ResetReminderCount()
		return nil
	case task.FieldAllowCancel:
		m.ResetAllowCancel()
		return nil
	case task.FieldAllowUrge:
		m.ResetAllowUrge()
		return nil
	case task.FieldAllowDelegate:
		m.ResetAllowDelegate()
		return nil
	case task.FieldAllowTransfer:
		m.ResetAllowTransfer()
		return nil
	case task.FieldIsDraftEnabled:
		m.ResetIsDraftEnabled()
		return nil
	case task.FieldIsAutoStart:
		m.ResetIsAutoStart()
		return nil
	case task.FieldStrictMode:
		m.ResetStrictMode()
		return nil
	case task.FieldExtras:
		m.ResetExtras()
		return nil
	case task.FieldTenantID:
		m.ResetTenantID()
		return nil
	case task.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case task.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldTaskKey:
		m.ResetTaskKey()
		return nil
	case task.FieldParentID:
		m.ResetParentID()
		return nil
	case task.FieldChildIds:
		m.ResetChildIds()
		return nil
	case task.FieldAction:
		m.ResetAction()
		return nil
	case task.FieldComment:
		m.ResetComment()
		return nil
	case task.FieldAttachments:
		m.ResetAttachments()
		return nil
	case task.FieldFormData:
		m.ResetFormData()
		return nil
	case task.FieldVariables:
		m.ResetVariables()
		return nil
	case task.FieldIsResubmit:
		m.ResetIsResubmit()
		return nil
	case task.FieldClaimTime:
		m.ResetClaimTime()
		return nil
	case task.FieldIsUrged:
		m.ResetIsUrged()
		return nil
	case task.FieldUrgeCount:
		m.ResetUrgeCount()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Task edge %s", name)
}

// TemplateMutation represents an operation that mutates the Template nodes in the graph.
type TemplateMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	code                *string
	description         *string
	_type               *string
	version             *string
	status              *string
	disabled            *bool
	form_code           *string
	form_version        *string
	form_config         *map[string]interface{}
	form_permissions    *map[string]interface{}
	field_permissions   *map[string]interface{}
	node_key            *string
	node_type           *string
	node_config         *map[string]interface{}
	node_rules          *map[string]interface{}
	node_events         *map[string]interface{}
	business_tags       *[]string
	appendbusiness_tags []string
	module_code         *string
	category            *string
	allow_cancel        *bool
	allow_urge          *bool
	allow_delegate      *bool
	allow_transfer      *bool
	is_draft_enabled    *bool
	is_auto_start       *bool
	strict_mode         *bool
	viewers             *[]string
	appendviewers       []string
	editors             *[]string
	appendeditors       []string
	permission_configs  *map[string]interface{}
	role_configs        *map[string]interface{}
	visible_range       *map[string]interface{}
	extras              *map[string]interface{}
	tenant_id           *string
	created_by          *string
	updated_by          *string
	created_at          *int64
	addcreated_at       *int64
	updated_at          *int64
	addupdated_at       *int64
	template_key        *string
	process_rules       *map[string]interface{}
	trigger_conditions  *map[string]interface{}
	timeout_config      *map[string]interface{}
	reminder_config     *map[string]interface{}
	source_version      *string
	is_latest           *bool
	effective_time      *int64
	addeffective_time   *int64
	expire_time         *int64
	addexpire_time      *int64
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Template, error)
	predicates          []predicate.Template
}

var _ ent.Mutation = (*TemplateMutation)(nil)

// templateOption allows management of the mutation configuration using functional options.
type templateOption func(*TemplateMutation)

// newTemplateMutation creates new mutation for the Template entity.
func newTemplateMutation(c config, op Op, opts ...templateOption) *TemplateMutation {
	m := &TemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateID sets the ID field of the mutation.
func withTemplateID(id string) templateOption {
	return func(m *TemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *Template
		)
		m.oldValue = func(ctx context.Context) (*Template, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Template.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplate sets the old Template of the mutation.
func withTemplate(node *Template) templateOption {
	return func(m *TemplateMutation) {
		m.oldValue = func(context.Context) (*Template, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Template entities.
func (m *TemplateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Template.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TemplateMutation) ClearName() {
	m.name = nil
	m.clearedFields[template.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TemplateMutation) NameCleared() bool {
	_, ok := m.clearedFields[template.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TemplateMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, template.FieldName)
}

// SetCode sets the "code" field.
func (m *TemplateMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TemplateMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *TemplateMutation) ClearCode() {
	m.code = nil
	m.clearedFields[template.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *TemplateMutation) CodeCleared() bool {
	_, ok := m.clearedFields[template.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *TemplateMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, template.FieldCode)
}

// SetDescription sets the "description" field.
func (m *TemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[template.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[template.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, template.FieldDescription)
}

// SetType sets the "type" field.
func (m *TemplateMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TemplateMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *TemplateMutation) ClearType() {
	m._type = nil
	m.clearedFields[template.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *TemplateMutation) TypeCleared() bool {
	_, ok := m.clearedFields[template.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *TemplateMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, template.FieldType)
}

// SetVersion sets the "version" field.
func (m *TemplateMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *TemplateMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *TemplateMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[template.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *TemplateMutation) VersionCleared() bool {
	_, ok := m.clearedFields[template.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *TemplateMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, template.FieldVersion)
}

// SetStatus sets the "status" field.
func (m *TemplateMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TemplateMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TemplateMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[template.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TemplateMutation) StatusCleared() bool {
	_, ok := m.clearedFields[template.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TemplateMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, template.FieldStatus)
}

// SetDisabled sets the "disabled" field.
func (m *TemplateMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *TemplateMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *TemplateMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[template.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *TemplateMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[template.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *TemplateMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, template.FieldDisabled)
}

// SetFormCode sets the "form_code" field.
func (m *TemplateMutation) SetFormCode(s string) {
	m.form_code = &s
}

// FormCode returns the value of the "form_code" field in the mutation.
func (m *TemplateMutation) FormCode() (r string, exists bool) {
	v := m.form_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFormCode returns the old "form_code" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldFormCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormCode: %w", err)
	}
	return oldValue.FormCode, nil
}

// ResetFormCode resets all changes to the "form_code" field.
func (m *TemplateMutation) ResetFormCode() {
	m.form_code = nil
}

// SetFormVersion sets the "form_version" field.
func (m *TemplateMutation) SetFormVersion(s string) {
	m.form_version = &s
}

// FormVersion returns the value of the "form_version" field in the mutation.
func (m *TemplateMutation) FormVersion() (r string, exists bool) {
	v := m.form_version
	if v == nil {
		return
	}
	return *v, true
}

// OldFormVersion returns the old "form_version" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldFormVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormVersion: %w", err)
	}
	return oldValue.FormVersion, nil
}

// ClearFormVersion clears the value of the "form_version" field.
func (m *TemplateMutation) ClearFormVersion() {
	m.form_version = nil
	m.clearedFields[template.FieldFormVersion] = struct{}{}
}

// FormVersionCleared returns if the "form_version" field was cleared in this mutation.
func (m *TemplateMutation) FormVersionCleared() bool {
	_, ok := m.clearedFields[template.FieldFormVersion]
	return ok
}

// ResetFormVersion resets all changes to the "form_version" field.
func (m *TemplateMutation) ResetFormVersion() {
	m.form_version = nil
	delete(m.clearedFields, template.FieldFormVersion)
}

// SetFormConfig sets the "form_config" field.
func (m *TemplateMutation) SetFormConfig(value map[string]interface{}) {
	m.form_config = &value
}

// FormConfig returns the value of the "form_config" field in the mutation.
func (m *TemplateMutation) FormConfig() (r map[string]interface{}, exists bool) {
	v := m.form_config
	if v == nil {
		return
	}
	return *v, true
}

// OldFormConfig returns the old "form_config" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldFormConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormConfig: %w", err)
	}
	return oldValue.FormConfig, nil
}

// ClearFormConfig clears the value of the "form_config" field.
func (m *TemplateMutation) ClearFormConfig() {
	m.form_config = nil
	m.clearedFields[template.FieldFormConfig] = struct{}{}
}

// FormConfigCleared returns if the "form_config" field was cleared in this mutation.
func (m *TemplateMutation) FormConfigCleared() bool {
	_, ok := m.clearedFields[template.FieldFormConfig]
	return ok
}

// ResetFormConfig resets all changes to the "form_config" field.
func (m *TemplateMutation) ResetFormConfig() {
	m.form_config = nil
	delete(m.clearedFields, template.FieldFormConfig)
}

// SetFormPermissions sets the "form_permissions" field.
func (m *TemplateMutation) SetFormPermissions(value map[string]interface{}) {
	m.form_permissions = &value
}

// FormPermissions returns the value of the "form_permissions" field in the mutation.
func (m *TemplateMutation) FormPermissions() (r map[string]interface{}, exists bool) {
	v := m.form_permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldFormPermissions returns the old "form_permissions" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldFormPermissions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormPermissions: %w", err)
	}
	return oldValue.FormPermissions, nil
}

// ClearFormPermissions clears the value of the "form_permissions" field.
func (m *TemplateMutation) ClearFormPermissions() {
	m.form_permissions = nil
	m.clearedFields[template.FieldFormPermissions] = struct{}{}
}

// FormPermissionsCleared returns if the "form_permissions" field was cleared in this mutation.
func (m *TemplateMutation) FormPermissionsCleared() bool {
	_, ok := m.clearedFields[template.FieldFormPermissions]
	return ok
}

// ResetFormPermissions resets all changes to the "form_permissions" field.
func (m *TemplateMutation) ResetFormPermissions() {
	m.form_permissions = nil
	delete(m.clearedFields, template.FieldFormPermissions)
}

// SetFieldPermissions sets the "field_permissions" field.
func (m *TemplateMutation) SetFieldPermissions(value map[string]interface{}) {
	m.field_permissions = &value
}

// FieldPermissions returns the value of the "field_permissions" field in the mutation.
func (m *TemplateMutation) FieldPermissions() (r map[string]interface{}, exists bool) {
	v := m.field_permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldPermissions returns the old "field_permissions" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldFieldPermissions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldPermissions: %w", err)
	}
	return oldValue.FieldPermissions, nil
}

// ClearFieldPermissions clears the value of the "field_permissions" field.
func (m *TemplateMutation) ClearFieldPermissions() {
	m.field_permissions = nil
	m.clearedFields[template.FieldFieldPermissions] = struct{}{}
}

// FieldPermissionsCleared returns if the "field_permissions" field was cleared in this mutation.
func (m *TemplateMutation) FieldPermissionsCleared() bool {
	_, ok := m.clearedFields[template.FieldFieldPermissions]
	return ok
}

// ResetFieldPermissions resets all changes to the "field_permissions" field.
func (m *TemplateMutation) ResetFieldPermissions() {
	m.field_permissions = nil
	delete(m.clearedFields, template.FieldFieldPermissions)
}

// SetNodeKey sets the "node_key" field.
func (m *TemplateMutation) SetNodeKey(s string) {
	m.node_key = &s
}

// NodeKey returns the value of the "node_key" field in the mutation.
func (m *TemplateMutation) NodeKey() (r string, exists bool) {
	v := m.node_key
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeKey returns the old "node_key" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldNodeKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeKey: %w", err)
	}
	return oldValue.NodeKey, nil
}

// ResetNodeKey resets all changes to the "node_key" field.
func (m *TemplateMutation) ResetNodeKey() {
	m.node_key = nil
}

// SetNodeType sets the "node_type" field.
func (m *TemplateMutation) SetNodeType(s string) {
	m.node_type = &s
}

// NodeType returns the value of the "node_type" field in the mutation.
func (m *TemplateMutation) NodeType() (r string, exists bool) {
	v := m.node_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeType returns the old "node_type" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldNodeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeType: %w", err)
	}
	return oldValue.NodeType, nil
}

// ResetNodeType resets all changes to the "node_type" field.
func (m *TemplateMutation) ResetNodeType() {
	m.node_type = nil
}

// SetNodeConfig sets the "node_config" field.
func (m *TemplateMutation) SetNodeConfig(value map[string]interface{}) {
	m.node_config = &value
}

// NodeConfig returns the value of the "node_config" field in the mutation.
func (m *TemplateMutation) NodeConfig() (r map[string]interface{}, exists bool) {
	v := m.node_config
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeConfig returns the old "node_config" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldNodeConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeConfig: %w", err)
	}
	return oldValue.NodeConfig, nil
}

// ClearNodeConfig clears the value of the "node_config" field.
func (m *TemplateMutation) ClearNodeConfig() {
	m.node_config = nil
	m.clearedFields[template.FieldNodeConfig] = struct{}{}
}

// NodeConfigCleared returns if the "node_config" field was cleared in this mutation.
func (m *TemplateMutation) NodeConfigCleared() bool {
	_, ok := m.clearedFields[template.FieldNodeConfig]
	return ok
}

// ResetNodeConfig resets all changes to the "node_config" field.
func (m *TemplateMutation) ResetNodeConfig() {
	m.node_config = nil
	delete(m.clearedFields, template.FieldNodeConfig)
}

// SetNodeRules sets the "node_rules" field.
func (m *TemplateMutation) SetNodeRules(value map[string]interface{}) {
	m.node_rules = &value
}

// NodeRules returns the value of the "node_rules" field in the mutation.
func (m *TemplateMutation) NodeRules() (r map[string]interface{}, exists bool) {
	v := m.node_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeRules returns the old "node_rules" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldNodeRules(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeRules: %w", err)
	}
	return oldValue.NodeRules, nil
}

// ClearNodeRules clears the value of the "node_rules" field.
func (m *TemplateMutation) ClearNodeRules() {
	m.node_rules = nil
	m.clearedFields[template.FieldNodeRules] = struct{}{}
}

// NodeRulesCleared returns if the "node_rules" field was cleared in this mutation.
func (m *TemplateMutation) NodeRulesCleared() bool {
	_, ok := m.clearedFields[template.FieldNodeRules]
	return ok
}

// ResetNodeRules resets all changes to the "node_rules" field.
func (m *TemplateMutation) ResetNodeRules() {
	m.node_rules = nil
	delete(m.clearedFields, template.FieldNodeRules)
}

// SetNodeEvents sets the "node_events" field.
func (m *TemplateMutation) SetNodeEvents(value map[string]interface{}) {
	m.node_events = &value
}

// NodeEvents returns the value of the "node_events" field in the mutation.
func (m *TemplateMutation) NodeEvents() (r map[string]interface{}, exists bool) {
	v := m.node_events
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeEvents returns the old "node_events" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldNodeEvents(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeEvents: %w", err)
	}
	return oldValue.NodeEvents, nil
}

// ClearNodeEvents clears the value of the "node_events" field.
func (m *TemplateMutation) ClearNodeEvents() {
	m.node_events = nil
	m.clearedFields[template.FieldNodeEvents] = struct{}{}
}

// NodeEventsCleared returns if the "node_events" field was cleared in this mutation.
func (m *TemplateMutation) NodeEventsCleared() bool {
	_, ok := m.clearedFields[template.FieldNodeEvents]
	return ok
}

// ResetNodeEvents resets all changes to the "node_events" field.
func (m *TemplateMutation) ResetNodeEvents() {
	m.node_events = nil
	delete(m.clearedFields, template.FieldNodeEvents)
}

// SetBusinessTags sets the "business_tags" field.
func (m *TemplateMutation) SetBusinessTags(s []string) {
	m.business_tags = &s
	m.appendbusiness_tags = nil
}

// BusinessTags returns the value of the "business_tags" field in the mutation.
func (m *TemplateMutation) BusinessTags() (r []string, exists bool) {
	v := m.business_tags
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessTags returns the old "business_tags" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldBusinessTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessTags: %w", err)
	}
	return oldValue.BusinessTags, nil
}

// AppendBusinessTags adds s to the "business_tags" field.
func (m *TemplateMutation) AppendBusinessTags(s []string) {
	m.appendbusiness_tags = append(m.appendbusiness_tags, s...)
}

// AppendedBusinessTags returns the list of values that were appended to the "business_tags" field in this mutation.
func (m *TemplateMutation) AppendedBusinessTags() ([]string, bool) {
	if len(m.appendbusiness_tags) == 0 {
		return nil, false
	}
	return m.appendbusiness_tags, true
}

// ClearBusinessTags clears the value of the "business_tags" field.
func (m *TemplateMutation) ClearBusinessTags() {
	m.business_tags = nil
	m.appendbusiness_tags = nil
	m.clearedFields[template.FieldBusinessTags] = struct{}{}
}

// BusinessTagsCleared returns if the "business_tags" field was cleared in this mutation.
func (m *TemplateMutation) BusinessTagsCleared() bool {
	_, ok := m.clearedFields[template.FieldBusinessTags]
	return ok
}

// ResetBusinessTags resets all changes to the "business_tags" field.
func (m *TemplateMutation) ResetBusinessTags() {
	m.business_tags = nil
	m.appendbusiness_tags = nil
	delete(m.clearedFields, template.FieldBusinessTags)
}

// SetModuleCode sets the "module_code" field.
func (m *TemplateMutation) SetModuleCode(s string) {
	m.module_code = &s
}

// ModuleCode returns the value of the "module_code" field in the mutation.
func (m *TemplateMutation) ModuleCode() (r string, exists bool) {
	v := m.module_code
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleCode returns the old "module_code" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldModuleCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleCode: %w", err)
	}
	return oldValue.ModuleCode, nil
}

// ResetModuleCode resets all changes to the "module_code" field.
func (m *TemplateMutation) ResetModuleCode() {
	m.module_code = nil
}

// SetCategory sets the "category" field.
func (m *TemplateMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *TemplateMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *TemplateMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[template.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *TemplateMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[template.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *TemplateMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, template.FieldCategory)
}

// SetAllowCancel sets the "allow_cancel" field.
func (m *TemplateMutation) SetAllowCancel(b bool) {
	m.allow_cancel = &b
}

// AllowCancel returns the value of the "allow_cancel" field in the mutation.
func (m *TemplateMutation) AllowCancel() (r bool, exists bool) {
	v := m.allow_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowCancel returns the old "allow_cancel" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldAllowCancel(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowCancel: %w", err)
	}
	return oldValue.AllowCancel, nil
}

// ResetAllowCancel resets all changes to the "allow_cancel" field.
func (m *TemplateMutation) ResetAllowCancel() {
	m.allow_cancel = nil
}

// SetAllowUrge sets the "allow_urge" field.
func (m *TemplateMutation) SetAllowUrge(b bool) {
	m.allow_urge = &b
}

// AllowUrge returns the value of the "allow_urge" field in the mutation.
func (m *TemplateMutation) AllowUrge() (r bool, exists bool) {
	v := m.allow_urge
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowUrge returns the old "allow_urge" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldAllowUrge(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowUrge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowUrge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowUrge: %w", err)
	}
	return oldValue.AllowUrge, nil
}

// ResetAllowUrge resets all changes to the "allow_urge" field.
func (m *TemplateMutation) ResetAllowUrge() {
	m.allow_urge = nil
}

// SetAllowDelegate sets the "allow_delegate" field.
func (m *TemplateMutation) SetAllowDelegate(b bool) {
	m.allow_delegate = &b
}

// AllowDelegate returns the value of the "allow_delegate" field in the mutation.
func (m *TemplateMutation) AllowDelegate() (r bool, exists bool) {
	v := m.allow_delegate
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowDelegate returns the old "allow_delegate" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldAllowDelegate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowDelegate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowDelegate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowDelegate: %w", err)
	}
	return oldValue.AllowDelegate, nil
}

// ResetAllowDelegate resets all changes to the "allow_delegate" field.
func (m *TemplateMutation) ResetAllowDelegate() {
	m.allow_delegate = nil
}

// SetAllowTransfer sets the "allow_transfer" field.
func (m *TemplateMutation) SetAllowTransfer(b bool) {
	m.allow_transfer = &b
}

// AllowTransfer returns the value of the "allow_transfer" field in the mutation.
func (m *TemplateMutation) AllowTransfer() (r bool, exists bool) {
	v := m.allow_transfer
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowTransfer returns the old "allow_transfer" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldAllowTransfer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowTransfer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowTransfer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowTransfer: %w", err)
	}
	return oldValue.AllowTransfer, nil
}

// ResetAllowTransfer resets all changes to the "allow_transfer" field.
func (m *TemplateMutation) ResetAllowTransfer() {
	m.allow_transfer = nil
}

// SetIsDraftEnabled sets the "is_draft_enabled" field.
func (m *TemplateMutation) SetIsDraftEnabled(b bool) {
	m.is_draft_enabled = &b
}

// IsDraftEnabled returns the value of the "is_draft_enabled" field in the mutation.
func (m *TemplateMutation) IsDraftEnabled() (r bool, exists bool) {
	v := m.is_draft_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDraftEnabled returns the old "is_draft_enabled" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldIsDraftEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDraftEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDraftEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDraftEnabled: %w", err)
	}
	return oldValue.IsDraftEnabled, nil
}

// ResetIsDraftEnabled resets all changes to the "is_draft_enabled" field.
func (m *TemplateMutation) ResetIsDraftEnabled() {
	m.is_draft_enabled = nil
}

// SetIsAutoStart sets the "is_auto_start" field.
func (m *TemplateMutation) SetIsAutoStart(b bool) {
	m.is_auto_start = &b
}

// IsAutoStart returns the value of the "is_auto_start" field in the mutation.
func (m *TemplateMutation) IsAutoStart() (r bool, exists bool) {
	v := m.is_auto_start
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutoStart returns the old "is_auto_start" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldIsAutoStart(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAutoStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAutoStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutoStart: %w", err)
	}
	return oldValue.IsAutoStart, nil
}

// ResetIsAutoStart resets all changes to the "is_auto_start" field.
func (m *TemplateMutation) ResetIsAutoStart() {
	m.is_auto_start = nil
}

// SetStrictMode sets the "strict_mode" field.
func (m *TemplateMutation) SetStrictMode(b bool) {
	m.strict_mode = &b
}

// StrictMode returns the value of the "strict_mode" field in the mutation.
func (m *TemplateMutation) StrictMode() (r bool, exists bool) {
	v := m.strict_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldStrictMode returns the old "strict_mode" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldStrictMode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrictMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrictMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrictMode: %w", err)
	}
	return oldValue.StrictMode, nil
}

// ResetStrictMode resets all changes to the "strict_mode" field.
func (m *TemplateMutation) ResetStrictMode() {
	m.strict_mode = nil
}

// SetViewers sets the "viewers" field.
func (m *TemplateMutation) SetViewers(s []string) {
	m.viewers = &s
	m.appendviewers = nil
}

// Viewers returns the value of the "viewers" field in the mutation.
func (m *TemplateMutation) Viewers() (r []string, exists bool) {
	v := m.viewers
	if v == nil {
		return
	}
	return *v, true
}

// OldViewers returns the old "viewers" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldViewers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewers: %w", err)
	}
	return oldValue.Viewers, nil
}

// AppendViewers adds s to the "viewers" field.
func (m *TemplateMutation) AppendViewers(s []string) {
	m.appendviewers = append(m.appendviewers, s...)
}

// AppendedViewers returns the list of values that were appended to the "viewers" field in this mutation.
func (m *TemplateMutation) AppendedViewers() ([]string, bool) {
	if len(m.appendviewers) == 0 {
		return nil, false
	}
	return m.appendviewers, true
}

// ClearViewers clears the value of the "viewers" field.
func (m *TemplateMutation) ClearViewers() {
	m.viewers = nil
	m.appendviewers = nil
	m.clearedFields[template.FieldViewers] = struct{}{}
}

// ViewersCleared returns if the "viewers" field was cleared in this mutation.
func (m *TemplateMutation) ViewersCleared() bool {
	_, ok := m.clearedFields[template.FieldViewers]
	return ok
}

// ResetViewers resets all changes to the "viewers" field.
func (m *TemplateMutation) ResetViewers() {
	m.viewers = nil
	m.appendviewers = nil
	delete(m.clearedFields, template.FieldViewers)
}

// SetEditors sets the "editors" field.
func (m *TemplateMutation) SetEditors(s []string) {
	m.editors = &s
	m.appendeditors = nil
}

// Editors returns the value of the "editors" field in the mutation.
func (m *TemplateMutation) Editors() (r []string, exists bool) {
	v := m.editors
	if v == nil {
		return
	}
	return *v, true
}

// OldEditors returns the old "editors" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldEditors(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditors: %w", err)
	}
	return oldValue.Editors, nil
}

// AppendEditors adds s to the "editors" field.
func (m *TemplateMutation) AppendEditors(s []string) {
	m.appendeditors = append(m.appendeditors, s...)
}

// AppendedEditors returns the list of values that were appended to the "editors" field in this mutation.
func (m *TemplateMutation) AppendedEditors() ([]string, bool) {
	if len(m.appendeditors) == 0 {
		return nil, false
	}
	return m.appendeditors, true
}

// ClearEditors clears the value of the "editors" field.
func (m *TemplateMutation) ClearEditors() {
	m.editors = nil
	m.appendeditors = nil
	m.clearedFields[template.FieldEditors] = struct{}{}
}

// EditorsCleared returns if the "editors" field was cleared in this mutation.
func (m *TemplateMutation) EditorsCleared() bool {
	_, ok := m.clearedFields[template.FieldEditors]
	return ok
}

// ResetEditors resets all changes to the "editors" field.
func (m *TemplateMutation) ResetEditors() {
	m.editors = nil
	m.appendeditors = nil
	delete(m.clearedFields, template.FieldEditors)
}

// SetPermissionConfigs sets the "permission_configs" field.
func (m *TemplateMutation) SetPermissionConfigs(value map[string]interface{}) {
	m.permission_configs = &value
}

// PermissionConfigs returns the value of the "permission_configs" field in the mutation.
func (m *TemplateMutation) PermissionConfigs() (r map[string]interface{}, exists bool) {
	v := m.permission_configs
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionConfigs returns the old "permission_configs" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldPermissionConfigs(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionConfigs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionConfigs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionConfigs: %w", err)
	}
	return oldValue.PermissionConfigs, nil
}

// ClearPermissionConfigs clears the value of the "permission_configs" field.
func (m *TemplateMutation) ClearPermissionConfigs() {
	m.permission_configs = nil
	m.clearedFields[template.FieldPermissionConfigs] = struct{}{}
}

// PermissionConfigsCleared returns if the "permission_configs" field was cleared in this mutation.
func (m *TemplateMutation) PermissionConfigsCleared() bool {
	_, ok := m.clearedFields[template.FieldPermissionConfigs]
	return ok
}

// ResetPermissionConfigs resets all changes to the "permission_configs" field.
func (m *TemplateMutation) ResetPermissionConfigs() {
	m.permission_configs = nil
	delete(m.clearedFields, template.FieldPermissionConfigs)
}

// SetRoleConfigs sets the "role_configs" field.
func (m *TemplateMutation) SetRoleConfigs(value map[string]interface{}) {
	m.role_configs = &value
}

// RoleConfigs returns the value of the "role_configs" field in the mutation.
func (m *TemplateMutation) RoleConfigs() (r map[string]interface{}, exists bool) {
	v := m.role_configs
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleConfigs returns the old "role_configs" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldRoleConfigs(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleConfigs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleConfigs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleConfigs: %w", err)
	}
	return oldValue.RoleConfigs, nil
}

// ClearRoleConfigs clears the value of the "role_configs" field.
func (m *TemplateMutation) ClearRoleConfigs() {
	m.role_configs = nil
	m.clearedFields[template.FieldRoleConfigs] = struct{}{}
}

// RoleConfigsCleared returns if the "role_configs" field was cleared in this mutation.
func (m *TemplateMutation) RoleConfigsCleared() bool {
	_, ok := m.clearedFields[template.FieldRoleConfigs]
	return ok
}

// ResetRoleConfigs resets all changes to the "role_configs" field.
func (m *TemplateMutation) ResetRoleConfigs() {
	m.role_configs = nil
	delete(m.clearedFields, template.FieldRoleConfigs)
}

// SetVisibleRange sets the "visible_range" field.
func (m *TemplateMutation) SetVisibleRange(value map[string]interface{}) {
	m.visible_range = &value
}

// VisibleRange returns the value of the "visible_range" field in the mutation.
func (m *TemplateMutation) VisibleRange() (r map[string]interface{}, exists bool) {
	v := m.visible_range
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibleRange returns the old "visible_range" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldVisibleRange(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibleRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibleRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibleRange: %w", err)
	}
	return oldValue.VisibleRange, nil
}

// ClearVisibleRange clears the value of the "visible_range" field.
func (m *TemplateMutation) ClearVisibleRange() {
	m.visible_range = nil
	m.clearedFields[template.FieldVisibleRange] = struct{}{}
}

// VisibleRangeCleared returns if the "visible_range" field was cleared in this mutation.
func (m *TemplateMutation) VisibleRangeCleared() bool {
	_, ok := m.clearedFields[template.FieldVisibleRange]
	return ok
}

// ResetVisibleRange resets all changes to the "visible_range" field.
func (m *TemplateMutation) ResetVisibleRange() {
	m.visible_range = nil
	delete(m.clearedFields, template.FieldVisibleRange)
}

// SetExtras sets the "extras" field.
func (m *TemplateMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *TemplateMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *TemplateMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[template.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *TemplateMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[template.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *TemplateMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, template.FieldExtras)
}

// SetTenantID sets the "tenant_id" field.
func (m *TemplateMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TemplateMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *TemplateMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[template.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *TemplateMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[template.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TemplateMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, template.FieldTenantID)
}

// SetCreatedBy sets the "created_by" field.
func (m *TemplateMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TemplateMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TemplateMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[template.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TemplateMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[template.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TemplateMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, template.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TemplateMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TemplateMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TemplateMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[template.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TemplateMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[template.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TemplateMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, template.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *TemplateMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TemplateMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TemplateMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TemplateMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TemplateMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[template.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TemplateMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[template.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TemplateMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, template.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TemplateMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TemplateMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TemplateMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TemplateMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TemplateMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[template.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TemplateMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[template.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, template.FieldUpdatedAt)
}

// SetTemplateKey sets the "template_key" field.
func (m *TemplateMutation) SetTemplateKey(s string) {
	m.template_key = &s
}

// TemplateKey returns the value of the "template_key" field in the mutation.
func (m *TemplateMutation) TemplateKey() (r string, exists bool) {
	v := m.template_key
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateKey returns the old "template_key" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldTemplateKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateKey: %w", err)
	}
	return oldValue.TemplateKey, nil
}

// ResetTemplateKey resets all changes to the "template_key" field.
func (m *TemplateMutation) ResetTemplateKey() {
	m.template_key = nil
}

// SetProcessRules sets the "process_rules" field.
func (m *TemplateMutation) SetProcessRules(value map[string]interface{}) {
	m.process_rules = &value
}

// ProcessRules returns the value of the "process_rules" field in the mutation.
func (m *TemplateMutation) ProcessRules() (r map[string]interface{}, exists bool) {
	v := m.process_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessRules returns the old "process_rules" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldProcessRules(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessRules: %w", err)
	}
	return oldValue.ProcessRules, nil
}

// ClearProcessRules clears the value of the "process_rules" field.
func (m *TemplateMutation) ClearProcessRules() {
	m.process_rules = nil
	m.clearedFields[template.FieldProcessRules] = struct{}{}
}

// ProcessRulesCleared returns if the "process_rules" field was cleared in this mutation.
func (m *TemplateMutation) ProcessRulesCleared() bool {
	_, ok := m.clearedFields[template.FieldProcessRules]
	return ok
}

// ResetProcessRules resets all changes to the "process_rules" field.
func (m *TemplateMutation) ResetProcessRules() {
	m.process_rules = nil
	delete(m.clearedFields, template.FieldProcessRules)
}

// SetTriggerConditions sets the "trigger_conditions" field.
func (m *TemplateMutation) SetTriggerConditions(value map[string]interface{}) {
	m.trigger_conditions = &value
}

// TriggerConditions returns the value of the "trigger_conditions" field in the mutation.
func (m *TemplateMutation) TriggerConditions() (r map[string]interface{}, exists bool) {
	v := m.trigger_conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggerConditions returns the old "trigger_conditions" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldTriggerConditions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggerConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggerConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggerConditions: %w", err)
	}
	return oldValue.TriggerConditions, nil
}

// ClearTriggerConditions clears the value of the "trigger_conditions" field.
func (m *TemplateMutation) ClearTriggerConditions() {
	m.trigger_conditions = nil
	m.clearedFields[template.FieldTriggerConditions] = struct{}{}
}

// TriggerConditionsCleared returns if the "trigger_conditions" field was cleared in this mutation.
func (m *TemplateMutation) TriggerConditionsCleared() bool {
	_, ok := m.clearedFields[template.FieldTriggerConditions]
	return ok
}

// ResetTriggerConditions resets all changes to the "trigger_conditions" field.
func (m *TemplateMutation) ResetTriggerConditions() {
	m.trigger_conditions = nil
	delete(m.clearedFields, template.FieldTriggerConditions)
}

// SetTimeoutConfig sets the "timeout_config" field.
func (m *TemplateMutation) SetTimeoutConfig(value map[string]interface{}) {
	m.timeout_config = &value
}

// TimeoutConfig returns the value of the "timeout_config" field in the mutation.
func (m *TemplateMutation) TimeoutConfig() (r map[string]interface{}, exists bool) {
	v := m.timeout_config
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeoutConfig returns the old "timeout_config" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldTimeoutConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeoutConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeoutConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeoutConfig: %w", err)
	}
	return oldValue.TimeoutConfig, nil
}

// ClearTimeoutConfig clears the value of the "timeout_config" field.
func (m *TemplateMutation) ClearTimeoutConfig() {
	m.timeout_config = nil
	m.clearedFields[template.FieldTimeoutConfig] = struct{}{}
}

// TimeoutConfigCleared returns if the "timeout_config" field was cleared in this mutation.
func (m *TemplateMutation) TimeoutConfigCleared() bool {
	_, ok := m.clearedFields[template.FieldTimeoutConfig]
	return ok
}

// ResetTimeoutConfig resets all changes to the "timeout_config" field.
func (m *TemplateMutation) ResetTimeoutConfig() {
	m.timeout_config = nil
	delete(m.clearedFields, template.FieldTimeoutConfig)
}

// SetReminderConfig sets the "reminder_config" field.
func (m *TemplateMutation) SetReminderConfig(value map[string]interface{}) {
	m.reminder_config = &value
}

// ReminderConfig returns the value of the "reminder_config" field in the mutation.
func (m *TemplateMutation) ReminderConfig() (r map[string]interface{}, exists bool) {
	v := m.reminder_config
	if v == nil {
		return
	}
	return *v, true
}

// OldReminderConfig returns the old "reminder_config" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldReminderConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReminderConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReminderConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReminderConfig: %w", err)
	}
	return oldValue.ReminderConfig, nil
}

// ClearReminderConfig clears the value of the "reminder_config" field.
func (m *TemplateMutation) ClearReminderConfig() {
	m.reminder_config = nil
	m.clearedFields[template.FieldReminderConfig] = struct{}{}
}

// ReminderConfigCleared returns if the "reminder_config" field was cleared in this mutation.
func (m *TemplateMutation) ReminderConfigCleared() bool {
	_, ok := m.clearedFields[template.FieldReminderConfig]
	return ok
}

// ResetReminderConfig resets all changes to the "reminder_config" field.
func (m *TemplateMutation) ResetReminderConfig() {
	m.reminder_config = nil
	delete(m.clearedFields, template.FieldReminderConfig)
}

// SetSourceVersion sets the "source_version" field.
func (m *TemplateMutation) SetSourceVersion(s string) {
	m.source_version = &s
}

// SourceVersion returns the value of the "source_version" field in the mutation.
func (m *TemplateMutation) SourceVersion() (r string, exists bool) {
	v := m.source_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceVersion returns the old "source_version" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldSourceVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceVersion: %w", err)
	}
	return oldValue.SourceVersion, nil
}

// ClearSourceVersion clears the value of the "source_version" field.
func (m *TemplateMutation) ClearSourceVersion() {
	m.source_version = nil
	m.clearedFields[template.FieldSourceVersion] = struct{}{}
}

// SourceVersionCleared returns if the "source_version" field was cleared in this mutation.
func (m *TemplateMutation) SourceVersionCleared() bool {
	_, ok := m.clearedFields[template.FieldSourceVersion]
	return ok
}

// ResetSourceVersion resets all changes to the "source_version" field.
func (m *TemplateMutation) ResetSourceVersion() {
	m.source_version = nil
	delete(m.clearedFields, template.FieldSourceVersion)
}

// SetIsLatest sets the "is_latest" field.
func (m *TemplateMutation) SetIsLatest(b bool) {
	m.is_latest = &b
}

// IsLatest returns the value of the "is_latest" field in the mutation.
func (m *TemplateMutation) IsLatest() (r bool, exists bool) {
	v := m.is_latest
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLatest returns the old "is_latest" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldIsLatest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLatest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLatest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLatest: %w", err)
	}
	return oldValue.IsLatest, nil
}

// ResetIsLatest resets all changes to the "is_latest" field.
func (m *TemplateMutation) ResetIsLatest() {
	m.is_latest = nil
}

// SetEffectiveTime sets the "effective_time" field.
func (m *TemplateMutation) SetEffectiveTime(i int64) {
	m.effective_time = &i
	m.addeffective_time = nil
}

// EffectiveTime returns the value of the "effective_time" field in the mutation.
func (m *TemplateMutation) EffectiveTime() (r int64, exists bool) {
	v := m.effective_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveTime returns the old "effective_time" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldEffectiveTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveTime: %w", err)
	}
	return oldValue.EffectiveTime, nil
}

// AddEffectiveTime adds i to the "effective_time" field.
func (m *TemplateMutation) AddEffectiveTime(i int64) {
	if m.addeffective_time != nil {
		*m.addeffective_time += i
	} else {
		m.addeffective_time = &i
	}
}

// AddedEffectiveTime returns the value that was added to the "effective_time" field in this mutation.
func (m *TemplateMutation) AddedEffectiveTime() (r int64, exists bool) {
	v := m.addeffective_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearEffectiveTime clears the value of the "effective_time" field.
func (m *TemplateMutation) ClearEffectiveTime() {
	m.effective_time = nil
	m.addeffective_time = nil
	m.clearedFields[template.FieldEffectiveTime] = struct{}{}
}

// EffectiveTimeCleared returns if the "effective_time" field was cleared in this mutation.
func (m *TemplateMutation) EffectiveTimeCleared() bool {
	_, ok := m.clearedFields[template.FieldEffectiveTime]
	return ok
}

// ResetEffectiveTime resets all changes to the "effective_time" field.
func (m *TemplateMutation) ResetEffectiveTime() {
	m.effective_time = nil
	m.addeffective_time = nil
	delete(m.clearedFields, template.FieldEffectiveTime)
}

// SetExpireTime sets the "expire_time" field.
func (m *TemplateMutation) SetExpireTime(i int64) {
	m.expire_time = &i
	m.addexpire_time = nil
}

// ExpireTime returns the value of the "expire_time" field in the mutation.
func (m *TemplateMutation) ExpireTime() (r int64, exists bool) {
	v := m.expire_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireTime returns the old "expire_time" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldExpireTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireTime: %w", err)
	}
	return oldValue.ExpireTime, nil
}

// AddExpireTime adds i to the "expire_time" field.
func (m *TemplateMutation) AddExpireTime(i int64) {
	if m.addexpire_time != nil {
		*m.addexpire_time += i
	} else {
		m.addexpire_time = &i
	}
}

// AddedExpireTime returns the value that was added to the "expire_time" field in this mutation.
func (m *TemplateMutation) AddedExpireTime() (r int64, exists bool) {
	v := m.addexpire_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearExpireTime clears the value of the "expire_time" field.
func (m *TemplateMutation) ClearExpireTime() {
	m.expire_time = nil
	m.addexpire_time = nil
	m.clearedFields[template.FieldExpireTime] = struct{}{}
}

// ExpireTimeCleared returns if the "expire_time" field was cleared in this mutation.
func (m *TemplateMutation) ExpireTimeCleared() bool {
	_, ok := m.clearedFields[template.FieldExpireTime]
	return ok
}

// ResetExpireTime resets all changes to the "expire_time" field.
func (m *TemplateMutation) ResetExpireTime() {
	m.expire_time = nil
	m.addexpire_time = nil
	delete(m.clearedFields, template.FieldExpireTime)
}

// Where appends a list predicates to the TemplateMutation builder.
func (m *TemplateMutation) Where(ps ...predicate.Template) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Template, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Template).
func (m *TemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateMutation) Fields() []string {
	fields := make([]string, 0, 47)
	if m.name != nil {
		fields = append(fields, template.FieldName)
	}
	if m.code != nil {
		fields = append(fields, template.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, template.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, template.FieldType)
	}
	if m.version != nil {
		fields = append(fields, template.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, template.FieldStatus)
	}
	if m.disabled != nil {
		fields = append(fields, template.FieldDisabled)
	}
	if m.form_code != nil {
		fields = append(fields, template.FieldFormCode)
	}
	if m.form_version != nil {
		fields = append(fields, template.FieldFormVersion)
	}
	if m.form_config != nil {
		fields = append(fields, template.FieldFormConfig)
	}
	if m.form_permissions != nil {
		fields = append(fields, template.FieldFormPermissions)
	}
	if m.field_permissions != nil {
		fields = append(fields, template.FieldFieldPermissions)
	}
	if m.node_key != nil {
		fields = append(fields, template.FieldNodeKey)
	}
	if m.node_type != nil {
		fields = append(fields, template.FieldNodeType)
	}
	if m.node_config != nil {
		fields = append(fields, template.FieldNodeConfig)
	}
	if m.node_rules != nil {
		fields = append(fields, template.FieldNodeRules)
	}
	if m.node_events != nil {
		fields = append(fields, template.FieldNodeEvents)
	}
	if m.business_tags != nil {
		fields = append(fields, template.FieldBusinessTags)
	}
	if m.module_code != nil {
		fields = append(fields, template.FieldModuleCode)
	}
	if m.category != nil {
		fields = append(fields, template.FieldCategory)
	}
	if m.allow_cancel != nil {
		fields = append(fields, template.FieldAllowCancel)
	}
	if m.allow_urge != nil {
		fields = append(fields, template.FieldAllowUrge)
	}
	if m.allow_delegate != nil {
		fields = append(fields, template.FieldAllowDelegate)
	}
	if m.allow_transfer != nil {
		fields = append(fields, template.FieldAllowTransfer)
	}
	if m.is_draft_enabled != nil {
		fields = append(fields, template.FieldIsDraftEnabled)
	}
	if m.is_auto_start != nil {
		fields = append(fields, template.FieldIsAutoStart)
	}
	if m.strict_mode != nil {
		fields = append(fields, template.FieldStrictMode)
	}
	if m.viewers != nil {
		fields = append(fields, template.FieldViewers)
	}
	if m.editors != nil {
		fields = append(fields, template.FieldEditors)
	}
	if m.permission_configs != nil {
		fields = append(fields, template.FieldPermissionConfigs)
	}
	if m.role_configs != nil {
		fields = append(fields, template.FieldRoleConfigs)
	}
	if m.visible_range != nil {
		fields = append(fields, template.FieldVisibleRange)
	}
	if m.extras != nil {
		fields = append(fields, template.FieldExtras)
	}
	if m.tenant_id != nil {
		fields = append(fields, template.FieldTenantID)
	}
	if m.created_by != nil {
		fields = append(fields, template.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, template.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, template.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, template.FieldUpdatedAt)
	}
	if m.template_key != nil {
		fields = append(fields, template.FieldTemplateKey)
	}
	if m.process_rules != nil {
		fields = append(fields, template.FieldProcessRules)
	}
	if m.trigger_conditions != nil {
		fields = append(fields, template.FieldTriggerConditions)
	}
	if m.timeout_config != nil {
		fields = append(fields, template.FieldTimeoutConfig)
	}
	if m.reminder_config != nil {
		fields = append(fields, template.FieldReminderConfig)
	}
	if m.source_version != nil {
		fields = append(fields, template.FieldSourceVersion)
	}
	if m.is_latest != nil {
		fields = append(fields, template.FieldIsLatest)
	}
	if m.effective_time != nil {
		fields = append(fields, template.FieldEffectiveTime)
	}
	if m.expire_time != nil {
		fields = append(fields, template.FieldExpireTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case template.FieldName:
		return m.Name()
	case template.FieldCode:
		return m.Code()
	case template.FieldDescription:
		return m.Description()
	case template.FieldType:
		return m.GetType()
	case template.FieldVersion:
		return m.Version()
	case template.FieldStatus:
		return m.Status()
	case template.FieldDisabled:
		return m.Disabled()
	case template.FieldFormCode:
		return m.FormCode()
	case template.FieldFormVersion:
		return m.FormVersion()
	case template.FieldFormConfig:
		return m.FormConfig()
	case template.FieldFormPermissions:
		return m.FormPermissions()
	case template.FieldFieldPermissions:
		return m.FieldPermissions()
	case template.FieldNodeKey:
		return m.NodeKey()
	case template.FieldNodeType:
		return m.NodeType()
	case template.FieldNodeConfig:
		return m.NodeConfig()
	case template.FieldNodeRules:
		return m.NodeRules()
	case template.FieldNodeEvents:
		return m.NodeEvents()
	case template.FieldBusinessTags:
		return m.BusinessTags()
	case template.FieldModuleCode:
		return m.ModuleCode()
	case template.FieldCategory:
		return m.Category()
	case template.FieldAllowCancel:
		return m.AllowCancel()
	case template.FieldAllowUrge:
		return m.AllowUrge()
	case template.FieldAllowDelegate:
		return m.AllowDelegate()
	case template.FieldAllowTransfer:
		return m.AllowTransfer()
	case template.FieldIsDraftEnabled:
		return m.IsDraftEnabled()
	case template.FieldIsAutoStart:
		return m.IsAutoStart()
	case template.FieldStrictMode:
		return m.StrictMode()
	case template.FieldViewers:
		return m.Viewers()
	case template.FieldEditors:
		return m.Editors()
	case template.FieldPermissionConfigs:
		return m.PermissionConfigs()
	case template.FieldRoleConfigs:
		return m.RoleConfigs()
	case template.FieldVisibleRange:
		return m.VisibleRange()
	case template.FieldExtras:
		return m.Extras()
	case template.FieldTenantID:
		return m.TenantID()
	case template.FieldCreatedBy:
		return m.CreatedBy()
	case template.FieldUpdatedBy:
		return m.UpdatedBy()
	case template.FieldCreatedAt:
		return m.CreatedAt()
	case template.FieldUpdatedAt:
		return m.UpdatedAt()
	case template.FieldTemplateKey:
		return m.TemplateKey()
	case template.FieldProcessRules:
		return m.ProcessRules()
	case template.FieldTriggerConditions:
		return m.TriggerConditions()
	case template.FieldTimeoutConfig:
		return m.TimeoutConfig()
	case template.FieldReminderConfig:
		return m.ReminderConfig()
	case template.FieldSourceVersion:
		return m.SourceVersion()
	case template.FieldIsLatest:
		return m.IsLatest()
	case template.FieldEffectiveTime:
		return m.EffectiveTime()
	case template.FieldExpireTime:
		return m.ExpireTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case template.FieldName:
		return m.OldName(ctx)
	case template.FieldCode:
		return m.OldCode(ctx)
	case template.FieldDescription:
		return m.OldDescription(ctx)
	case template.FieldType:
		return m.OldType(ctx)
	case template.FieldVersion:
		return m.OldVersion(ctx)
	case template.FieldStatus:
		return m.OldStatus(ctx)
	case template.FieldDisabled:
		return m.OldDisabled(ctx)
	case template.FieldFormCode:
		return m.OldFormCode(ctx)
	case template.FieldFormVersion:
		return m.OldFormVersion(ctx)
	case template.FieldFormConfig:
		return m.OldFormConfig(ctx)
	case template.FieldFormPermissions:
		return m.OldFormPermissions(ctx)
	case template.FieldFieldPermissions:
		return m.OldFieldPermissions(ctx)
	case template.FieldNodeKey:
		return m.OldNodeKey(ctx)
	case template.FieldNodeType:
		return m.OldNodeType(ctx)
	case template.FieldNodeConfig:
		return m.OldNodeConfig(ctx)
	case template.FieldNodeRules:
		return m.OldNodeRules(ctx)
	case template.FieldNodeEvents:
		return m.OldNodeEvents(ctx)
	case template.FieldBusinessTags:
		return m.OldBusinessTags(ctx)
	case template.FieldModuleCode:
		return m.OldModuleCode(ctx)
	case template.FieldCategory:
		return m.OldCategory(ctx)
	case template.FieldAllowCancel:
		return m.OldAllowCancel(ctx)
	case template.FieldAllowUrge:
		return m.OldAllowUrge(ctx)
	case template.FieldAllowDelegate:
		return m.OldAllowDelegate(ctx)
	case template.FieldAllowTransfer:
		return m.OldAllowTransfer(ctx)
	case template.FieldIsDraftEnabled:
		return m.OldIsDraftEnabled(ctx)
	case template.FieldIsAutoStart:
		return m.OldIsAutoStart(ctx)
	case template.FieldStrictMode:
		return m.OldStrictMode(ctx)
	case template.FieldViewers:
		return m.OldViewers(ctx)
	case template.FieldEditors:
		return m.OldEditors(ctx)
	case template.FieldPermissionConfigs:
		return m.OldPermissionConfigs(ctx)
	case template.FieldRoleConfigs:
		return m.OldRoleConfigs(ctx)
	case template.FieldVisibleRange:
		return m.OldVisibleRange(ctx)
	case template.FieldExtras:
		return m.OldExtras(ctx)
	case template.FieldTenantID:
		return m.OldTenantID(ctx)
	case template.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case template.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case template.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case template.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case template.FieldTemplateKey:
		return m.OldTemplateKey(ctx)
	case template.FieldProcessRules:
		return m.OldProcessRules(ctx)
	case template.FieldTriggerConditions:
		return m.OldTriggerConditions(ctx)
	case template.FieldTimeoutConfig:
		return m.OldTimeoutConfig(ctx)
	case template.FieldReminderConfig:
		return m.OldReminderConfig(ctx)
	case template.FieldSourceVersion:
		return m.OldSourceVersion(ctx)
	case template.FieldIsLatest:
		return m.OldIsLatest(ctx)
	case template.FieldEffectiveTime:
		return m.OldEffectiveTime(ctx)
	case template.FieldExpireTime:
		return m.OldExpireTime(ctx)
	}
	return nil, fmt.Errorf("unknown Template field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case template.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case template.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case template.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case template.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case template.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case template.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case template.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case template.FieldFormCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormCode(v)
		return nil
	case template.FieldFormVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormVersion(v)
		return nil
	case template.FieldFormConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormConfig(v)
		return nil
	case template.FieldFormPermissions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormPermissions(v)
		return nil
	case template.FieldFieldPermissions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldPermissions(v)
		return nil
	case template.FieldNodeKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeKey(v)
		return nil
	case template.FieldNodeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeType(v)
		return nil
	case template.FieldNodeConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeConfig(v)
		return nil
	case template.FieldNodeRules:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeRules(v)
		return nil
	case template.FieldNodeEvents:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeEvents(v)
		return nil
	case template.FieldBusinessTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessTags(v)
		return nil
	case template.FieldModuleCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleCode(v)
		return nil
	case template.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case template.FieldAllowCancel:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowCancel(v)
		return nil
	case template.FieldAllowUrge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowUrge(v)
		return nil
	case template.FieldAllowDelegate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowDelegate(v)
		return nil
	case template.FieldAllowTransfer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowTransfer(v)
		return nil
	case template.FieldIsDraftEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDraftEnabled(v)
		return nil
	case template.FieldIsAutoStart:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutoStart(v)
		return nil
	case template.FieldStrictMode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrictMode(v)
		return nil
	case template.FieldViewers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewers(v)
		return nil
	case template.FieldEditors:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditors(v)
		return nil
	case template.FieldPermissionConfigs:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionConfigs(v)
		return nil
	case template.FieldRoleConfigs:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleConfigs(v)
		return nil
	case template.FieldVisibleRange:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibleRange(v)
		return nil
	case template.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case template.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case template.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case template.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case template.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case template.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case template.FieldTemplateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateKey(v)
		return nil
	case template.FieldProcessRules:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessRules(v)
		return nil
	case template.FieldTriggerConditions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggerConditions(v)
		return nil
	case template.FieldTimeoutConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeoutConfig(v)
		return nil
	case template.FieldReminderConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReminderConfig(v)
		return nil
	case template.FieldSourceVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceVersion(v)
		return nil
	case template.FieldIsLatest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLatest(v)
		return nil
	case template.FieldEffectiveTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveTime(v)
		return nil
	case template.FieldExpireTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireTime(v)
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, template.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, template.FieldUpdatedAt)
	}
	if m.addeffective_time != nil {
		fields = append(fields, template.FieldEffectiveTime)
	}
	if m.addexpire_time != nil {
		fields = append(fields, template.FieldExpireTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case template.FieldCreatedAt:
		return m.AddedCreatedAt()
	case template.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case template.FieldEffectiveTime:
		return m.AddedEffectiveTime()
	case template.FieldExpireTime:
		return m.AddedExpireTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case template.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case template.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case template.FieldEffectiveTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEffectiveTime(v)
		return nil
	case template.FieldExpireTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpireTime(v)
		return nil
	}
	return fmt.Errorf("unknown Template numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(template.FieldName) {
		fields = append(fields, template.FieldName)
	}
	if m.FieldCleared(template.FieldCode) {
		fields = append(fields, template.FieldCode)
	}
	if m.FieldCleared(template.FieldDescription) {
		fields = append(fields, template.FieldDescription)
	}
	if m.FieldCleared(template.FieldType) {
		fields = append(fields, template.FieldType)
	}
	if m.FieldCleared(template.FieldVersion) {
		fields = append(fields, template.FieldVersion)
	}
	if m.FieldCleared(template.FieldStatus) {
		fields = append(fields, template.FieldStatus)
	}
	if m.FieldCleared(template.FieldDisabled) {
		fields = append(fields, template.FieldDisabled)
	}
	if m.FieldCleared(template.FieldFormVersion) {
		fields = append(fields, template.FieldFormVersion)
	}
	if m.FieldCleared(template.FieldFormConfig) {
		fields = append(fields, template.FieldFormConfig)
	}
	if m.FieldCleared(template.FieldFormPermissions) {
		fields = append(fields, template.FieldFormPermissions)
	}
	if m.FieldCleared(template.FieldFieldPermissions) {
		fields = append(fields, template.FieldFieldPermissions)
	}
	if m.FieldCleared(template.FieldNodeConfig) {
		fields = append(fields, template.FieldNodeConfig)
	}
	if m.FieldCleared(template.FieldNodeRules) {
		fields = append(fields, template.FieldNodeRules)
	}
	if m.FieldCleared(template.FieldNodeEvents) {
		fields = append(fields, template.FieldNodeEvents)
	}
	if m.FieldCleared(template.FieldBusinessTags) {
		fields = append(fields, template.FieldBusinessTags)
	}
	if m.FieldCleared(template.FieldCategory) {
		fields = append(fields, template.FieldCategory)
	}
	if m.FieldCleared(template.FieldViewers) {
		fields = append(fields, template.FieldViewers)
	}
	if m.FieldCleared(template.FieldEditors) {
		fields = append(fields, template.FieldEditors)
	}
	if m.FieldCleared(template.FieldPermissionConfigs) {
		fields = append(fields, template.FieldPermissionConfigs)
	}
	if m.FieldCleared(template.FieldRoleConfigs) {
		fields = append(fields, template.FieldRoleConfigs)
	}
	if m.FieldCleared(template.FieldVisibleRange) {
		fields = append(fields, template.FieldVisibleRange)
	}
	if m.FieldCleared(template.FieldExtras) {
		fields = append(fields, template.FieldExtras)
	}
	if m.FieldCleared(template.FieldTenantID) {
		fields = append(fields, template.FieldTenantID)
	}
	if m.FieldCleared(template.FieldCreatedBy) {
		fields = append(fields, template.FieldCreatedBy)
	}
	if m.FieldCleared(template.FieldUpdatedBy) {
		fields = append(fields, template.FieldUpdatedBy)
	}
	if m.FieldCleared(template.FieldCreatedAt) {
		fields = append(fields, template.FieldCreatedAt)
	}
	if m.FieldCleared(template.FieldUpdatedAt) {
		fields = append(fields, template.FieldUpdatedAt)
	}
	if m.FieldCleared(template.FieldProcessRules) {
		fields = append(fields, template.FieldProcessRules)
	}
	if m.FieldCleared(template.FieldTriggerConditions) {
		fields = append(fields, template.FieldTriggerConditions)
	}
	if m.FieldCleared(template.FieldTimeoutConfig) {
		fields = append(fields, template.FieldTimeoutConfig)
	}
	if m.FieldCleared(template.FieldReminderConfig) {
		fields = append(fields, template.FieldReminderConfig)
	}
	if m.FieldCleared(template.FieldSourceVersion) {
		fields = append(fields, template.FieldSourceVersion)
	}
	if m.FieldCleared(template.FieldEffectiveTime) {
		fields = append(fields, template.FieldEffectiveTime)
	}
	if m.FieldCleared(template.FieldExpireTime) {
		fields = append(fields, template.FieldExpireTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateMutation) ClearField(name string) error {
	switch name {
	case template.FieldName:
		m.ClearName()
		return nil
	case template.FieldCode:
		m.ClearCode()
		return nil
	case template.FieldDescription:
		m.ClearDescription()
		return nil
	case template.FieldType:
		m.ClearType()
		return nil
	case template.FieldVersion:
		m.ClearVersion()
		return nil
	case template.FieldStatus:
		m.ClearStatus()
		return nil
	case template.FieldDisabled:
		m.ClearDisabled()
		return nil
	case template.FieldFormVersion:
		m.ClearFormVersion()
		return nil
	case template.FieldFormConfig:
		m.ClearFormConfig()
		return nil
	case template.FieldFormPermissions:
		m.ClearFormPermissions()
		return nil
	case template.FieldFieldPermissions:
		m.ClearFieldPermissions()
		return nil
	case template.FieldNodeConfig:
		m.ClearNodeConfig()
		return nil
	case template.FieldNodeRules:
		m.ClearNodeRules()
		return nil
	case template.FieldNodeEvents:
		m.ClearNodeEvents()
		return nil
	case template.FieldBusinessTags:
		m.ClearBusinessTags()
		return nil
	case template.FieldCategory:
		m.ClearCategory()
		return nil
	case template.FieldViewers:
		m.ClearViewers()
		return nil
	case template.FieldEditors:
		m.ClearEditors()
		return nil
	case template.FieldPermissionConfigs:
		m.ClearPermissionConfigs()
		return nil
	case template.FieldRoleConfigs:
		m.ClearRoleConfigs()
		return nil
	case template.FieldVisibleRange:
		m.ClearVisibleRange()
		return nil
	case template.FieldExtras:
		m.ClearExtras()
		return nil
	case template.FieldTenantID:
		m.ClearTenantID()
		return nil
	case template.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case template.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case template.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case template.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case template.FieldProcessRules:
		m.ClearProcessRules()
		return nil
	case template.FieldTriggerConditions:
		m.ClearTriggerConditions()
		return nil
	case template.FieldTimeoutConfig:
		m.ClearTimeoutConfig()
		return nil
	case template.FieldReminderConfig:
		m.ClearReminderConfig()
		return nil
	case template.FieldSourceVersion:
		m.ClearSourceVersion()
		return nil
	case template.FieldEffectiveTime:
		m.ClearEffectiveTime()
		return nil
	case template.FieldExpireTime:
		m.ClearExpireTime()
		return nil
	}
	return fmt.Errorf("unknown Template nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateMutation) ResetField(name string) error {
	switch name {
	case template.FieldName:
		m.ResetName()
		return nil
	case template.FieldCode:
		m.ResetCode()
		return nil
	case template.FieldDescription:
		m.ResetDescription()
		return nil
	case template.FieldType:
		m.ResetType()
		return nil
	case template.FieldVersion:
		m.ResetVersion()
		return nil
	case template.FieldStatus:
		m.ResetStatus()
		return nil
	case template.FieldDisabled:
		m.ResetDisabled()
		return nil
	case template.FieldFormCode:
		m.ResetFormCode()
		return nil
	case template.FieldFormVersion:
		m.ResetFormVersion()
		return nil
	case template.FieldFormConfig:
		m.ResetFormConfig()
		return nil
	case template.FieldFormPermissions:
		m.ResetFormPermissions()
		return nil
	case template.FieldFieldPermissions:
		m.ResetFieldPermissions()
		return nil
	case template.FieldNodeKey:
		m.ResetNodeKey()
		return nil
	case template.FieldNodeType:
		m.ResetNodeType()
		return nil
	case template.FieldNodeConfig:
		m.ResetNodeConfig()
		return nil
	case template.FieldNodeRules:
		m.ResetNodeRules()
		return nil
	case template.FieldNodeEvents:
		m.ResetNodeEvents()
		return nil
	case template.FieldBusinessTags:
		m.ResetBusinessTags()
		return nil
	case template.FieldModuleCode:
		m.ResetModuleCode()
		return nil
	case template.FieldCategory:
		m.ResetCategory()
		return nil
	case template.FieldAllowCancel:
		m.ResetAllowCancel()
		return nil
	case template.FieldAllowUrge:
		m.ResetAllowUrge()
		return nil
	case template.FieldAllowDelegate:
		m.ResetAllowDelegate()
		return nil
	case template.FieldAllowTransfer:
		m.ResetAllowTransfer()
		return nil
	case template.FieldIsDraftEnabled:
		m.ResetIsDraftEnabled()
		return nil
	case template.FieldIsAutoStart:
		m.ResetIsAutoStart()
		return nil
	case template.FieldStrictMode:
		m.ResetStrictMode()
		return nil
	case template.FieldViewers:
		m.ResetViewers()
		return nil
	case template.FieldEditors:
		m.ResetEditors()
		return nil
	case template.FieldPermissionConfigs:
		m.ResetPermissionConfigs()
		return nil
	case template.FieldRoleConfigs:
		m.ResetRoleConfigs()
		return nil
	case template.FieldVisibleRange:
		m.ResetVisibleRange()
		return nil
	case template.FieldExtras:
		m.ResetExtras()
		return nil
	case template.FieldTenantID:
		m.ResetTenantID()
		return nil
	case template.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case template.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case template.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case template.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case template.FieldTemplateKey:
		m.ResetTemplateKey()
		return nil
	case template.FieldProcessRules:
		m.ResetProcessRules()
		return nil
	case template.FieldTriggerConditions:
		m.ResetTriggerConditions()
		return nil
	case template.FieldTimeoutConfig:
		m.ResetTimeoutConfig()
		return nil
	case template.FieldReminderConfig:
		m.ResetReminderConfig()
		return nil
	case template.FieldSourceVersion:
		m.ResetSourceVersion()
		return nil
	case template.FieldIsLatest:
		m.ResetIsLatest()
		return nil
	case template.FieldEffectiveTime:
		m.ResetEffectiveTime()
		return nil
	case template.FieldExpireTime:
		m.ResetExpireTime()
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Template unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Template edge %s", name)
}
