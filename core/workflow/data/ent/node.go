// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"ncobase/core/workflow/data/ent/node"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// Node is the model entity for the Node schema.
type Node struct {
	config `json:"-"`
	// ID of the ent.
	// primary key
	ID string `json:"id,omitempty"`
	// name
	Name string `json:"name,omitempty"`
	// description
	Description string `json:"description,omitempty"`
	// type
	Type string `json:"type,omitempty"`
	// Status, text status
	Status string `json:"status,omitempty"`
	// Unique identifier for the node
	NodeKey string `json:"node_key,omitempty"`
	// Node type
	NodeType string `json:"node_type,omitempty"`
	// Node configuration
	NodeConfig map[string]interface{} `json:"node_config,omitempty"`
	// Node rules
	NodeRules map[string]interface{} `json:"node_rules,omitempty"`
	// Node events
	NodeEvents map[string]interface{} `json:"node_events,omitempty"`
	// Form type code
	FormCode string `json:"form_code,omitempty"`
	// Form version number
	FormVersion string `json:"form_version,omitempty"`
	// Form configuration
	FormConfig map[string]interface{} `json:"form_config,omitempty"`
	// Form permission settings
	FormPermissions map[string]interface{} `json:"form_permissions,omitempty"`
	// Field level permissions
	FieldPermissions map[string]interface{} `json:"field_permissions,omitempty"`
	// Task assignees
	Assignees []string `json:"assignees,omitempty"`
	// Candidate assignees
	Candidates []string `json:"candidates,omitempty"`
	// Delegated from user
	DelegatedFrom string `json:"delegated_from,omitempty"`
	// Delegation reason
	DelegatedReason string `json:"delegated_reason,omitempty"`
	// Whether task is delegated
	IsDelegated bool `json:"is_delegated,omitempty"`
	// Whether task is transferred
	IsTransferred bool `json:"is_transferred,omitempty"`
	// Allow cancellation
	AllowCancel bool `json:"allow_cancel,omitempty"`
	// Allow urging
	AllowUrge bool `json:"allow_urge,omitempty"`
	// Allow delegation
	AllowDelegate bool `json:"allow_delegate,omitempty"`
	// Allow transfer
	AllowTransfer bool `json:"allow_transfer,omitempty"`
	// Whether draft is enabled
	IsDraftEnabled bool `json:"is_draft_enabled,omitempty"`
	// Whether auto start is enabled
	IsAutoStart bool `json:"is_auto_start,omitempty"`
	// Enable strict mode
	StrictMode bool `json:"strict_mode,omitempty"`
	// Start time
	StartTime int64 `json:"start_time,omitempty"`
	// End time
	EndTime *int64 `json:"end_time,omitempty"`
	// Due time
	DueTime *int64 `json:"due_time,omitempty"`
	// Duration in seconds
	Duration int `json:"duration,omitempty"`
	// Priority level
	Priority int `json:"priority,omitempty"`
	// Whether timed out
	IsTimeout bool `json:"is_timeout,omitempty"`
	// Number of reminders sent
	ReminderCount int `json:"reminder_count,omitempty"`
	// Extend properties
	Extras map[string]interface{} `json:"extras,omitempty"`
	// tenant id
	TenantID string `json:"tenant_id,omitempty"`
	// id of the creator
	CreatedBy string `json:"created_by,omitempty"`
	// id of the last updater
	UpdatedBy string `json:"updated_by,omitempty"`
	// created at
	CreatedAt int64 `json:"created_at,omitempty"`
	// updated at
	UpdatedAt int64 `json:"updated_at,omitempty"`
	// Process ID
	ProcessID string `json:"process_id,omitempty"`
	// Permission configs
	Permissions map[string]interface{} `json:"permissions,omitempty"`
	// Previous nodes
	PrevNodes []string `json:"prev_nodes,omitempty"`
	// Next nodes
	NextNodes []string `json:"next_nodes,omitempty"`
	// Parallel nodes
	ParallelNodes []string `json:"parallel_nodes,omitempty"`
	// Branch nodes
	BranchNodes []string `json:"branch_nodes,omitempty"`
	// Transition conditions
	Conditions []string `json:"conditions,omitempty"`
	// Node properties
	Properties map[string]interface{} `json:"properties,omitempty"`
	// Whether requires countersign
	IsCountersign bool `json:"is_countersign,omitempty"`
	// Countersign rules
	CountersignRule string `json:"countersign_rule,omitempty"`
	// Handler configurations
	Handlers map[string]interface{} `json:"handlers,omitempty"`
	// Listener configurations
	Listeners map[string]interface{} `json:"listeners,omitempty"`
	// Hook configurations
	Hooks map[string]interface{} `json:"hooks,omitempty"`
	// Node variables
	Variables map[string]interface{} `json:"variables,omitempty"`
	// Number of retries
	RetryTimes int `json:"retry_times,omitempty"`
	// Retry interval in seconds
	RetryInterval int `json:"retry_interval,omitempty"`
	// Whether to count working days only
	IsWorkingDay bool `json:"is_working_day,omitempty"`
	selectValues sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Node) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case node.FieldNodeConfig, node.FieldNodeRules, node.FieldNodeEvents, node.FieldFormConfig, node.FieldFormPermissions, node.FieldFieldPermissions, node.FieldAssignees, node.FieldCandidates, node.FieldExtras, node.FieldPermissions, node.FieldPrevNodes, node.FieldNextNodes, node.FieldParallelNodes, node.FieldBranchNodes, node.FieldConditions, node.FieldProperties, node.FieldHandlers, node.FieldListeners, node.FieldHooks, node.FieldVariables:
			values[i] = new([]byte)
		case node.FieldIsDelegated, node.FieldIsTransferred, node.FieldAllowCancel, node.FieldAllowUrge, node.FieldAllowDelegate, node.FieldAllowTransfer, node.FieldIsDraftEnabled, node.FieldIsAutoStart, node.FieldStrictMode, node.FieldIsTimeout, node.FieldIsCountersign, node.FieldIsWorkingDay:
			values[i] = new(sql.NullBool)
		case node.FieldStartTime, node.FieldEndTime, node.FieldDueTime, node.FieldDuration, node.FieldPriority, node.FieldReminderCount, node.FieldCreatedAt, node.FieldUpdatedAt, node.FieldRetryTimes, node.FieldRetryInterval:
			values[i] = new(sql.NullInt64)
		case node.FieldID, node.FieldName, node.FieldDescription, node.FieldType, node.FieldStatus, node.FieldNodeKey, node.FieldNodeType, node.FieldFormCode, node.FieldFormVersion, node.FieldDelegatedFrom, node.FieldDelegatedReason, node.FieldTenantID, node.FieldCreatedBy, node.FieldUpdatedBy, node.FieldProcessID, node.FieldCountersignRule:
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Node fields.
func (n *Node) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case node.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				n.ID = value.String
			}
		case node.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				n.Name = value.String
			}
		case node.FieldDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field description", values[i])
			} else if value.Valid {
				n.Description = value.String
			}
		case node.FieldType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field type", values[i])
			} else if value.Valid {
				n.Type = value.String
			}
		case node.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				n.Status = value.String
			}
		case node.FieldNodeKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field node_key", values[i])
			} else if value.Valid {
				n.NodeKey = value.String
			}
		case node.FieldNodeType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field node_type", values[i])
			} else if value.Valid {
				n.NodeType = value.String
			}
		case node.FieldNodeConfig:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field node_config", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.NodeConfig); err != nil {
					return fmt.Errorf("unmarshal field node_config: %w", err)
				}
			}
		case node.FieldNodeRules:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field node_rules", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.NodeRules); err != nil {
					return fmt.Errorf("unmarshal field node_rules: %w", err)
				}
			}
		case node.FieldNodeEvents:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field node_events", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.NodeEvents); err != nil {
					return fmt.Errorf("unmarshal field node_events: %w", err)
				}
			}
		case node.FieldFormCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field form_code", values[i])
			} else if value.Valid {
				n.FormCode = value.String
			}
		case node.FieldFormVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field form_version", values[i])
			} else if value.Valid {
				n.FormVersion = value.String
			}
		case node.FieldFormConfig:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field form_config", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.FormConfig); err != nil {
					return fmt.Errorf("unmarshal field form_config: %w", err)
				}
			}
		case node.FieldFormPermissions:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field form_permissions", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.FormPermissions); err != nil {
					return fmt.Errorf("unmarshal field form_permissions: %w", err)
				}
			}
		case node.FieldFieldPermissions:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field field_permissions", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.FieldPermissions); err != nil {
					return fmt.Errorf("unmarshal field field_permissions: %w", err)
				}
			}
		case node.FieldAssignees:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field assignees", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.Assignees); err != nil {
					return fmt.Errorf("unmarshal field assignees: %w", err)
				}
			}
		case node.FieldCandidates:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field candidates", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.Candidates); err != nil {
					return fmt.Errorf("unmarshal field candidates: %w", err)
				}
			}
		case node.FieldDelegatedFrom:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field delegated_from", values[i])
			} else if value.Valid {
				n.DelegatedFrom = value.String
			}
		case node.FieldDelegatedReason:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field delegated_reason", values[i])
			} else if value.Valid {
				n.DelegatedReason = value.String
			}
		case node.FieldIsDelegated:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_delegated", values[i])
			} else if value.Valid {
				n.IsDelegated = value.Bool
			}
		case node.FieldIsTransferred:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_transferred", values[i])
			} else if value.Valid {
				n.IsTransferred = value.Bool
			}
		case node.FieldAllowCancel:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field allow_cancel", values[i])
			} else if value.Valid {
				n.AllowCancel = value.Bool
			}
		case node.FieldAllowUrge:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field allow_urge", values[i])
			} else if value.Valid {
				n.AllowUrge = value.Bool
			}
		case node.FieldAllowDelegate:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field allow_delegate", values[i])
			} else if value.Valid {
				n.AllowDelegate = value.Bool
			}
		case node.FieldAllowTransfer:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field allow_transfer", values[i])
			} else if value.Valid {
				n.AllowTransfer = value.Bool
			}
		case node.FieldIsDraftEnabled:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_draft_enabled", values[i])
			} else if value.Valid {
				n.IsDraftEnabled = value.Bool
			}
		case node.FieldIsAutoStart:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_auto_start", values[i])
			} else if value.Valid {
				n.IsAutoStart = value.Bool
			}
		case node.FieldStrictMode:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field strict_mode", values[i])
			} else if value.Valid {
				n.StrictMode = value.Bool
			}
		case node.FieldStartTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field start_time", values[i])
			} else if value.Valid {
				n.StartTime = value.Int64
			}
		case node.FieldEndTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field end_time", values[i])
			} else if value.Valid {
				n.EndTime = new(int64)
				*n.EndTime = value.Int64
			}
		case node.FieldDueTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field due_time", values[i])
			} else if value.Valid {
				n.DueTime = new(int64)
				*n.DueTime = value.Int64
			}
		case node.FieldDuration:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field duration", values[i])
			} else if value.Valid {
				n.Duration = int(value.Int64)
			}
		case node.FieldPriority:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field priority", values[i])
			} else if value.Valid {
				n.Priority = int(value.Int64)
			}
		case node.FieldIsTimeout:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_timeout", values[i])
			} else if value.Valid {
				n.IsTimeout = value.Bool
			}
		case node.FieldReminderCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field reminder_count", values[i])
			} else if value.Valid {
				n.ReminderCount = int(value.Int64)
			}
		case node.FieldExtras:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field extras", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.Extras); err != nil {
					return fmt.Errorf("unmarshal field extras: %w", err)
				}
			}
		case node.FieldTenantID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value.Valid {
				n.TenantID = value.String
			}
		case node.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				n.CreatedBy = value.String
			}
		case node.FieldUpdatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field updated_by", values[i])
			} else if value.Valid {
				n.UpdatedBy = value.String
			}
		case node.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				n.CreatedAt = value.Int64
			}
		case node.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				n.UpdatedAt = value.Int64
			}
		case node.FieldProcessID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field process_id", values[i])
			} else if value.Valid {
				n.ProcessID = value.String
			}
		case node.FieldPermissions:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field permissions", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.Permissions); err != nil {
					return fmt.Errorf("unmarshal field permissions: %w", err)
				}
			}
		case node.FieldPrevNodes:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field prev_nodes", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.PrevNodes); err != nil {
					return fmt.Errorf("unmarshal field prev_nodes: %w", err)
				}
			}
		case node.FieldNextNodes:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field next_nodes", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.NextNodes); err != nil {
					return fmt.Errorf("unmarshal field next_nodes: %w", err)
				}
			}
		case node.FieldParallelNodes:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field parallel_nodes", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.ParallelNodes); err != nil {
					return fmt.Errorf("unmarshal field parallel_nodes: %w", err)
				}
			}
		case node.FieldBranchNodes:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field branch_nodes", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.BranchNodes); err != nil {
					return fmt.Errorf("unmarshal field branch_nodes: %w", err)
				}
			}
		case node.FieldConditions:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field conditions", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.Conditions); err != nil {
					return fmt.Errorf("unmarshal field conditions: %w", err)
				}
			}
		case node.FieldProperties:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field properties", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.Properties); err != nil {
					return fmt.Errorf("unmarshal field properties: %w", err)
				}
			}
		case node.FieldIsCountersign:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_countersign", values[i])
			} else if value.Valid {
				n.IsCountersign = value.Bool
			}
		case node.FieldCountersignRule:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field countersign_rule", values[i])
			} else if value.Valid {
				n.CountersignRule = value.String
			}
		case node.FieldHandlers:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field handlers", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.Handlers); err != nil {
					return fmt.Errorf("unmarshal field handlers: %w", err)
				}
			}
		case node.FieldListeners:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field listeners", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.Listeners); err != nil {
					return fmt.Errorf("unmarshal field listeners: %w", err)
				}
			}
		case node.FieldHooks:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field hooks", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.Hooks); err != nil {
					return fmt.Errorf("unmarshal field hooks: %w", err)
				}
			}
		case node.FieldVariables:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field variables", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &n.Variables); err != nil {
					return fmt.Errorf("unmarshal field variables: %w", err)
				}
			}
		case node.FieldRetryTimes:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field retry_times", values[i])
			} else if value.Valid {
				n.RetryTimes = int(value.Int64)
			}
		case node.FieldRetryInterval:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field retry_interval", values[i])
			} else if value.Valid {
				n.RetryInterval = int(value.Int64)
			}
		case node.FieldIsWorkingDay:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_working_day", values[i])
			} else if value.Valid {
				n.IsWorkingDay = value.Bool
			}
		default:
			n.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Node.
// This includes values selected through modifiers, order, etc.
func (n *Node) Value(name string) (ent.Value, error) {
	return n.selectValues.Get(name)
}

// Update returns a builder for updating this Node.
// Note that you need to call Node.Unwrap() before calling this method if this Node
// was returned from a transaction, and the transaction was committed or rolled back.
func (n *Node) Update() *NodeUpdateOne {
	return NewNodeClient(n.config).UpdateOne(n)
}

// Unwrap unwraps the Node entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (n *Node) Unwrap() *Node {
	_tx, ok := n.config.driver.(*txDriver)
	if !ok {
		panic("ent: Node is not a transactional entity")
	}
	n.config.driver = _tx.drv
	return n
}

// String implements the fmt.Stringer.
func (n *Node) String() string {
	var builder strings.Builder
	builder.WriteString("Node(")
	builder.WriteString(fmt.Sprintf("id=%v, ", n.ID))
	builder.WriteString("name=")
	builder.WriteString(n.Name)
	builder.WriteString(", ")
	builder.WriteString("description=")
	builder.WriteString(n.Description)
	builder.WriteString(", ")
	builder.WriteString("type=")
	builder.WriteString(n.Type)
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(n.Status)
	builder.WriteString(", ")
	builder.WriteString("node_key=")
	builder.WriteString(n.NodeKey)
	builder.WriteString(", ")
	builder.WriteString("node_type=")
	builder.WriteString(n.NodeType)
	builder.WriteString(", ")
	builder.WriteString("node_config=")
	builder.WriteString(fmt.Sprintf("%v", n.NodeConfig))
	builder.WriteString(", ")
	builder.WriteString("node_rules=")
	builder.WriteString(fmt.Sprintf("%v", n.NodeRules))
	builder.WriteString(", ")
	builder.WriteString("node_events=")
	builder.WriteString(fmt.Sprintf("%v", n.NodeEvents))
	builder.WriteString(", ")
	builder.WriteString("form_code=")
	builder.WriteString(n.FormCode)
	builder.WriteString(", ")
	builder.WriteString("form_version=")
	builder.WriteString(n.FormVersion)
	builder.WriteString(", ")
	builder.WriteString("form_config=")
	builder.WriteString(fmt.Sprintf("%v", n.FormConfig))
	builder.WriteString(", ")
	builder.WriteString("form_permissions=")
	builder.WriteString(fmt.Sprintf("%v", n.FormPermissions))
	builder.WriteString(", ")
	builder.WriteString("field_permissions=")
	builder.WriteString(fmt.Sprintf("%v", n.FieldPermissions))
	builder.WriteString(", ")
	builder.WriteString("assignees=")
	builder.WriteString(fmt.Sprintf("%v", n.Assignees))
	builder.WriteString(", ")
	builder.WriteString("candidates=")
	builder.WriteString(fmt.Sprintf("%v", n.Candidates))
	builder.WriteString(", ")
	builder.WriteString("delegated_from=")
	builder.WriteString(n.DelegatedFrom)
	builder.WriteString(", ")
	builder.WriteString("delegated_reason=")
	builder.WriteString(n.DelegatedReason)
	builder.WriteString(", ")
	builder.WriteString("is_delegated=")
	builder.WriteString(fmt.Sprintf("%v", n.IsDelegated))
	builder.WriteString(", ")
	builder.WriteString("is_transferred=")
	builder.WriteString(fmt.Sprintf("%v", n.IsTransferred))
	builder.WriteString(", ")
	builder.WriteString("allow_cancel=")
	builder.WriteString(fmt.Sprintf("%v", n.AllowCancel))
	builder.WriteString(", ")
	builder.WriteString("allow_urge=")
	builder.WriteString(fmt.Sprintf("%v", n.AllowUrge))
	builder.WriteString(", ")
	builder.WriteString("allow_delegate=")
	builder.WriteString(fmt.Sprintf("%v", n.AllowDelegate))
	builder.WriteString(", ")
	builder.WriteString("allow_transfer=")
	builder.WriteString(fmt.Sprintf("%v", n.AllowTransfer))
	builder.WriteString(", ")
	builder.WriteString("is_draft_enabled=")
	builder.WriteString(fmt.Sprintf("%v", n.IsDraftEnabled))
	builder.WriteString(", ")
	builder.WriteString("is_auto_start=")
	builder.WriteString(fmt.Sprintf("%v", n.IsAutoStart))
	builder.WriteString(", ")
	builder.WriteString("strict_mode=")
	builder.WriteString(fmt.Sprintf("%v", n.StrictMode))
	builder.WriteString(", ")
	builder.WriteString("start_time=")
	builder.WriteString(fmt.Sprintf("%v", n.StartTime))
	builder.WriteString(", ")
	if v := n.EndTime; v != nil {
		builder.WriteString("end_time=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := n.DueTime; v != nil {
		builder.WriteString("due_time=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("duration=")
	builder.WriteString(fmt.Sprintf("%v", n.Duration))
	builder.WriteString(", ")
	builder.WriteString("priority=")
	builder.WriteString(fmt.Sprintf("%v", n.Priority))
	builder.WriteString(", ")
	builder.WriteString("is_timeout=")
	builder.WriteString(fmt.Sprintf("%v", n.IsTimeout))
	builder.WriteString(", ")
	builder.WriteString("reminder_count=")
	builder.WriteString(fmt.Sprintf("%v", n.ReminderCount))
	builder.WriteString(", ")
	builder.WriteString("extras=")
	builder.WriteString(fmt.Sprintf("%v", n.Extras))
	builder.WriteString(", ")
	builder.WriteString("tenant_id=")
	builder.WriteString(n.TenantID)
	builder.WriteString(", ")
	builder.WriteString("created_by=")
	builder.WriteString(n.CreatedBy)
	builder.WriteString(", ")
	builder.WriteString("updated_by=")
	builder.WriteString(n.UpdatedBy)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(fmt.Sprintf("%v", n.CreatedAt))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(fmt.Sprintf("%v", n.UpdatedAt))
	builder.WriteString(", ")
	builder.WriteString("process_id=")
	builder.WriteString(n.ProcessID)
	builder.WriteString(", ")
	builder.WriteString("permissions=")
	builder.WriteString(fmt.Sprintf("%v", n.Permissions))
	builder.WriteString(", ")
	builder.WriteString("prev_nodes=")
	builder.WriteString(fmt.Sprintf("%v", n.PrevNodes))
	builder.WriteString(", ")
	builder.WriteString("next_nodes=")
	builder.WriteString(fmt.Sprintf("%v", n.NextNodes))
	builder.WriteString(", ")
	builder.WriteString("parallel_nodes=")
	builder.WriteString(fmt.Sprintf("%v", n.ParallelNodes))
	builder.WriteString(", ")
	builder.WriteString("branch_nodes=")
	builder.WriteString(fmt.Sprintf("%v", n.BranchNodes))
	builder.WriteString(", ")
	builder.WriteString("conditions=")
	builder.WriteString(fmt.Sprintf("%v", n.Conditions))
	builder.WriteString(", ")
	builder.WriteString("properties=")
	builder.WriteString(fmt.Sprintf("%v", n.Properties))
	builder.WriteString(", ")
	builder.WriteString("is_countersign=")
	builder.WriteString(fmt.Sprintf("%v", n.IsCountersign))
	builder.WriteString(", ")
	builder.WriteString("countersign_rule=")
	builder.WriteString(n.CountersignRule)
	builder.WriteString(", ")
	builder.WriteString("handlers=")
	builder.WriteString(fmt.Sprintf("%v", n.Handlers))
	builder.WriteString(", ")
	builder.WriteString("listeners=")
	builder.WriteString(fmt.Sprintf("%v", n.Listeners))
	builder.WriteString(", ")
	builder.WriteString("hooks=")
	builder.WriteString(fmt.Sprintf("%v", n.Hooks))
	builder.WriteString(", ")
	builder.WriteString("variables=")
	builder.WriteString(fmt.Sprintf("%v", n.Variables))
	builder.WriteString(", ")
	builder.WriteString("retry_times=")
	builder.WriteString(fmt.Sprintf("%v", n.RetryTimes))
	builder.WriteString(", ")
	builder.WriteString("retry_interval=")
	builder.WriteString(fmt.Sprintf("%v", n.RetryInterval))
	builder.WriteString(", ")
	builder.WriteString("is_working_day=")
	builder.WriteString(fmt.Sprintf("%v", n.IsWorkingDay))
	builder.WriteByte(')')
	return builder.String()
}

// Nodes is a parsable slice of Node.
type Nodes []*Node
