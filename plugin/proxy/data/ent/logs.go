// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"ncobase/proxy/data/ent/logs"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// Logs is the model entity for the Logs schema.
type Logs struct {
	config `json:"-"`
	// ID of the ent.
	// primary key
	ID string `json:"id,omitempty"`
	// created at
	CreatedAt int64 `json:"created_at,omitempty"`
	// updated at
	UpdatedAt int64 `json:"updated_at,omitempty"`
	// ID of the associated endpoint
	EndpointID string `json:"endpoint_id,omitempty"`
	// ID of the associated route
	RouteID string `json:"route_id,omitempty"`
	// HTTP method of the request
	RequestMethod string `json:"request_method,omitempty"`
	// Path of the request
	RequestPath string `json:"request_path,omitempty"`
	// Headers of the request (JSON format)
	RequestHeaders string `json:"request_headers,omitempty"`
	// Body of the request
	RequestBody string `json:"request_body,omitempty"`
	// HTTP status code of the response
	StatusCode int `json:"status_code,omitempty"`
	// Headers of the response (JSON format)
	ResponseHeaders string `json:"response_headers,omitempty"`
	// Body of the response
	ResponseBody string `json:"response_body,omitempty"`
	// Duration of the request in milliseconds
	Duration int `json:"duration,omitempty"`
	// Error message if any
	Error string `json:"error,omitempty"`
	// IP address of the client
	ClientIP string `json:"client_ip,omitempty"`
	// ID of the user who made the request
	UserID       string `json:"user_id,omitempty"`
	selectValues sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Logs) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case logs.FieldCreatedAt, logs.FieldUpdatedAt, logs.FieldStatusCode, logs.FieldDuration:
			values[i] = new(sql.NullInt64)
		case logs.FieldID, logs.FieldEndpointID, logs.FieldRouteID, logs.FieldRequestMethod, logs.FieldRequestPath, logs.FieldRequestHeaders, logs.FieldRequestBody, logs.FieldResponseHeaders, logs.FieldResponseBody, logs.FieldError, logs.FieldClientIP, logs.FieldUserID:
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Logs fields.
func (l *Logs) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case logs.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				l.ID = value.String
			}
		case logs.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				l.CreatedAt = value.Int64
			}
		case logs.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				l.UpdatedAt = value.Int64
			}
		case logs.FieldEndpointID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field endpoint_id", values[i])
			} else if value.Valid {
				l.EndpointID = value.String
			}
		case logs.FieldRouteID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field route_id", values[i])
			} else if value.Valid {
				l.RouteID = value.String
			}
		case logs.FieldRequestMethod:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field request_method", values[i])
			} else if value.Valid {
				l.RequestMethod = value.String
			}
		case logs.FieldRequestPath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field request_path", values[i])
			} else if value.Valid {
				l.RequestPath = value.String
			}
		case logs.FieldRequestHeaders:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field request_headers", values[i])
			} else if value.Valid {
				l.RequestHeaders = value.String
			}
		case logs.FieldRequestBody:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field request_body", values[i])
			} else if value.Valid {
				l.RequestBody = value.String
			}
		case logs.FieldStatusCode:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field status_code", values[i])
			} else if value.Valid {
				l.StatusCode = int(value.Int64)
			}
		case logs.FieldResponseHeaders:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field response_headers", values[i])
			} else if value.Valid {
				l.ResponseHeaders = value.String
			}
		case logs.FieldResponseBody:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field response_body", values[i])
			} else if value.Valid {
				l.ResponseBody = value.String
			}
		case logs.FieldDuration:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field duration", values[i])
			} else if value.Valid {
				l.Duration = int(value.Int64)
			}
		case logs.FieldError:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field error", values[i])
			} else if value.Valid {
				l.Error = value.String
			}
		case logs.FieldClientIP:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field client_ip", values[i])
			} else if value.Valid {
				l.ClientIP = value.String
			}
		case logs.FieldUserID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field user_id", values[i])
			} else if value.Valid {
				l.UserID = value.String
			}
		default:
			l.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Logs.
// This includes values selected through modifiers, order, etc.
func (l *Logs) Value(name string) (ent.Value, error) {
	return l.selectValues.Get(name)
}

// Update returns a builder for updating this Logs.
// Note that you need to call Logs.Unwrap() before calling this method if this Logs
// was returned from a transaction, and the transaction was committed or rolled back.
func (l *Logs) Update() *LogsUpdateOne {
	return NewLogsClient(l.config).UpdateOne(l)
}

// Unwrap unwraps the Logs entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (l *Logs) Unwrap() *Logs {
	_tx, ok := l.config.driver.(*txDriver)
	if !ok {
		panic("ent: Logs is not a transactional entity")
	}
	l.config.driver = _tx.drv
	return l
}

// String implements the fmt.Stringer.
func (l *Logs) String() string {
	var builder strings.Builder
	builder.WriteString("Logs(")
	builder.WriteString(fmt.Sprintf("id=%v, ", l.ID))
	builder.WriteString("created_at=")
	builder.WriteString(fmt.Sprintf("%v", l.CreatedAt))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(fmt.Sprintf("%v", l.UpdatedAt))
	builder.WriteString(", ")
	builder.WriteString("endpoint_id=")
	builder.WriteString(l.EndpointID)
	builder.WriteString(", ")
	builder.WriteString("route_id=")
	builder.WriteString(l.RouteID)
	builder.WriteString(", ")
	builder.WriteString("request_method=")
	builder.WriteString(l.RequestMethod)
	builder.WriteString(", ")
	builder.WriteString("request_path=")
	builder.WriteString(l.RequestPath)
	builder.WriteString(", ")
	builder.WriteString("request_headers=")
	builder.WriteString(l.RequestHeaders)
	builder.WriteString(", ")
	builder.WriteString("request_body=")
	builder.WriteString(l.RequestBody)
	builder.WriteString(", ")
	builder.WriteString("status_code=")
	builder.WriteString(fmt.Sprintf("%v", l.StatusCode))
	builder.WriteString(", ")
	builder.WriteString("response_headers=")
	builder.WriteString(l.ResponseHeaders)
	builder.WriteString(", ")
	builder.WriteString("response_body=")
	builder.WriteString(l.ResponseBody)
	builder.WriteString(", ")
	builder.WriteString("duration=")
	builder.WriteString(fmt.Sprintf("%v", l.Duration))
	builder.WriteString(", ")
	builder.WriteString("error=")
	builder.WriteString(l.Error)
	builder.WriteString(", ")
	builder.WriteString("client_ip=")
	builder.WriteString(l.ClientIP)
	builder.WriteString(", ")
	builder.WriteString("user_id=")
	builder.WriteString(l.UserID)
	builder.WriteByte(')')
	return builder.String()
}

// LogsSlice is a parsable slice of Logs.
type LogsSlice []*Logs
