// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"ncobase/plugin/proxy/data/ent/endpoint"
	"ncobase/plugin/proxy/data/ent/logs"
	"ncobase/plugin/proxy/data/ent/predicate"
	"ncobase/plugin/proxy/data/ent/route"
	"ncobase/plugin/proxy/data/ent/transformer"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEndpoint    = "Endpoint"
	TypeLogs        = "Logs"
	TypeRoute       = "Route"
	TypeTransformer = "Transformer"
)

// EndpointMutation represents an operation that mutates the Endpoint nodes in the graph.
type EndpointMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	description         *string
	disabled            *bool
	extras              *map[string]interface{}
	created_by          *string
	updated_by          *string
	created_at          *int64
	addcreated_at       *int64
	updated_at          *int64
	addupdated_at       *int64
	base_url            *string
	protocol            *string
	auth_type           *string
	auth_config         *string
	timeout             *int
	addtimeout          *int
	use_circuit_breaker *bool
	retry_count         *int
	addretry_count      *int
	validate_ssl        *bool
	log_requests        *bool
	log_responses       *bool
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Endpoint, error)
	predicates          []predicate.Endpoint
}

var _ ent.Mutation = (*EndpointMutation)(nil)

// endpointOption allows management of the mutation configuration using functional options.
type endpointOption func(*EndpointMutation)

// newEndpointMutation creates new mutation for the Endpoint entity.
func newEndpointMutation(c config, op Op, opts ...endpointOption) *EndpointMutation {
	m := &EndpointMutation{
		config:        c,
		op:            op,
		typ:           TypeEndpoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEndpointID sets the ID field of the mutation.
func withEndpointID(id string) endpointOption {
	return func(m *EndpointMutation) {
		var (
			err   error
			once  sync.Once
			value *Endpoint
		)
		m.oldValue = func(ctx context.Context) (*Endpoint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Endpoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEndpoint sets the old Endpoint of the mutation.
func withEndpoint(node *Endpoint) endpointOption {
	return func(m *EndpointMutation) {
		m.oldValue = func(context.Context) (*Endpoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EndpointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EndpointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Endpoint entities.
func (m *EndpointMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EndpointMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EndpointMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Endpoint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EndpointMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EndpointMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *EndpointMutation) ClearName() {
	m.name = nil
	m.clearedFields[endpoint.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *EndpointMutation) NameCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *EndpointMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, endpoint.FieldName)
}

// SetDescription sets the "description" field.
func (m *EndpointMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EndpointMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EndpointMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[endpoint.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EndpointMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EndpointMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, endpoint.FieldDescription)
}

// SetDisabled sets the "disabled" field.
func (m *EndpointMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *EndpointMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *EndpointMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[endpoint.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *EndpointMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *EndpointMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, endpoint.FieldDisabled)
}

// SetExtras sets the "extras" field.
func (m *EndpointMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *EndpointMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *EndpointMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[endpoint.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *EndpointMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *EndpointMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, endpoint.FieldExtras)
}

// SetCreatedBy sets the "created_by" field.
func (m *EndpointMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EndpointMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EndpointMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[endpoint.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EndpointMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EndpointMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, endpoint.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EndpointMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EndpointMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EndpointMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[endpoint.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EndpointMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EndpointMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, endpoint.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *EndpointMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EndpointMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *EndpointMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EndpointMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EndpointMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[endpoint.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EndpointMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EndpointMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, endpoint.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EndpointMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EndpointMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *EndpointMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EndpointMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EndpointMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[endpoint.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EndpointMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EndpointMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, endpoint.FieldUpdatedAt)
}

// SetBaseURL sets the "base_url" field.
func (m *EndpointMutation) SetBaseURL(s string) {
	m.base_url = &s
}

// BaseURL returns the value of the "base_url" field in the mutation.
func (m *EndpointMutation) BaseURL() (r string, exists bool) {
	v := m.base_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseURL returns the old "base_url" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldBaseURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseURL: %w", err)
	}
	return oldValue.BaseURL, nil
}

// ResetBaseURL resets all changes to the "base_url" field.
func (m *EndpointMutation) ResetBaseURL() {
	m.base_url = nil
}

// SetProtocol sets the "protocol" field.
func (m *EndpointMutation) SetProtocol(s string) {
	m.protocol = &s
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *EndpointMutation) Protocol() (r string, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldProtocol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *EndpointMutation) ResetProtocol() {
	m.protocol = nil
}

// SetAuthType sets the "auth_type" field.
func (m *EndpointMutation) SetAuthType(s string) {
	m.auth_type = &s
}

// AuthType returns the value of the "auth_type" field in the mutation.
func (m *EndpointMutation) AuthType() (r string, exists bool) {
	v := m.auth_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthType returns the old "auth_type" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldAuthType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthType: %w", err)
	}
	return oldValue.AuthType, nil
}

// ResetAuthType resets all changes to the "auth_type" field.
func (m *EndpointMutation) ResetAuthType() {
	m.auth_type = nil
}

// SetAuthConfig sets the "auth_config" field.
func (m *EndpointMutation) SetAuthConfig(s string) {
	m.auth_config = &s
}

// AuthConfig returns the value of the "auth_config" field in the mutation.
func (m *EndpointMutation) AuthConfig() (r string, exists bool) {
	v := m.auth_config
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthConfig returns the old "auth_config" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldAuthConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthConfig: %w", err)
	}
	return oldValue.AuthConfig, nil
}

// ClearAuthConfig clears the value of the "auth_config" field.
func (m *EndpointMutation) ClearAuthConfig() {
	m.auth_config = nil
	m.clearedFields[endpoint.FieldAuthConfig] = struct{}{}
}

// AuthConfigCleared returns if the "auth_config" field was cleared in this mutation.
func (m *EndpointMutation) AuthConfigCleared() bool {
	_, ok := m.clearedFields[endpoint.FieldAuthConfig]
	return ok
}

// ResetAuthConfig resets all changes to the "auth_config" field.
func (m *EndpointMutation) ResetAuthConfig() {
	m.auth_config = nil
	delete(m.clearedFields, endpoint.FieldAuthConfig)
}

// SetTimeout sets the "timeout" field.
func (m *EndpointMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *EndpointMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *EndpointMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *EndpointMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *EndpointMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetUseCircuitBreaker sets the "use_circuit_breaker" field.
func (m *EndpointMutation) SetUseCircuitBreaker(b bool) {
	m.use_circuit_breaker = &b
}

// UseCircuitBreaker returns the value of the "use_circuit_breaker" field in the mutation.
func (m *EndpointMutation) UseCircuitBreaker() (r bool, exists bool) {
	v := m.use_circuit_breaker
	if v == nil {
		return
	}
	return *v, true
}

// OldUseCircuitBreaker returns the old "use_circuit_breaker" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldUseCircuitBreaker(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseCircuitBreaker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseCircuitBreaker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseCircuitBreaker: %w", err)
	}
	return oldValue.UseCircuitBreaker, nil
}

// ResetUseCircuitBreaker resets all changes to the "use_circuit_breaker" field.
func (m *EndpointMutation) ResetUseCircuitBreaker() {
	m.use_circuit_breaker = nil
}

// SetRetryCount sets the "retry_count" field.
func (m *EndpointMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *EndpointMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *EndpointMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *EndpointMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *EndpointMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetValidateSsl sets the "validate_ssl" field.
func (m *EndpointMutation) SetValidateSsl(b bool) {
	m.validate_ssl = &b
}

// ValidateSsl returns the value of the "validate_ssl" field in the mutation.
func (m *EndpointMutation) ValidateSsl() (r bool, exists bool) {
	v := m.validate_ssl
	if v == nil {
		return
	}
	return *v, true
}

// OldValidateSsl returns the old "validate_ssl" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldValidateSsl(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidateSsl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidateSsl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidateSsl: %w", err)
	}
	return oldValue.ValidateSsl, nil
}

// ResetValidateSsl resets all changes to the "validate_ssl" field.
func (m *EndpointMutation) ResetValidateSsl() {
	m.validate_ssl = nil
}

// SetLogRequests sets the "log_requests" field.
func (m *EndpointMutation) SetLogRequests(b bool) {
	m.log_requests = &b
}

// LogRequests returns the value of the "log_requests" field in the mutation.
func (m *EndpointMutation) LogRequests() (r bool, exists bool) {
	v := m.log_requests
	if v == nil {
		return
	}
	return *v, true
}

// OldLogRequests returns the old "log_requests" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldLogRequests(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogRequests is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogRequests requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogRequests: %w", err)
	}
	return oldValue.LogRequests, nil
}

// ResetLogRequests resets all changes to the "log_requests" field.
func (m *EndpointMutation) ResetLogRequests() {
	m.log_requests = nil
}

// SetLogResponses sets the "log_responses" field.
func (m *EndpointMutation) SetLogResponses(b bool) {
	m.log_responses = &b
}

// LogResponses returns the value of the "log_responses" field in the mutation.
func (m *EndpointMutation) LogResponses() (r bool, exists bool) {
	v := m.log_responses
	if v == nil {
		return
	}
	return *v, true
}

// OldLogResponses returns the old "log_responses" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldLogResponses(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogResponses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogResponses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogResponses: %w", err)
	}
	return oldValue.LogResponses, nil
}

// ResetLogResponses resets all changes to the "log_responses" field.
func (m *EndpointMutation) ResetLogResponses() {
	m.log_responses = nil
}

// Where appends a list predicates to the EndpointMutation builder.
func (m *EndpointMutation) Where(ps ...predicate.Endpoint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EndpointMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EndpointMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Endpoint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EndpointMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EndpointMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Endpoint).
func (m *EndpointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EndpointMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.name != nil {
		fields = append(fields, endpoint.FieldName)
	}
	if m.description != nil {
		fields = append(fields, endpoint.FieldDescription)
	}
	if m.disabled != nil {
		fields = append(fields, endpoint.FieldDisabled)
	}
	if m.extras != nil {
		fields = append(fields, endpoint.FieldExtras)
	}
	if m.created_by != nil {
		fields = append(fields, endpoint.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, endpoint.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, endpoint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, endpoint.FieldUpdatedAt)
	}
	if m.base_url != nil {
		fields = append(fields, endpoint.FieldBaseURL)
	}
	if m.protocol != nil {
		fields = append(fields, endpoint.FieldProtocol)
	}
	if m.auth_type != nil {
		fields = append(fields, endpoint.FieldAuthType)
	}
	if m.auth_config != nil {
		fields = append(fields, endpoint.FieldAuthConfig)
	}
	if m.timeout != nil {
		fields = append(fields, endpoint.FieldTimeout)
	}
	if m.use_circuit_breaker != nil {
		fields = append(fields, endpoint.FieldUseCircuitBreaker)
	}
	if m.retry_count != nil {
		fields = append(fields, endpoint.FieldRetryCount)
	}
	if m.validate_ssl != nil {
		fields = append(fields, endpoint.FieldValidateSsl)
	}
	if m.log_requests != nil {
		fields = append(fields, endpoint.FieldLogRequests)
	}
	if m.log_responses != nil {
		fields = append(fields, endpoint.FieldLogResponses)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EndpointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case endpoint.FieldName:
		return m.Name()
	case endpoint.FieldDescription:
		return m.Description()
	case endpoint.FieldDisabled:
		return m.Disabled()
	case endpoint.FieldExtras:
		return m.Extras()
	case endpoint.FieldCreatedBy:
		return m.CreatedBy()
	case endpoint.FieldUpdatedBy:
		return m.UpdatedBy()
	case endpoint.FieldCreatedAt:
		return m.CreatedAt()
	case endpoint.FieldUpdatedAt:
		return m.UpdatedAt()
	case endpoint.FieldBaseURL:
		return m.BaseURL()
	case endpoint.FieldProtocol:
		return m.Protocol()
	case endpoint.FieldAuthType:
		return m.AuthType()
	case endpoint.FieldAuthConfig:
		return m.AuthConfig()
	case endpoint.FieldTimeout:
		return m.Timeout()
	case endpoint.FieldUseCircuitBreaker:
		return m.UseCircuitBreaker()
	case endpoint.FieldRetryCount:
		return m.RetryCount()
	case endpoint.FieldValidateSsl:
		return m.ValidateSsl()
	case endpoint.FieldLogRequests:
		return m.LogRequests()
	case endpoint.FieldLogResponses:
		return m.LogResponses()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EndpointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case endpoint.FieldName:
		return m.OldName(ctx)
	case endpoint.FieldDescription:
		return m.OldDescription(ctx)
	case endpoint.FieldDisabled:
		return m.OldDisabled(ctx)
	case endpoint.FieldExtras:
		return m.OldExtras(ctx)
	case endpoint.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case endpoint.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case endpoint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case endpoint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case endpoint.FieldBaseURL:
		return m.OldBaseURL(ctx)
	case endpoint.FieldProtocol:
		return m.OldProtocol(ctx)
	case endpoint.FieldAuthType:
		return m.OldAuthType(ctx)
	case endpoint.FieldAuthConfig:
		return m.OldAuthConfig(ctx)
	case endpoint.FieldTimeout:
		return m.OldTimeout(ctx)
	case endpoint.FieldUseCircuitBreaker:
		return m.OldUseCircuitBreaker(ctx)
	case endpoint.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case endpoint.FieldValidateSsl:
		return m.OldValidateSsl(ctx)
	case endpoint.FieldLogRequests:
		return m.OldLogRequests(ctx)
	case endpoint.FieldLogResponses:
		return m.OldLogResponses(ctx)
	}
	return nil, fmt.Errorf("unknown Endpoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EndpointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case endpoint.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case endpoint.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case endpoint.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case endpoint.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case endpoint.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case endpoint.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case endpoint.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case endpoint.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case endpoint.FieldBaseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseURL(v)
		return nil
	case endpoint.FieldProtocol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case endpoint.FieldAuthType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthType(v)
		return nil
	case endpoint.FieldAuthConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthConfig(v)
		return nil
	case endpoint.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case endpoint.FieldUseCircuitBreaker:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseCircuitBreaker(v)
		return nil
	case endpoint.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case endpoint.FieldValidateSsl:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidateSsl(v)
		return nil
	case endpoint.FieldLogRequests:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogRequests(v)
		return nil
	case endpoint.FieldLogResponses:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogResponses(v)
		return nil
	}
	return fmt.Errorf("unknown Endpoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EndpointMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, endpoint.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, endpoint.FieldUpdatedAt)
	}
	if m.addtimeout != nil {
		fields = append(fields, endpoint.FieldTimeout)
	}
	if m.addretry_count != nil {
		fields = append(fields, endpoint.FieldRetryCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EndpointMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case endpoint.FieldCreatedAt:
		return m.AddedCreatedAt()
	case endpoint.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case endpoint.FieldTimeout:
		return m.AddedTimeout()
	case endpoint.FieldRetryCount:
		return m.AddedRetryCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EndpointMutation) AddField(name string, value ent.Value) error {
	switch name {
	case endpoint.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case endpoint.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case endpoint.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	case endpoint.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	}
	return fmt.Errorf("unknown Endpoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EndpointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(endpoint.FieldName) {
		fields = append(fields, endpoint.FieldName)
	}
	if m.FieldCleared(endpoint.FieldDescription) {
		fields = append(fields, endpoint.FieldDescription)
	}
	if m.FieldCleared(endpoint.FieldDisabled) {
		fields = append(fields, endpoint.FieldDisabled)
	}
	if m.FieldCleared(endpoint.FieldExtras) {
		fields = append(fields, endpoint.FieldExtras)
	}
	if m.FieldCleared(endpoint.FieldCreatedBy) {
		fields = append(fields, endpoint.FieldCreatedBy)
	}
	if m.FieldCleared(endpoint.FieldUpdatedBy) {
		fields = append(fields, endpoint.FieldUpdatedBy)
	}
	if m.FieldCleared(endpoint.FieldCreatedAt) {
		fields = append(fields, endpoint.FieldCreatedAt)
	}
	if m.FieldCleared(endpoint.FieldUpdatedAt) {
		fields = append(fields, endpoint.FieldUpdatedAt)
	}
	if m.FieldCleared(endpoint.FieldAuthConfig) {
		fields = append(fields, endpoint.FieldAuthConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EndpointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EndpointMutation) ClearField(name string) error {
	switch name {
	case endpoint.FieldName:
		m.ClearName()
		return nil
	case endpoint.FieldDescription:
		m.ClearDescription()
		return nil
	case endpoint.FieldDisabled:
		m.ClearDisabled()
		return nil
	case endpoint.FieldExtras:
		m.ClearExtras()
		return nil
	case endpoint.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case endpoint.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case endpoint.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case endpoint.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case endpoint.FieldAuthConfig:
		m.ClearAuthConfig()
		return nil
	}
	return fmt.Errorf("unknown Endpoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EndpointMutation) ResetField(name string) error {
	switch name {
	case endpoint.FieldName:
		m.ResetName()
		return nil
	case endpoint.FieldDescription:
		m.ResetDescription()
		return nil
	case endpoint.FieldDisabled:
		m.ResetDisabled()
		return nil
	case endpoint.FieldExtras:
		m.ResetExtras()
		return nil
	case endpoint.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case endpoint.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case endpoint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case endpoint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case endpoint.FieldBaseURL:
		m.ResetBaseURL()
		return nil
	case endpoint.FieldProtocol:
		m.ResetProtocol()
		return nil
	case endpoint.FieldAuthType:
		m.ResetAuthType()
		return nil
	case endpoint.FieldAuthConfig:
		m.ResetAuthConfig()
		return nil
	case endpoint.FieldTimeout:
		m.ResetTimeout()
		return nil
	case endpoint.FieldUseCircuitBreaker:
		m.ResetUseCircuitBreaker()
		return nil
	case endpoint.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case endpoint.FieldValidateSsl:
		m.ResetValidateSsl()
		return nil
	case endpoint.FieldLogRequests:
		m.ResetLogRequests()
		return nil
	case endpoint.FieldLogResponses:
		m.ResetLogResponses()
		return nil
	}
	return fmt.Errorf("unknown Endpoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EndpointMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EndpointMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EndpointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EndpointMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EndpointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EndpointMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EndpointMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Endpoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EndpointMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Endpoint edge %s", name)
}

// LogsMutation represents an operation that mutates the Logs nodes in the graph.
type LogsMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *int64
	addcreated_at    *int64
	updated_at       *int64
	addupdated_at    *int64
	endpoint_id      *string
	route_id         *string
	request_method   *string
	request_path     *string
	request_headers  *string
	request_body     *string
	status_code      *int
	addstatus_code   *int
	response_headers *string
	response_body    *string
	duration         *int
	addduration      *int
	error            *string
	client_ip        *string
	user_id          *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Logs, error)
	predicates       []predicate.Logs
}

var _ ent.Mutation = (*LogsMutation)(nil)

// logsOption allows management of the mutation configuration using functional options.
type logsOption func(*LogsMutation)

// newLogsMutation creates new mutation for the Logs entity.
func newLogsMutation(c config, op Op, opts ...logsOption) *LogsMutation {
	m := &LogsMutation{
		config:        c,
		op:            op,
		typ:           TypeLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogsID sets the ID field of the mutation.
func withLogsID(id string) logsOption {
	return func(m *LogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Logs
		)
		m.oldValue = func(ctx context.Context) (*Logs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Logs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogs sets the old Logs of the mutation.
func withLogs(node *Logs) logsOption {
	return func(m *LogsMutation) {
		m.oldValue = func(context.Context) (*Logs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Logs entities.
func (m *LogsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Logs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LogsMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LogsMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *LogsMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *LogsMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *LogsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[logs.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *LogsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[logs.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LogsMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, logs.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LogsMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LogsMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *LogsMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *LogsMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *LogsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[logs.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *LogsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[logs.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, logs.FieldUpdatedAt)
}

// SetEndpointID sets the "endpoint_id" field.
func (m *LogsMutation) SetEndpointID(s string) {
	m.endpoint_id = &s
}

// EndpointID returns the value of the "endpoint_id" field in the mutation.
func (m *LogsMutation) EndpointID() (r string, exists bool) {
	v := m.endpoint_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpointID returns the old "endpoint_id" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldEndpointID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpointID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpointID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpointID: %w", err)
	}
	return oldValue.EndpointID, nil
}

// ResetEndpointID resets all changes to the "endpoint_id" field.
func (m *LogsMutation) ResetEndpointID() {
	m.endpoint_id = nil
}

// SetRouteID sets the "route_id" field.
func (m *LogsMutation) SetRouteID(s string) {
	m.route_id = &s
}

// RouteID returns the value of the "route_id" field in the mutation.
func (m *LogsMutation) RouteID() (r string, exists bool) {
	v := m.route_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRouteID returns the old "route_id" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRouteID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouteID: %w", err)
	}
	return oldValue.RouteID, nil
}

// ResetRouteID resets all changes to the "route_id" field.
func (m *LogsMutation) ResetRouteID() {
	m.route_id = nil
}

// SetRequestMethod sets the "request_method" field.
func (m *LogsMutation) SetRequestMethod(s string) {
	m.request_method = &s
}

// RequestMethod returns the value of the "request_method" field in the mutation.
func (m *LogsMutation) RequestMethod() (r string, exists bool) {
	v := m.request_method
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestMethod returns the old "request_method" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRequestMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestMethod: %w", err)
	}
	return oldValue.RequestMethod, nil
}

// ResetRequestMethod resets all changes to the "request_method" field.
func (m *LogsMutation) ResetRequestMethod() {
	m.request_method = nil
}

// SetRequestPath sets the "request_path" field.
func (m *LogsMutation) SetRequestPath(s string) {
	m.request_path = &s
}

// RequestPath returns the value of the "request_path" field in the mutation.
func (m *LogsMutation) RequestPath() (r string, exists bool) {
	v := m.request_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestPath returns the old "request_path" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRequestPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestPath: %w", err)
	}
	return oldValue.RequestPath, nil
}

// ResetRequestPath resets all changes to the "request_path" field.
func (m *LogsMutation) ResetRequestPath() {
	m.request_path = nil
}

// SetRequestHeaders sets the "request_headers" field.
func (m *LogsMutation) SetRequestHeaders(s string) {
	m.request_headers = &s
}

// RequestHeaders returns the value of the "request_headers" field in the mutation.
func (m *LogsMutation) RequestHeaders() (r string, exists bool) {
	v := m.request_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestHeaders returns the old "request_headers" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRequestHeaders(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestHeaders: %w", err)
	}
	return oldValue.RequestHeaders, nil
}

// ClearRequestHeaders clears the value of the "request_headers" field.
func (m *LogsMutation) ClearRequestHeaders() {
	m.request_headers = nil
	m.clearedFields[logs.FieldRequestHeaders] = struct{}{}
}

// RequestHeadersCleared returns if the "request_headers" field was cleared in this mutation.
func (m *LogsMutation) RequestHeadersCleared() bool {
	_, ok := m.clearedFields[logs.FieldRequestHeaders]
	return ok
}

// ResetRequestHeaders resets all changes to the "request_headers" field.
func (m *LogsMutation) ResetRequestHeaders() {
	m.request_headers = nil
	delete(m.clearedFields, logs.FieldRequestHeaders)
}

// SetRequestBody sets the "request_body" field.
func (m *LogsMutation) SetRequestBody(s string) {
	m.request_body = &s
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *LogsMutation) RequestBody() (r string, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRequestBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ClearRequestBody clears the value of the "request_body" field.
func (m *LogsMutation) ClearRequestBody() {
	m.request_body = nil
	m.clearedFields[logs.FieldRequestBody] = struct{}{}
}

// RequestBodyCleared returns if the "request_body" field was cleared in this mutation.
func (m *LogsMutation) RequestBodyCleared() bool {
	_, ok := m.clearedFields[logs.FieldRequestBody]
	return ok
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *LogsMutation) ResetRequestBody() {
	m.request_body = nil
	delete(m.clearedFields, logs.FieldRequestBody)
}

// SetStatusCode sets the "status_code" field.
func (m *LogsMutation) SetStatusCode(i int) {
	m.status_code = &i
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *LogsMutation) StatusCode() (r int, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds i to the "status_code" field.
func (m *LogsMutation) AddStatusCode(i int) {
	if m.addstatus_code != nil {
		*m.addstatus_code += i
	} else {
		m.addstatus_code = &i
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *LogsMutation) AddedStatusCode() (r int, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *LogsMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
}

// SetResponseHeaders sets the "response_headers" field.
func (m *LogsMutation) SetResponseHeaders(s string) {
	m.response_headers = &s
}

// ResponseHeaders returns the value of the "response_headers" field in the mutation.
func (m *LogsMutation) ResponseHeaders() (r string, exists bool) {
	v := m.response_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseHeaders returns the old "response_headers" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldResponseHeaders(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseHeaders: %w", err)
	}
	return oldValue.ResponseHeaders, nil
}

// ClearResponseHeaders clears the value of the "response_headers" field.
func (m *LogsMutation) ClearResponseHeaders() {
	m.response_headers = nil
	m.clearedFields[logs.FieldResponseHeaders] = struct{}{}
}

// ResponseHeadersCleared returns if the "response_headers" field was cleared in this mutation.
func (m *LogsMutation) ResponseHeadersCleared() bool {
	_, ok := m.clearedFields[logs.FieldResponseHeaders]
	return ok
}

// ResetResponseHeaders resets all changes to the "response_headers" field.
func (m *LogsMutation) ResetResponseHeaders() {
	m.response_headers = nil
	delete(m.clearedFields, logs.FieldResponseHeaders)
}

// SetResponseBody sets the "response_body" field.
func (m *LogsMutation) SetResponseBody(s string) {
	m.response_body = &s
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *LogsMutation) ResponseBody() (r string, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldResponseBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *LogsMutation) ClearResponseBody() {
	m.response_body = nil
	m.clearedFields[logs.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *LogsMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[logs.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *LogsMutation) ResetResponseBody() {
	m.response_body = nil
	delete(m.clearedFields, logs.FieldResponseBody)
}

// SetDuration sets the "duration" field.
func (m *LogsMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *LogsMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *LogsMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *LogsMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *LogsMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetError sets the "error" field.
func (m *LogsMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *LogsMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *LogsMutation) ClearError() {
	m.error = nil
	m.clearedFields[logs.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *LogsMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[logs.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *LogsMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, logs.FieldError)
}

// SetClientIP sets the "client_ip" field.
func (m *LogsMutation) SetClientIP(s string) {
	m.client_ip = &s
}

// ClientIP returns the value of the "client_ip" field in the mutation.
func (m *LogsMutation) ClientIP() (r string, exists bool) {
	v := m.client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldClientIP returns the old "client_ip" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientIP: %w", err)
	}
	return oldValue.ClientIP, nil
}

// ClearClientIP clears the value of the "client_ip" field.
func (m *LogsMutation) ClearClientIP() {
	m.client_ip = nil
	m.clearedFields[logs.FieldClientIP] = struct{}{}
}

// ClientIPCleared returns if the "client_ip" field was cleared in this mutation.
func (m *LogsMutation) ClientIPCleared() bool {
	_, ok := m.clearedFields[logs.FieldClientIP]
	return ok
}

// ResetClientIP resets all changes to the "client_ip" field.
func (m *LogsMutation) ResetClientIP() {
	m.client_ip = nil
	delete(m.clearedFields, logs.FieldClientIP)
}

// SetUserID sets the "user_id" field.
func (m *LogsMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LogsMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *LogsMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[logs.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *LogsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[logs.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LogsMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, logs.FieldUserID)
}

// Where appends a list predicates to the LogsMutation builder.
func (m *LogsMutation) Where(ps ...predicate.Logs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Logs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Logs).
func (m *LogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogsMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m.endpoint_id != nil {
		fields = append(fields, logs.FieldEndpointID)
	}
	if m.route_id != nil {
		fields = append(fields, logs.FieldRouteID)
	}
	if m.request_method != nil {
		fields = append(fields, logs.FieldRequestMethod)
	}
	if m.request_path != nil {
		fields = append(fields, logs.FieldRequestPath)
	}
	if m.request_headers != nil {
		fields = append(fields, logs.FieldRequestHeaders)
	}
	if m.request_body != nil {
		fields = append(fields, logs.FieldRequestBody)
	}
	if m.status_code != nil {
		fields = append(fields, logs.FieldStatusCode)
	}
	if m.response_headers != nil {
		fields = append(fields, logs.FieldResponseHeaders)
	}
	if m.response_body != nil {
		fields = append(fields, logs.FieldResponseBody)
	}
	if m.duration != nil {
		fields = append(fields, logs.FieldDuration)
	}
	if m.error != nil {
		fields = append(fields, logs.FieldError)
	}
	if m.client_ip != nil {
		fields = append(fields, logs.FieldClientIP)
	}
	if m.user_id != nil {
		fields = append(fields, logs.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldCreatedAt:
		return m.CreatedAt()
	case logs.FieldUpdatedAt:
		return m.UpdatedAt()
	case logs.FieldEndpointID:
		return m.EndpointID()
	case logs.FieldRouteID:
		return m.RouteID()
	case logs.FieldRequestMethod:
		return m.RequestMethod()
	case logs.FieldRequestPath:
		return m.RequestPath()
	case logs.FieldRequestHeaders:
		return m.RequestHeaders()
	case logs.FieldRequestBody:
		return m.RequestBody()
	case logs.FieldStatusCode:
		return m.StatusCode()
	case logs.FieldResponseHeaders:
		return m.ResponseHeaders()
	case logs.FieldResponseBody:
		return m.ResponseBody()
	case logs.FieldDuration:
		return m.Duration()
	case logs.FieldError:
		return m.Error()
	case logs.FieldClientIP:
		return m.ClientIP()
	case logs.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case logs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case logs.FieldEndpointID:
		return m.OldEndpointID(ctx)
	case logs.FieldRouteID:
		return m.OldRouteID(ctx)
	case logs.FieldRequestMethod:
		return m.OldRequestMethod(ctx)
	case logs.FieldRequestPath:
		return m.OldRequestPath(ctx)
	case logs.FieldRequestHeaders:
		return m.OldRequestHeaders(ctx)
	case logs.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case logs.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case logs.FieldResponseHeaders:
		return m.OldResponseHeaders(ctx)
	case logs.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case logs.FieldDuration:
		return m.OldDuration(ctx)
	case logs.FieldError:
		return m.OldError(ctx)
	case logs.FieldClientIP:
		return m.OldClientIP(ctx)
	case logs.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Logs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logs.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case logs.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case logs.FieldEndpointID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpointID(v)
		return nil
	case logs.FieldRouteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouteID(v)
		return nil
	case logs.FieldRequestMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestMethod(v)
		return nil
	case logs.FieldRequestPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestPath(v)
		return nil
	case logs.FieldRequestHeaders:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestHeaders(v)
		return nil
	case logs.FieldRequestBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case logs.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case logs.FieldResponseHeaders:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseHeaders(v)
		return nil
	case logs.FieldResponseBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case logs.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case logs.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case logs.FieldClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientIP(v)
		return nil
	case logs.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogsMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m.addstatus_code != nil {
		fields = append(fields, logs.FieldStatusCode)
	}
	if m.addduration != nil {
		fields = append(fields, logs.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldCreatedAt:
		return m.AddedCreatedAt()
	case logs.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case logs.FieldStatusCode:
		return m.AddedStatusCode()
	case logs.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case logs.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case logs.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case logs.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	case logs.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Logs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logs.FieldCreatedAt) {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.FieldCleared(logs.FieldUpdatedAt) {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m.FieldCleared(logs.FieldRequestHeaders) {
		fields = append(fields, logs.FieldRequestHeaders)
	}
	if m.FieldCleared(logs.FieldRequestBody) {
		fields = append(fields, logs.FieldRequestBody)
	}
	if m.FieldCleared(logs.FieldResponseHeaders) {
		fields = append(fields, logs.FieldResponseHeaders)
	}
	if m.FieldCleared(logs.FieldResponseBody) {
		fields = append(fields, logs.FieldResponseBody)
	}
	if m.FieldCleared(logs.FieldError) {
		fields = append(fields, logs.FieldError)
	}
	if m.FieldCleared(logs.FieldClientIP) {
		fields = append(fields, logs.FieldClientIP)
	}
	if m.FieldCleared(logs.FieldUserID) {
		fields = append(fields, logs.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogsMutation) ClearField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case logs.FieldRequestHeaders:
		m.ClearRequestHeaders()
		return nil
	case logs.FieldRequestBody:
		m.ClearRequestBody()
		return nil
	case logs.FieldResponseHeaders:
		m.ClearResponseHeaders()
		return nil
	case logs.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case logs.FieldError:
		m.ClearError()
		return nil
	case logs.FieldClientIP:
		m.ClearClientIP()
		return nil
	case logs.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Logs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogsMutation) ResetField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case logs.FieldEndpointID:
		m.ResetEndpointID()
		return nil
	case logs.FieldRouteID:
		m.ResetRouteID()
		return nil
	case logs.FieldRequestMethod:
		m.ResetRequestMethod()
		return nil
	case logs.FieldRequestPath:
		m.ResetRequestPath()
		return nil
	case logs.FieldRequestHeaders:
		m.ResetRequestHeaders()
		return nil
	case logs.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case logs.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case logs.FieldResponseHeaders:
		m.ResetResponseHeaders()
		return nil
	case logs.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case logs.FieldDuration:
		m.ResetDuration()
		return nil
	case logs.FieldError:
		m.ResetError()
		return nil
	case logs.FieldClientIP:
		m.ResetClientIP()
		return nil
	case logs.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Logs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Logs edge %s", name)
}

// RouteMutation represents an operation that mutates the Route nodes in the graph.
type RouteMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	name                  *string
	description           *string
	disabled              *bool
	extras                *map[string]interface{}
	created_by            *string
	updated_by            *string
	created_at            *int64
	addcreated_at         *int64
	updated_at            *int64
	addupdated_at         *int64
	endpoint_id           *string
	path_pattern          *string
	target_path           *string
	method                *string
	input_transformer_id  *string
	output_transformer_id *string
	cache_enabled         *bool
	cache_ttl             *int
	addcache_ttl          *int
	rate_limit            *string
	strip_auth_header     *bool
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Route, error)
	predicates            []predicate.Route
}

var _ ent.Mutation = (*RouteMutation)(nil)

// routeOption allows management of the mutation configuration using functional options.
type routeOption func(*RouteMutation)

// newRouteMutation creates new mutation for the Route entity.
func newRouteMutation(c config, op Op, opts ...routeOption) *RouteMutation {
	m := &RouteMutation{
		config:        c,
		op:            op,
		typ:           TypeRoute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouteID sets the ID field of the mutation.
func withRouteID(id string) routeOption {
	return func(m *RouteMutation) {
		var (
			err   error
			once  sync.Once
			value *Route
		)
		m.oldValue = func(ctx context.Context) (*Route, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Route.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoute sets the old Route of the mutation.
func withRoute(node *Route) routeOption {
	return func(m *RouteMutation) {
		m.oldValue = func(context.Context) (*Route, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Route entities.
func (m *RouteMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouteMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouteMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Route.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RouteMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RouteMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *RouteMutation) ClearName() {
	m.name = nil
	m.clearedFields[route.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *RouteMutation) NameCleared() bool {
	_, ok := m.clearedFields[route.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *RouteMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, route.FieldName)
}

// SetDescription sets the "description" field.
func (m *RouteMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RouteMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RouteMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[route.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RouteMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[route.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RouteMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, route.FieldDescription)
}

// SetDisabled sets the "disabled" field.
func (m *RouteMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *RouteMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *RouteMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[route.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *RouteMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[route.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *RouteMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, route.FieldDisabled)
}

// SetExtras sets the "extras" field.
func (m *RouteMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *RouteMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *RouteMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[route.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *RouteMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[route.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *RouteMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, route.FieldExtras)
}

// SetCreatedBy sets the "created_by" field.
func (m *RouteMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RouteMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RouteMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[route.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RouteMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[route.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RouteMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, route.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RouteMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RouteMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RouteMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[route.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RouteMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[route.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RouteMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, route.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *RouteMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouteMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *RouteMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RouteMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RouteMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[route.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RouteMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[route.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouteMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, route.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouteMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouteMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *RouteMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RouteMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RouteMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[route.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RouteMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[route.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouteMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, route.FieldUpdatedAt)
}

// SetEndpointID sets the "endpoint_id" field.
func (m *RouteMutation) SetEndpointID(s string) {
	m.endpoint_id = &s
}

// EndpointID returns the value of the "endpoint_id" field in the mutation.
func (m *RouteMutation) EndpointID() (r string, exists bool) {
	v := m.endpoint_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpointID returns the old "endpoint_id" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldEndpointID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpointID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpointID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpointID: %w", err)
	}
	return oldValue.EndpointID, nil
}

// ResetEndpointID resets all changes to the "endpoint_id" field.
func (m *RouteMutation) ResetEndpointID() {
	m.endpoint_id = nil
}

// SetPathPattern sets the "path_pattern" field.
func (m *RouteMutation) SetPathPattern(s string) {
	m.path_pattern = &s
}

// PathPattern returns the value of the "path_pattern" field in the mutation.
func (m *RouteMutation) PathPattern() (r string, exists bool) {
	v := m.path_pattern
	if v == nil {
		return
	}
	return *v, true
}

// OldPathPattern returns the old "path_pattern" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldPathPattern(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPathPattern is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPathPattern requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPathPattern: %w", err)
	}
	return oldValue.PathPattern, nil
}

// ResetPathPattern resets all changes to the "path_pattern" field.
func (m *RouteMutation) ResetPathPattern() {
	m.path_pattern = nil
}

// SetTargetPath sets the "target_path" field.
func (m *RouteMutation) SetTargetPath(s string) {
	m.target_path = &s
}

// TargetPath returns the value of the "target_path" field in the mutation.
func (m *RouteMutation) TargetPath() (r string, exists bool) {
	v := m.target_path
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetPath returns the old "target_path" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldTargetPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetPath: %w", err)
	}
	return oldValue.TargetPath, nil
}

// ResetTargetPath resets all changes to the "target_path" field.
func (m *RouteMutation) ResetTargetPath() {
	m.target_path = nil
}

// SetMethod sets the "method" field.
func (m *RouteMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *RouteMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *RouteMutation) ResetMethod() {
	m.method = nil
}

// SetInputTransformerID sets the "input_transformer_id" field.
func (m *RouteMutation) SetInputTransformerID(s string) {
	m.input_transformer_id = &s
}

// InputTransformerID returns the value of the "input_transformer_id" field in the mutation.
func (m *RouteMutation) InputTransformerID() (r string, exists bool) {
	v := m.input_transformer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInputTransformerID returns the old "input_transformer_id" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldInputTransformerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputTransformerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputTransformerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputTransformerID: %w", err)
	}
	return oldValue.InputTransformerID, nil
}

// ClearInputTransformerID clears the value of the "input_transformer_id" field.
func (m *RouteMutation) ClearInputTransformerID() {
	m.input_transformer_id = nil
	m.clearedFields[route.FieldInputTransformerID] = struct{}{}
}

// InputTransformerIDCleared returns if the "input_transformer_id" field was cleared in this mutation.
func (m *RouteMutation) InputTransformerIDCleared() bool {
	_, ok := m.clearedFields[route.FieldInputTransformerID]
	return ok
}

// ResetInputTransformerID resets all changes to the "input_transformer_id" field.
func (m *RouteMutation) ResetInputTransformerID() {
	m.input_transformer_id = nil
	delete(m.clearedFields, route.FieldInputTransformerID)
}

// SetOutputTransformerID sets the "output_transformer_id" field.
func (m *RouteMutation) SetOutputTransformerID(s string) {
	m.output_transformer_id = &s
}

// OutputTransformerID returns the value of the "output_transformer_id" field in the mutation.
func (m *RouteMutation) OutputTransformerID() (r string, exists bool) {
	v := m.output_transformer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputTransformerID returns the old "output_transformer_id" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldOutputTransformerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputTransformerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputTransformerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputTransformerID: %w", err)
	}
	return oldValue.OutputTransformerID, nil
}

// ClearOutputTransformerID clears the value of the "output_transformer_id" field.
func (m *RouteMutation) ClearOutputTransformerID() {
	m.output_transformer_id = nil
	m.clearedFields[route.FieldOutputTransformerID] = struct{}{}
}

// OutputTransformerIDCleared returns if the "output_transformer_id" field was cleared in this mutation.
func (m *RouteMutation) OutputTransformerIDCleared() bool {
	_, ok := m.clearedFields[route.FieldOutputTransformerID]
	return ok
}

// ResetOutputTransformerID resets all changes to the "output_transformer_id" field.
func (m *RouteMutation) ResetOutputTransformerID() {
	m.output_transformer_id = nil
	delete(m.clearedFields, route.FieldOutputTransformerID)
}

// SetCacheEnabled sets the "cache_enabled" field.
func (m *RouteMutation) SetCacheEnabled(b bool) {
	m.cache_enabled = &b
}

// CacheEnabled returns the value of the "cache_enabled" field in the mutation.
func (m *RouteMutation) CacheEnabled() (r bool, exists bool) {
	v := m.cache_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheEnabled returns the old "cache_enabled" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldCacheEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheEnabled: %w", err)
	}
	return oldValue.CacheEnabled, nil
}

// ResetCacheEnabled resets all changes to the "cache_enabled" field.
func (m *RouteMutation) ResetCacheEnabled() {
	m.cache_enabled = nil
}

// SetCacheTTL sets the "cache_ttl" field.
func (m *RouteMutation) SetCacheTTL(i int) {
	m.cache_ttl = &i
	m.addcache_ttl = nil
}

// CacheTTL returns the value of the "cache_ttl" field in the mutation.
func (m *RouteMutation) CacheTTL() (r int, exists bool) {
	v := m.cache_ttl
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheTTL returns the old "cache_ttl" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldCacheTTL(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheTTL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheTTL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheTTL: %w", err)
	}
	return oldValue.CacheTTL, nil
}

// AddCacheTTL adds i to the "cache_ttl" field.
func (m *RouteMutation) AddCacheTTL(i int) {
	if m.addcache_ttl != nil {
		*m.addcache_ttl += i
	} else {
		m.addcache_ttl = &i
	}
}

// AddedCacheTTL returns the value that was added to the "cache_ttl" field in this mutation.
func (m *RouteMutation) AddedCacheTTL() (r int, exists bool) {
	v := m.addcache_ttl
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheTTL resets all changes to the "cache_ttl" field.
func (m *RouteMutation) ResetCacheTTL() {
	m.cache_ttl = nil
	m.addcache_ttl = nil
}

// SetRateLimit sets the "rate_limit" field.
func (m *RouteMutation) SetRateLimit(s string) {
	m.rate_limit = &s
}

// RateLimit returns the value of the "rate_limit" field in the mutation.
func (m *RouteMutation) RateLimit() (r string, exists bool) {
	v := m.rate_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldRateLimit returns the old "rate_limit" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldRateLimit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateLimit: %w", err)
	}
	return oldValue.RateLimit, nil
}

// ClearRateLimit clears the value of the "rate_limit" field.
func (m *RouteMutation) ClearRateLimit() {
	m.rate_limit = nil
	m.clearedFields[route.FieldRateLimit] = struct{}{}
}

// RateLimitCleared returns if the "rate_limit" field was cleared in this mutation.
func (m *RouteMutation) RateLimitCleared() bool {
	_, ok := m.clearedFields[route.FieldRateLimit]
	return ok
}

// ResetRateLimit resets all changes to the "rate_limit" field.
func (m *RouteMutation) ResetRateLimit() {
	m.rate_limit = nil
	delete(m.clearedFields, route.FieldRateLimit)
}

// SetStripAuthHeader sets the "strip_auth_header" field.
func (m *RouteMutation) SetStripAuthHeader(b bool) {
	m.strip_auth_header = &b
}

// StripAuthHeader returns the value of the "strip_auth_header" field in the mutation.
func (m *RouteMutation) StripAuthHeader() (r bool, exists bool) {
	v := m.strip_auth_header
	if v == nil {
		return
	}
	return *v, true
}

// OldStripAuthHeader returns the old "strip_auth_header" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldStripAuthHeader(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripAuthHeader is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripAuthHeader requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripAuthHeader: %w", err)
	}
	return oldValue.StripAuthHeader, nil
}

// ResetStripAuthHeader resets all changes to the "strip_auth_header" field.
func (m *RouteMutation) ResetStripAuthHeader() {
	m.strip_auth_header = nil
}

// Where appends a list predicates to the RouteMutation builder.
func (m *RouteMutation) Where(ps ...predicate.Route) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Route, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Route).
func (m *RouteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouteMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.name != nil {
		fields = append(fields, route.FieldName)
	}
	if m.description != nil {
		fields = append(fields, route.FieldDescription)
	}
	if m.disabled != nil {
		fields = append(fields, route.FieldDisabled)
	}
	if m.extras != nil {
		fields = append(fields, route.FieldExtras)
	}
	if m.created_by != nil {
		fields = append(fields, route.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, route.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, route.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, route.FieldUpdatedAt)
	}
	if m.endpoint_id != nil {
		fields = append(fields, route.FieldEndpointID)
	}
	if m.path_pattern != nil {
		fields = append(fields, route.FieldPathPattern)
	}
	if m.target_path != nil {
		fields = append(fields, route.FieldTargetPath)
	}
	if m.method != nil {
		fields = append(fields, route.FieldMethod)
	}
	if m.input_transformer_id != nil {
		fields = append(fields, route.FieldInputTransformerID)
	}
	if m.output_transformer_id != nil {
		fields = append(fields, route.FieldOutputTransformerID)
	}
	if m.cache_enabled != nil {
		fields = append(fields, route.FieldCacheEnabled)
	}
	if m.cache_ttl != nil {
		fields = append(fields, route.FieldCacheTTL)
	}
	if m.rate_limit != nil {
		fields = append(fields, route.FieldRateLimit)
	}
	if m.strip_auth_header != nil {
		fields = append(fields, route.FieldStripAuthHeader)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case route.FieldName:
		return m.Name()
	case route.FieldDescription:
		return m.Description()
	case route.FieldDisabled:
		return m.Disabled()
	case route.FieldExtras:
		return m.Extras()
	case route.FieldCreatedBy:
		return m.CreatedBy()
	case route.FieldUpdatedBy:
		return m.UpdatedBy()
	case route.FieldCreatedAt:
		return m.CreatedAt()
	case route.FieldUpdatedAt:
		return m.UpdatedAt()
	case route.FieldEndpointID:
		return m.EndpointID()
	case route.FieldPathPattern:
		return m.PathPattern()
	case route.FieldTargetPath:
		return m.TargetPath()
	case route.FieldMethod:
		return m.Method()
	case route.FieldInputTransformerID:
		return m.InputTransformerID()
	case route.FieldOutputTransformerID:
		return m.OutputTransformerID()
	case route.FieldCacheEnabled:
		return m.CacheEnabled()
	case route.FieldCacheTTL:
		return m.CacheTTL()
	case route.FieldRateLimit:
		return m.RateLimit()
	case route.FieldStripAuthHeader:
		return m.StripAuthHeader()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case route.FieldName:
		return m.OldName(ctx)
	case route.FieldDescription:
		return m.OldDescription(ctx)
	case route.FieldDisabled:
		return m.OldDisabled(ctx)
	case route.FieldExtras:
		return m.OldExtras(ctx)
	case route.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case route.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case route.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case route.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case route.FieldEndpointID:
		return m.OldEndpointID(ctx)
	case route.FieldPathPattern:
		return m.OldPathPattern(ctx)
	case route.FieldTargetPath:
		return m.OldTargetPath(ctx)
	case route.FieldMethod:
		return m.OldMethod(ctx)
	case route.FieldInputTransformerID:
		return m.OldInputTransformerID(ctx)
	case route.FieldOutputTransformerID:
		return m.OldOutputTransformerID(ctx)
	case route.FieldCacheEnabled:
		return m.OldCacheEnabled(ctx)
	case route.FieldCacheTTL:
		return m.OldCacheTTL(ctx)
	case route.FieldRateLimit:
		return m.OldRateLimit(ctx)
	case route.FieldStripAuthHeader:
		return m.OldStripAuthHeader(ctx)
	}
	return nil, fmt.Errorf("unknown Route field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case route.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case route.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case route.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case route.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case route.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case route.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case route.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case route.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case route.FieldEndpointID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpointID(v)
		return nil
	case route.FieldPathPattern:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPathPattern(v)
		return nil
	case route.FieldTargetPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetPath(v)
		return nil
	case route.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case route.FieldInputTransformerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputTransformerID(v)
		return nil
	case route.FieldOutputTransformerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputTransformerID(v)
		return nil
	case route.FieldCacheEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheEnabled(v)
		return nil
	case route.FieldCacheTTL:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheTTL(v)
		return nil
	case route.FieldRateLimit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateLimit(v)
		return nil
	case route.FieldStripAuthHeader:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripAuthHeader(v)
		return nil
	}
	return fmt.Errorf("unknown Route field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouteMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, route.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, route.FieldUpdatedAt)
	}
	if m.addcache_ttl != nil {
		fields = append(fields, route.FieldCacheTTL)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case route.FieldCreatedAt:
		return m.AddedCreatedAt()
	case route.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case route.FieldCacheTTL:
		return m.AddedCacheTTL()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case route.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case route.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case route.FieldCacheTTL:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheTTL(v)
		return nil
	}
	return fmt.Errorf("unknown Route numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(route.FieldName) {
		fields = append(fields, route.FieldName)
	}
	if m.FieldCleared(route.FieldDescription) {
		fields = append(fields, route.FieldDescription)
	}
	if m.FieldCleared(route.FieldDisabled) {
		fields = append(fields, route.FieldDisabled)
	}
	if m.FieldCleared(route.FieldExtras) {
		fields = append(fields, route.FieldExtras)
	}
	if m.FieldCleared(route.FieldCreatedBy) {
		fields = append(fields, route.FieldCreatedBy)
	}
	if m.FieldCleared(route.FieldUpdatedBy) {
		fields = append(fields, route.FieldUpdatedBy)
	}
	if m.FieldCleared(route.FieldCreatedAt) {
		fields = append(fields, route.FieldCreatedAt)
	}
	if m.FieldCleared(route.FieldUpdatedAt) {
		fields = append(fields, route.FieldUpdatedAt)
	}
	if m.FieldCleared(route.FieldInputTransformerID) {
		fields = append(fields, route.FieldInputTransformerID)
	}
	if m.FieldCleared(route.FieldOutputTransformerID) {
		fields = append(fields, route.FieldOutputTransformerID)
	}
	if m.FieldCleared(route.FieldRateLimit) {
		fields = append(fields, route.FieldRateLimit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouteMutation) ClearField(name string) error {
	switch name {
	case route.FieldName:
		m.ClearName()
		return nil
	case route.FieldDescription:
		m.ClearDescription()
		return nil
	case route.FieldDisabled:
		m.ClearDisabled()
		return nil
	case route.FieldExtras:
		m.ClearExtras()
		return nil
	case route.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case route.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case route.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case route.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case route.FieldInputTransformerID:
		m.ClearInputTransformerID()
		return nil
	case route.FieldOutputTransformerID:
		m.ClearOutputTransformerID()
		return nil
	case route.FieldRateLimit:
		m.ClearRateLimit()
		return nil
	}
	return fmt.Errorf("unknown Route nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouteMutation) ResetField(name string) error {
	switch name {
	case route.FieldName:
		m.ResetName()
		return nil
	case route.FieldDescription:
		m.ResetDescription()
		return nil
	case route.FieldDisabled:
		m.ResetDisabled()
		return nil
	case route.FieldExtras:
		m.ResetExtras()
		return nil
	case route.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case route.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case route.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case route.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case route.FieldEndpointID:
		m.ResetEndpointID()
		return nil
	case route.FieldPathPattern:
		m.ResetPathPattern()
		return nil
	case route.FieldTargetPath:
		m.ResetTargetPath()
		return nil
	case route.FieldMethod:
		m.ResetMethod()
		return nil
	case route.FieldInputTransformerID:
		m.ResetInputTransformerID()
		return nil
	case route.FieldOutputTransformerID:
		m.ResetOutputTransformerID()
		return nil
	case route.FieldCacheEnabled:
		m.ResetCacheEnabled()
		return nil
	case route.FieldCacheTTL:
		m.ResetCacheTTL()
		return nil
	case route.FieldRateLimit:
		m.ResetRateLimit()
		return nil
	case route.FieldStripAuthHeader:
		m.ResetStripAuthHeader()
		return nil
	}
	return fmt.Errorf("unknown Route field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouteMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouteMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouteMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouteMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Route unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouteMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Route edge %s", name)
}

// TransformerMutation represents an operation that mutates the Transformer nodes in the graph.
type TransformerMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	description   *string
	disabled      *bool
	extras        *map[string]interface{}
	created_by    *string
	updated_by    *string
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	_type         *string
	content       *string
	content_type  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Transformer, error)
	predicates    []predicate.Transformer
}

var _ ent.Mutation = (*TransformerMutation)(nil)

// transformerOption allows management of the mutation configuration using functional options.
type transformerOption func(*TransformerMutation)

// newTransformerMutation creates new mutation for the Transformer entity.
func newTransformerMutation(c config, op Op, opts ...transformerOption) *TransformerMutation {
	m := &TransformerMutation{
		config:        c,
		op:            op,
		typ:           TypeTransformer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransformerID sets the ID field of the mutation.
func withTransformerID(id string) transformerOption {
	return func(m *TransformerMutation) {
		var (
			err   error
			once  sync.Once
			value *Transformer
		)
		m.oldValue = func(ctx context.Context) (*Transformer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transformer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransformer sets the old Transformer of the mutation.
func withTransformer(node *Transformer) transformerOption {
	return func(m *TransformerMutation) {
		m.oldValue = func(context.Context) (*Transformer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransformerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransformerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transformer entities.
func (m *TransformerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransformerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransformerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transformer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TransformerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TransformerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Transformer entity.
// If the Transformer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransformerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TransformerMutation) ClearName() {
	m.name = nil
	m.clearedFields[transformer.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TransformerMutation) NameCleared() bool {
	_, ok := m.clearedFields[transformer.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TransformerMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, transformer.FieldName)
}

// SetDescription sets the "description" field.
func (m *TransformerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TransformerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Transformer entity.
// If the Transformer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransformerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TransformerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[transformer.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TransformerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[transformer.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TransformerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, transformer.FieldDescription)
}

// SetDisabled sets the "disabled" field.
func (m *TransformerMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *TransformerMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Transformer entity.
// If the Transformer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransformerMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *TransformerMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[transformer.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *TransformerMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[transformer.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *TransformerMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, transformer.FieldDisabled)
}

// SetExtras sets the "extras" field.
func (m *TransformerMutation) SetExtras(value map[string]interface{}) {
	m.extras = &value
}

// Extras returns the value of the "extras" field in the mutation.
func (m *TransformerMutation) Extras() (r map[string]interface{}, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Transformer entity.
// If the Transformer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransformerMutation) OldExtras(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *TransformerMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[transformer.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *TransformerMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[transformer.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *TransformerMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, transformer.FieldExtras)
}

// SetCreatedBy sets the "created_by" field.
func (m *TransformerMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TransformerMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Transformer entity.
// If the Transformer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransformerMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TransformerMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[transformer.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TransformerMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[transformer.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TransformerMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, transformer.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TransformerMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TransformerMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Transformer entity.
// If the Transformer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransformerMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TransformerMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[transformer.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TransformerMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[transformer.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TransformerMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, transformer.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *TransformerMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransformerMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transformer entity.
// If the Transformer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransformerMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *TransformerMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TransformerMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TransformerMutation) ClearCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	m.clearedFields[transformer.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TransformerMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[transformer.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransformerMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
	delete(m.clearedFields, transformer.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransformerMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransformerMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transformer entity.
// If the Transformer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransformerMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *TransformerMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TransformerMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TransformerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	m.clearedFields[transformer.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TransformerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[transformer.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransformerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
	delete(m.clearedFields, transformer.FieldUpdatedAt)
}

// SetType sets the "type" field.
func (m *TransformerMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransformerMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transformer entity.
// If the Transformer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransformerMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransformerMutation) ResetType() {
	m._type = nil
}

// SetContent sets the "content" field.
func (m *TransformerMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *TransformerMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Transformer entity.
// If the Transformer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransformerMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *TransformerMutation) ResetContent() {
	m.content = nil
}

// SetContentType sets the "content_type" field.
func (m *TransformerMutation) SetContentType(s string) {
	m.content_type = &s
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *TransformerMutation) ContentType() (r string, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the Transformer entity.
// If the Transformer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransformerMutation) OldContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ResetContentType resets all changes to the "content_type" field.
func (m *TransformerMutation) ResetContentType() {
	m.content_type = nil
}

// Where appends a list predicates to the TransformerMutation builder.
func (m *TransformerMutation) Where(ps ...predicate.Transformer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransformerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransformerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transformer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransformerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransformerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transformer).
func (m *TransformerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransformerMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, transformer.FieldName)
	}
	if m.description != nil {
		fields = append(fields, transformer.FieldDescription)
	}
	if m.disabled != nil {
		fields = append(fields, transformer.FieldDisabled)
	}
	if m.extras != nil {
		fields = append(fields, transformer.FieldExtras)
	}
	if m.created_by != nil {
		fields = append(fields, transformer.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, transformer.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, transformer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transformer.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, transformer.FieldType)
	}
	if m.content != nil {
		fields = append(fields, transformer.FieldContent)
	}
	if m.content_type != nil {
		fields = append(fields, transformer.FieldContentType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransformerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transformer.FieldName:
		return m.Name()
	case transformer.FieldDescription:
		return m.Description()
	case transformer.FieldDisabled:
		return m.Disabled()
	case transformer.FieldExtras:
		return m.Extras()
	case transformer.FieldCreatedBy:
		return m.CreatedBy()
	case transformer.FieldUpdatedBy:
		return m.UpdatedBy()
	case transformer.FieldCreatedAt:
		return m.CreatedAt()
	case transformer.FieldUpdatedAt:
		return m.UpdatedAt()
	case transformer.FieldType:
		return m.GetType()
	case transformer.FieldContent:
		return m.Content()
	case transformer.FieldContentType:
		return m.ContentType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransformerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transformer.FieldName:
		return m.OldName(ctx)
	case transformer.FieldDescription:
		return m.OldDescription(ctx)
	case transformer.FieldDisabled:
		return m.OldDisabled(ctx)
	case transformer.FieldExtras:
		return m.OldExtras(ctx)
	case transformer.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case transformer.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case transformer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transformer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transformer.FieldType:
		return m.OldType(ctx)
	case transformer.FieldContent:
		return m.OldContent(ctx)
	case transformer.FieldContentType:
		return m.OldContentType(ctx)
	}
	return nil, fmt.Errorf("unknown Transformer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransformerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transformer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case transformer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case transformer.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case transformer.FieldExtras:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	case transformer.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case transformer.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case transformer.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transformer.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transformer.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transformer.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case transformer.FieldContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	}
	return fmt.Errorf("unknown Transformer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransformerMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, transformer.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, transformer.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransformerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transformer.FieldCreatedAt:
		return m.AddedCreatedAt()
	case transformer.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransformerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transformer.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case transformer.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Transformer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransformerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transformer.FieldName) {
		fields = append(fields, transformer.FieldName)
	}
	if m.FieldCleared(transformer.FieldDescription) {
		fields = append(fields, transformer.FieldDescription)
	}
	if m.FieldCleared(transformer.FieldDisabled) {
		fields = append(fields, transformer.FieldDisabled)
	}
	if m.FieldCleared(transformer.FieldExtras) {
		fields = append(fields, transformer.FieldExtras)
	}
	if m.FieldCleared(transformer.FieldCreatedBy) {
		fields = append(fields, transformer.FieldCreatedBy)
	}
	if m.FieldCleared(transformer.FieldUpdatedBy) {
		fields = append(fields, transformer.FieldUpdatedBy)
	}
	if m.FieldCleared(transformer.FieldCreatedAt) {
		fields = append(fields, transformer.FieldCreatedAt)
	}
	if m.FieldCleared(transformer.FieldUpdatedAt) {
		fields = append(fields, transformer.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransformerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransformerMutation) ClearField(name string) error {
	switch name {
	case transformer.FieldName:
		m.ClearName()
		return nil
	case transformer.FieldDescription:
		m.ClearDescription()
		return nil
	case transformer.FieldDisabled:
		m.ClearDisabled()
		return nil
	case transformer.FieldExtras:
		m.ClearExtras()
		return nil
	case transformer.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case transformer.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case transformer.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case transformer.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Transformer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransformerMutation) ResetField(name string) error {
	switch name {
	case transformer.FieldName:
		m.ResetName()
		return nil
	case transformer.FieldDescription:
		m.ResetDescription()
		return nil
	case transformer.FieldDisabled:
		m.ResetDisabled()
		return nil
	case transformer.FieldExtras:
		m.ResetExtras()
		return nil
	case transformer.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case transformer.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case transformer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transformer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transformer.FieldType:
		m.ResetType()
		return nil
	case transformer.FieldContent:
		m.ResetContent()
		return nil
	case transformer.FieldContentType:
		m.ResetContentType()
		return nil
	}
	return fmt.Errorf("unknown Transformer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransformerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransformerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransformerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransformerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransformerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransformerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransformerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Transformer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransformerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Transformer edge %s", name)
}
